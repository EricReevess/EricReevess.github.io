<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>React 架构与源码理解</title>
      <link href="/2024/02/29/react-sourcecode/"/>
      <url>/2024/02/29/react-sourcecode/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2023年7月31日，毕业2年后被裁员失业，只能说塞翁失马,焉知非福。</p><p>从毕业上班开始，React Hook 已经替代了 Class 组件成为官方推崇的主流，平时上班一直想抽空学习 React 的源码，但是零散时间根本没法集中。<br>趁着去年8月失业的这段时间，集中最近看了卡颂老师的<a href="https://react.iamkasong.com/">React 技术揭秘</a>，用记录方式写下对React源码和架构的理解，文中有对原文的直接或间接引用。</p><p>2024年1月25日再一次被裁员失业，但需温故知新，重新出发。</p><h2 id="React架构"><a href="#React架构" class="headerlink" title="React架构"></a>React架构</h2><h3 id="React-15-架构"><a href="#React-15-架构" class="headerlink" title="React 15 架构"></a>React 15 架构</h3><p>分为两层：</p><ul><li>Reconciler（协调器）：负责找出变化的组件</li><li>Renderer（渲染器）  ：负责将变化的组件渲染到页面上</li></ul><h4 id="Reconciler-协调器"><a href="#Reconciler-协调器" class="headerlink" title="Reconciler 协调器"></a>Reconciler 协调器</h4><p>对触发更新进行一系列操作：</p><ul><li>调用函数组件、类组件的render方法，将返回的JSX借助babel转换成js然后递归创建虚拟DOM</li><li>将虚拟DOM和上次更新时的虚拟DOM对比</li><li>通过对比找出本次更新中变化的虚拟DOM</li><li>通知Renderer将变化的虚拟DOM渲染到页面上</li></ul><h4 id="Render-渲染器"><a href="#Render-渲染器" class="headerlink" title="Render 渲染器"></a>Render 渲染器</h4><p>接受 Reconciler 通知的更新，重新渲染发生变化的组件</p><h4 id="React-15-架构产生的问题"><a href="#React-15-架构产生的问题" class="headerlink" title="React 15 架构产生的问题"></a>React 15 架构产生的问题</h4><p>在 React 15 的版本中，协调器和渲染器交替执行，即找到了差异就直接更新差异，让后将多个差异进行批处理<br>协调器使用递归进行DOM树的差异对比，当DOM树一定深度或者页面元素较多时，整个递归更新时间超过了1帧的生成时间16.6ms，如果页面存在交互或者动画，那么就会产生卡顿。</p><h3 id="React-16-架构"><a href="#React-16-架构" class="headerlink" title="React 16 架构"></a>React 16 架构</h3><p>分为三层：<br>调度层：调度任务的优先级，将任务细分优先级<br>协调层：构建Fiber 数据结构，通过 Fiber 对象对比差异，记录产生的差异对 DOM 的操作<br>渲染层：负责将更改内容渲染到页面上，也就是 VDOM 到 DOM</p><h4 id="浏览器空闲时间"><a href="#浏览器空闲时间" class="headerlink" title="浏览器空闲时间"></a>浏览器空闲时间</h4><p>这里指的浏览器空闲时间是在现代浏览器以60帧每秒的屏幕刷新率下，每一帧的生成时间16.6ms中，主线程执行完任务的空闲时间，React 16 正是利用了这部分时间，将不同优先级的任务分配到这些有限的时间片中，来避免对主线程产生长时间的占用。</p><h4 id="Scheduler-调度层"><a href="#Scheduler-调度层" class="headerlink" title="Scheduler 调度层"></a>Scheduler 调度层</h4><p>React 15 没有调度层，使用了 js 自身的递归去遍历 虚拟DOM，js的递归一旦开始就无法暂停，如果当虚拟DOM树过于庞大，或者说层次比较深，那么就会长时间占用js主线程，影响页面的交互，和动画。<br>React 16 于2016年开发，17年下半年发布，放弃了 React 15 的递归VDOM对比，使用循环来模拟递归，对比过程使用浏览器的空闲时间完成，不会长期占用js主线程，避免了对比 VDOM 时对页面造成的卡顿</p><blockquote><p><strong>MDN：</strong><br><strong>requestIdleCallback</strong> 是一个用于在浏览器空闲时执行任务的 API，它允许开发者在不影响用户体验的情况下执行一些较为耗时的任务。这个 API 最早由 Google Chrome 团队提出，并于2015年在 Chrome 浏览器中首次实现。由于不是每个浏览器都支持<strong>requestIdleCallback，React最后没有采用该api</strong></p></blockquote><p>React 16 中使用的是React 团队自己实现的任务调度库package/scheduler，可以实现在浏览器空闲时执行任务，而且还可以设置任务的优先级，高优先级任务先执行，低优先级任务后执行。</p><p>使用循环模拟可中断任务实现的伪代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空闲执行 伪代码</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">workLoop</span>(<span class="params">deadline</span>) &#123;</span><br><span class="line">  <span class="comment">// 停止循环标识</span></span><br><span class="line">  <span class="keyword">let</span> shouldYield = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环条件为存在下一个工作单元，且没有更高优先级的工作</span></span><br><span class="line">  <span class="keyword">while</span> (nextUnitOfWork &amp;&amp; !shouldYield) &#123;</span><br><span class="line">    nextUnitOfWork = <span class="title function_">performUnitOfWork</span>(</span><br><span class="line">        nextUnitOfWork</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 当前帧空余时间要没了，停止工作循环</span></span><br><span class="line">    shouldYield = deadline.<span class="title function_">timeRemaining</span>() &lt; <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 下一个周期空闲时间再执行任务</span></span><br><span class="line">  <span class="title function_">requestIdleCallback</span>(workLoop)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空闲时间执行任务</span></span><br><span class="line"><span class="title function_">requestIdleCallback</span>(workLoop)</span><br></pre></td></tr></table></figure><h4 id="Reconciler-协调层-（负责计算更新）"><a href="#Reconciler-协调层-（负责计算更新）" class="headerlink" title="Reconciler 协调层 （负责计算更新）"></a>Reconciler 协调层 （负责计算更新）</h4><p>React 15 中 的协调器绑定了渲染器，只要协调器找到了差异就立即调用渲染器更新页面，寻找差异和渲染是交叉进行的，也就是说渲染完上一个差异后，再寻找下一个差异。<br>但是在React 16 中，将协调器reconciler和渲染器render 分开了，使用了一个新的Fiber 数据结构 对象代替了 React 15 的 虚拟DOM，并且 Fiber 配合协同 scheduler ，可以将 render 阶段的任务拆分。<br>协调器会找出所有差异后，再将差异统一交给渲染器进行更新，协调器的任务就是将差异部分Fiber打上<strong>标记</strong><br>所以说，从React15到React16，协调器（Reconciler）重构的一大目的是：将老的<strong>同步更新</strong>的架构变为<strong>异步可中断更新</strong>。</p><h4 id="Render-渲染器-1"><a href="#Render-渲染器-1" class="headerlink" title="Render 渲染器"></a>Render 渲染器</h4><p>根据 Fiber 节点的标记，同步更新对应的DOM<br>Render在执行渲染操作的过程中被设定为不可被打断，而 scheduler 和 reconciler 的任务设定为可以被打断的</p><h2 id="代数效应（Algebraic-Effects）"><a href="#代数效应（Algebraic-Effects）" class="headerlink" title="代数效应（Algebraic Effects）"></a>代数效应（Algebraic Effects）</h2><blockquote><p>React核心团队成员<a href="https://github.com/sebmarkbage/">Sebastian Markbåge(opens new window)</a>（React Hooks的发明者）曾说：我们在React中做的就是践行代数效应（Algebraic Effects）。</p></blockquote><p>代数效应是<strong>函数式编程</strong>中的一个概念，用于将<strong>副作用</strong>从<strong>函数</strong>调用中<strong>分离</strong>。</p><h3 id="函数式编程与副作用"><a href="#函数式编程与副作用" class="headerlink" title="函数式编程与副作用"></a>函数式编程与副作用</h3><p>在函数式编程中，强调的是函数的”纯粹性”（purity），纯粹的函数不会产生副作用，其输出只依赖于输入，不会影响外部状态。这种纯粹性使得函数更易于测试、推理和组合。<br><strong>副作用</strong>是指函数的执行会对<strong>函数程序外部的状态</strong>或其他部分产生可观察的影响，这些影响不仅仅体现在函数的返回值上。这种影响可以包括但不限于：</p><ol><li><strong>修改外部状态：</strong> 如果函数修改了外部变量、数据结构或状态，这被认为是副作用。例如，修改全局变量、数组或对象的值。</li><li><strong>I/O 操作：</strong> 与外部世界的交互，如读取或写入文件、发送或接收网络请求、数据库查询等，都会引发副作用，因为它们会影响系统状态。</li><li><strong>界面交互：</strong> 当函数导致了用户界面上的可见变化，例如弹出对话框、更新屏幕上的内容或改变网页中的DOM结构，这也被认为是副作用。</li></ol><h3 id="代数效应思想"><a href="#代数效应思想" class="headerlink" title="代数效应思想"></a>代数效应思想</h3><p>由于js没有原生实现代数效应的机制，代数效应的思想可以用类似于 try catch 的模式进行虚构一个语法<br>平时我们编写业务时需要在同步函数里面依次使用请求获取一些值，这些都是异步操作例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getTotalPicNum</span>(<span class="params">user1, user2</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> picNum1 = <span class="title function_">getPicNum</span>(user1);</span><br><span class="line">  <span class="keyword">const</span> picNum2 = <span class="title function_">getPicNum</span>(user2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> picNum1 + picNum2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如<code>getPicNum</code>是一个异步请求，如果我们需要通过这个异步请求获取器结果，我们通常需要使用async/await</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getTotalPicNum</span>(<span class="params">user1, user2</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> picNum1 = <span class="keyword">await</span> <span class="title function_">getPicNum</span>(user1);</span><br><span class="line">  <span class="keyword">const</span> picNum2 = <span class="keyword">await</span> <span class="title function_">getPicNum</span>(user2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> picNum1 + picNum2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然可以解决问题，但是async改变了getTotalPicNum作为同步函数的调用方法，一般来说async function 具有传染性，会使其调用函数也变为async，会破坏本应该为同步函数的特性<br>那么有没有一种办法能保持getTotalPicNum 的同步特征呢？js没有提供，但是我们可以使用代数效应思想结合try/catch 虚构一个 语法 try/handle 关键字preform/resume<br>传统的try/catch在 try 代码块抛出异常时，那么就会终止执行代码块，转去执行 catch 代码块，错误之后的代码无法被执行，而try/handle 则不同。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getPicNum</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> picNum = perform name;</span><br><span class="line">  <span class="keyword">return</span> picNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title function_">getTotalPicNum</span>(<span class="string">&#x27;kaSong&#x27;</span>, <span class="string">&#x27;xiaoMing&#x27;</span>);</span><br><span class="line">&#125; handle (who) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (who) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;kaSong&#x27;</span>:</span><br><span class="line">      resume <span class="keyword">with</span> <span class="number">230</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;xiaoMing&#x27;</span>:</span><br><span class="line">      resume <span class="keyword">with</span> <span class="number">122</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      resume <span class="keyword">with</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述语法中，当遇到perform 关键字时，就会携带参数转去handle 代码块中执行分支代码，最终使用resume 将结果返回给 perform 左边的变量，而函数getPicNum getTotalPicNum的类型也都未改变，这样分离函数的副作用到handle中，避免了对原函数的影响，实现了关注点分离的效果。</p><h3 id="React中的代数效应"><a href="#React中的代数效应" class="headerlink" title="React中的代数效应"></a>React中的代数效应</h3><p>React Hooks 是对 代数效应的一种实践。<br>Hooks为React 函数组件带来了生命周期和状态管理，并且，则不需要改变函数组件的性质（例如前面类似于加个hook function之类的），函数组件内部使用 useState useEffect 等，开发者不需要关注其中的实现，React 会为我们进行处理，开发者的关注点是这个hooks api 给我带来了状态管理和生命周期，我只需要使用他们来编写组件就好了</p><h3 id="代数效应和生成器Generator"><a href="#代数效应和生成器Generator" class="headerlink" title="代数效应和生成器Generator"></a>代数效应和生成器Generator</h3><p>从React15到React16，协调器（Reconciler）重构的一大目的是：将老的同步更新的架构变为异步可中断更新。<br>异步可中断更新可以理解为：更新在执行过程中可能会被打断（浏览器时间分片用尽或有更高优任务插队），当可以继续执行时恢复之前执行的中间状态。<br>浏览器原生支持类似异步中断更新的实现，也就是生成器函数<br>生成器函数<code>Generator</code>返回一个迭代器，通过调用迭代器来惰性执行函数体，其中函数体内使用yield关键字进行分步，Generator 是 js 对<a href="https://zh.wikipedia.org/zh/%E5%8D%8F%E7%A8%8B">协程</a>的一种实现<br>但是 React 团队因为生成器函数的一些缺陷放弃了使用他实现 <strong>协调器Reconciler</strong>：</p><ul><li>生成器函数会改变函数调用的方式，也就是说具有传染性，其返回的是一个迭代器，要通过context.next()的方式进行调用。</li><li>生成器函数在调用的过程中具有中间状态，并且与上下文关联，也就是中间状态在生成器函数的作用域中</li></ul><p>例如Hooks 发明者 <a href="https://github.com/sebmarkbage">sebmarkbage</a> 回答的issue ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">doWork</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="title function_">doExpensiveWorkA</span>(a);</span><br><span class="line">  <span class="keyword">yield</span>;</span><br><span class="line">  <span class="keyword">var</span> y = x + <span class="title function_">doExpensiveWorkB</span>(b);</span><br><span class="line">  <span class="keyword">yield</span>;</span><br><span class="line">  <span class="keyword">var</span> z = y + <span class="title function_">doExpensiveWorkC</span>(c);</span><br><span class="line">  <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>每当浏览器有空闲时间都会依次执行其中一个<code>doExpensiveWork</code>，当时间用尽则会中断，当再次恢复时会从中断位置继续执行。<br>只考虑“单一优先级任务的中断与继续”情况下生成器函数可以很好的实现异步可中断更新。<br>但是当我们考虑“高优先级任务插队”的情况，如果此时已经完成doExpensiveWorkA与doExpensiveWorkB计算出x与y。此时B组件接收到一个高优更新，我们要重新计算 <code>var y = x + doExpensiveWorkB(b);</code><br>由于每一次更新任务队列，都需要重新创建一个生成器的上下文，而我们想复用的<code>x</code>又是在之前的生成器上下文中，那么就无法重用<code>x</code>的值了</p><h2 id="Fiber"><a href="#Fiber" class="headerlink" title="Fiber"></a>Fiber</h2><p>Fiber 是 React 16中 的一个数据结构，用于 reconciler 中对比差异，Fiber这个词在计算机科学中不是什么新名词，中文名为<strong>纤程，</strong>Wiki 中描述到：</p><blockquote><p>在<strong>计算机科学</strong>中，<strong>纤程</strong>（英语：Fiber）是一种最轻量化的<strong>线程</strong>（lightweight threads）。它是一种用户态线程（user thread），让<strong>应用程式</strong>可以独立决定自己的线程要如何运作。作业系统<strong>内核</strong>不能看见它，也不会为它进行<strong>排程</strong>。</p></blockquote><p>在 React 的官方文档中有这样的描述：</p><blockquote><p><strong>“fiber” reconciler 是一个新尝试，致力于解决 stack reconciler 中固有的问题，同时解决一些历史遗留问题。Fiber 从 React 16 开始变成了默认的 reconciler。</strong><br><strong>它的主要目标是：</strong></p><ul><li><strong>能够把可中断的任务切片处理。</strong></li><li><strong>能够调整优先级，重置并复用任务。</strong></li><li><strong>能够在父元素与子元素之间交错处理，以支持 React 中的布局。</strong></li><li><strong>能够在 render() 中返回多个元素。</strong></li><li><strong>更好地支持错误边界。</strong></li></ul></blockquote><p>可以理解为 Fiber 是 React 自己实现的一套机制，支持任务不同优先级，可中断与恢复，并且恢复后可以复用之前的中间状态。</p><h3 id="React-Fiber-节点"><a href="#React-Fiber-节点" class="headerlink" title="React Fiber 节点"></a>React Fiber 节点</h3><p><strong>Fiber包含三层含义</strong>：</p><ol><li>作为架构来说，之前React15的Reconciler采用递归的方式执行，数据保存在递归调用栈中，所以被称为stack Reconciler。React16的Reconciler基于Fiber节点实现，被称为Fiber Reconciler。</li><li>作为静态的数据结构来说，每个Fiber节点对应一个React element，保存了该组件的类型（函数组件/类组件/原生组件…）、对应的DOM节点等信息。</li><li>作为动态的工作单元来说，每个Fiber节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新…）。</li></ol><p>react 16 使用 Fiber 树代替了 虚拟DOM树，每个fiber 节点中有许多与 dom fiber 更新，副作用 等相关的属性</p><ul><li>与DOM实例相关：<ul><li>tag: 代表Fiber 所部表示的React 元素的类型，以number表示</li><li>type: 保存组件的基础类型，或者构造函数、类</li><li>stateNode: 当前fiber 对应的 原生DOM 的实例</li></ul></li><li>与构建 Fiber 树相关的<ul><li>return: 指向该fiber 节点的 父级fiber 节点的指针</li><li>child: 指向当前fiber的第一个子fiber</li><li>sibling: 指向当前fiber 的下一个兄弟节点</li><li>index: fiber索引</li><li>alternate: 与 workInProgress 树中 的fiber 节点互相指向，</li></ul></li><li>组件状态 props相关的<ul><li>pendingProps: fiber即将更新的props</li><li>memoizedProps：上一次的 props</li><li>memoizedState： 上一次的 state</li></ul></li><li>副作用相关属性<ul><li>updateQueue： 当前 fiber 的 state 的更新操作 和 回调函数 的队列</li><li>flags： 当前 fiber 需要执行的dom 操作</li><li>subtreeFlags： 记录当前 fiber节点的子树 要执行的 DOM 操作</li><li>deletions： 记录需要删除的子fiber</li><li>nextEffect：  下一个需要执行副作用的 兄弟 fiber 节点</li><li>firstEffect、lastEffect： 记录当前 fiber 节点的 子fiber 中，第一个和最后一个需要执行副作用的子fiber节点</li><li>mode：更新页面的渲染模式，不同组件可能使用不同模式</li></ul></li></ul><h3 id="Fiber-树结构"><a href="#Fiber-树结构" class="headerlink" title="Fiber 树结构"></a>Fiber 树结构</h3><p><strong>Fiber 树是一个 单链表树结构（Singly Linked List Tree Structure）</strong><br>例如下面的组件结构：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">a</span>&gt;</span>link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">img</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的 Fiber 树为:<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28280007/1694076879799-1121b357-1437-4804-be9f-979d9ea4fe09.png#averageHue=%23f9f9f9&clientId=uc11177c6-3c41-4&from=paste&height=576&id=u5637bf2a&originHeight=1152&originWidth=1210&originalType=binary&ratio=2&rotation=0&showTitle=false&size=84917&status=done&style=none&taskId=u0484ae70-e788-493a-8950-dcb17a60b25&title=&width=605" alt="image.png"></p><p>从fiber 树的 结构以及 更新的方式来看，fiber之间使用的链表结构来进行收集更新，也就是为什么能在判断中使用React hooks</p><h2 id="深入理解JSX"><a href="#深入理解JSX" class="headerlink" title="深入理解JSX"></a>深入理解JSX</h2><h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><p>JSX是 一种 声明式的语法，用来描述React 的组件内容结构<br>JSX代码会在编译时会被Babel编译为React.createElement方法。所以在每一个JSX文件中需要导入React<br>在React 17 中，已经不需要编写 React 导入，babel与React 团队合作，将jsx文件默认导入了一个<code>_jsx</code>函数用于转换JSX代码</p><h3 id="React-Element-和-React-Component-与-JSX-的-关系"><a href="#React-Element-和-React-Component-与-JSX-的-关系" class="headerlink" title="React Element 和 React Component 与 JSX 的 关系"></a>React Element 和 React Component 与 JSX 的 关系</h3><h3 id="React-createElement"><a href="#React-createElement" class="headerlink" title="React.createElement"></a>React.createElement</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createElement</span>(<span class="params">type, config, children</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> propName;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> props = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> key = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> ref = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> source = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (config != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 将 config 处理后赋值给 props</span></span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> childrenLength = <span class="variable language_">arguments</span>.<span class="property">length</span> - <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 处理 children，会被赋值给props.children</span></span><br><span class="line">  <span class="comment">// ...省略</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理 defaultProps</span></span><br><span class="line">  <span class="comment">// ...省略</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">ReactElement</span>(</span><br><span class="line">    type,</span><br><span class="line">    key,</span><br><span class="line">    ref,</span><br><span class="line">    self,</span><br><span class="line">    source,</span><br><span class="line">    <span class="title class_">ReactCurrentOwner</span>.<span class="property">current</span>,</span><br><span class="line">    props,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 type config children 创建一个 描述 DOM 的 React Element</p><ol><li>从 config 中分离内部预留属性:<code>key ref self source</code></li><li>初始化 props，如果type是组件，那么将type.defaultProps与props 合并</li><li>处理 children， createElement 支持在从children参数后传入多个children，<ol><li>如果只有一个children，那么props.children = children</li><li>如果有多个children，那么props.children = childArray</li></ol></li><li>将处理好的几个数据交给 ReactElement 函数生成 element 对象</li><li>如果是开发环境，通过 defineProperty 为 props上的key 和 ref 设置 一个getter 函数， 在开发者在组件内部访问props.key 或者 props.ref 时给予使用错误，</li></ol><h3 id="React-ReactElement"><a href="#React-ReactElement" class="headerlink" title="React.ReactElement"></a>React.ReactElement</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ReactElement</span> = <span class="keyword">function</span>(<span class="params">type, key, ref, self, source, owner, props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> element = &#123;</span><br><span class="line">    <span class="comment">// 标记这是个 React Element</span></span><br><span class="line">    <span class="attr">$$typeof</span>: <span class="variable constant_">REACT_ELEMENT_TYPE</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">type</span>: type,</span><br><span class="line">    <span class="attr">key</span>: key,</span><br><span class="line">    <span class="attr">ref</span>: ref,</span><br><span class="line">    <span class="attr">props</span>: props,</span><br><span class="line">    <span class="attr">_owner</span>: owner,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>创建 react element 对象的工厂方法，其作用就是将传递的参数<code>type,props,key,ref,owner,self</code>放入js对象中，再使用<code>$$typeof</code>将这个js对象标记为 React Element<code>REACT_ELEMENT_TYPE</code> 类型（Symbol）,然后返回该对象</p><h3 id="React-Component"><a href="#React-Component" class="headerlink" title="React Component"></a>React Component</h3><p>React Component 指的是我们在编写时，使用class 或者 function 声明的 React 组件，这是一个抽象的组件概念，其背后都会生成对应的 Element 对象，由于class 只是 es6 构建对象的语法糖，所以使用 instanceof无法区分class 组件 和 function 组件，React 通过 在编写 class 组件时 组件继承的 ClassComponent 实例的原型上的<code>isReactComponent</code> 来标记class 组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ClassComponent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">isReactComponent</span> = &#123;&#125;;</span><br></pre></td></tr></table></figure><h3 id="JSX-与-Fiber-的关系"><a href="#JSX-与-Fiber-的关系" class="headerlink" title="JSX 与 Fiber 的关系"></a>JSX 与 Fiber 的关系</h3><p>JSX是一种描述组件内容的类似HTML的语法，目的是生成React Element数据结构<br>React Element 用来提供在 Reconciler 中创建 对应 fiber 节点的一些基本DOM信息，例如 type，key，props 等</p><h2 id="双缓存"><a href="#双缓存" class="headerlink" title="双缓存"></a>双缓存</h2><p>React 16后 的 DOM更新使用的双缓存，也就是在当前已有的计算结果下，在内存中保存下一次更新的结果，从而达到快速更新的目的<br>React 16+ 使用 双缓存完成FIber树的构建以及DOM的快速更新，在React 运行时会同时存在 2最多 个Fiber 树结构，<br>第一个是current fiber tree ，也就是记录了当前页面展现的内容的树，当发生更新时，会重新构建一颗 WorkingInProgress fiber tree，其中记录即将要渲染到页面的内容，当WorkingInProgress 构建完成之后，会直接在内存中替换 current fiber tree，在替换之前，current fiber tree 上的每个节点内的 alternate 属性都指向 WorkingInProgress fiber tree 中对应的节点，同理 WorkingInProgress fiber tree 中的每个节点的 alternate 也指向  current fiber tree 的对应节点</p><p>React 初始构建时，会将root fiber作为 current fiber tree ，且只有一个fiber 节点，然后复制一份 root fiber ，让 current fiber tree的 根 fiber 中alternate 指向 复制后的 new root fiber 节点，让 new root fiber 作为 WorkingInProgress fiber tree 的根节点，然后在WorkingInProgress fiber tree中构建子fiber树，更新完毕之后，将 current fiber tree 替换为 WorkingInProgress fiber tree，WorkingInProgress fiber tree 就 成为 了current fiber tree</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">currentFiber.<span class="property">alternate</span> === workInProgressFiber;</span><br><span class="line">workInProgressFiber.<span class="property">alternate</span> === currentFiber;</span><br></pre></td></tr></table></figure><p>在每个fiber 中 都存储了 DOM ，fiber 完成构建后，所有 DOM 也都被创建（更新）了</p><h2 id="fiberRoot-和-rootFiber-的区别"><a href="#fiberRoot-和-rootFiber-的区别" class="headerlink" title="fiberRoot 和 rootFiber 的区别"></a>fiberRoot 和 rootFiber 的区别</h2><p>fiberRoot 指的是Fiber 数据结构的最外层对象，可以看做是 Fiber树的控制器，记录当前fiber树的信息信息等数据<br>rootFiber 指的是 fiber 树的根节点，对应的是组件挂载时对应的 root div<br>fiberRoot 可以 包含多个 rootFiber，因为可能会有多个 render 的 root<br>rootFIber 中的stateNode 指向 fiberRoot， fiberRoot中 的current 指向 rootFiber</p><h2 id="React-协调过程"><a href="#React-协调过程" class="headerlink" title="React 协调过程"></a>React 协调过程</h2><p>React 的更新分为2个阶段： render 、commit</p><ul><li>render 阶段：<ul><li>此阶段的任务随时可以被打断</li><li>此阶段分为两个子阶段<ul><li>首次渲染阶段 （mount）</li><li>更新阶段 （update）</li></ul></li></ul></li></ul><p>render 阶段的流程大致为：</p><ol><li>先创建 fiberRoot 和 rootFiber ，</li><li>根据 React Element 树结构为每一个 react 元素构建 fiber 对象，并创建相应的DOM ，</li><li>构建 WorkingInProgress fiber tree ，为需要更新的fiber的标注DOM操作类型flag（初始化渲染只有rootFiber 被标注）</li></ol><ul><li>commit阶段:<ul><li>该阶段不可被打断</li><li>获取WIP fiber tree， 根据每个Fiber节点的Tag 进行不同类型的DOM操作，也就是渲染器执行阶段，</li></ul></li></ul><h3 id="Render-阶段"><a href="#Render-阶段" class="headerlink" title="Render 阶段"></a>Render 阶段</h3><p><strong>render 会先判断 container 是否为DOM，然后将参数交给</strong><code>**legacyRenderSubtreeIntoContainer**</code><strong>函数</strong><br>render 接受3个参数：</p><ol><li>element：React.createElement 返回的 React 元素js对象</li><li>container：DOM 元素</li><li>callback： 完成渲染后的回调函数</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactDOM.render() 渲染方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params"></span></span><br><span class="line"><span class="params">  element: React$Element&lt;<span class="built_in">any</span>&gt;, <span class="comment">// createElement 方法的返回值 React 元素对象</span></span></span><br><span class="line"><span class="params">  container: Container, <span class="comment">// root DOM 元素</span></span></span><br><span class="line"><span class="params">  callback: ?<span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">invariant</span>(</span><br><span class="line">    <span class="title function_">isValidContainer</span>(container), <span class="comment">// 检测container 是否为 DOM 元素</span></span><br><span class="line">    <span class="string">&#x27;Target container is not a DOM element.&#x27;</span>,</span><br><span class="line">  );</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 开发者警告提示</span></span><br><span class="line">  <span class="comment">// if (__DEV__) &#123; ...&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将子树渲染到容器中</span></span><br><span class="line">  <span class="comment">// 操作： 创建 fiberRoot 和 rootFiber</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">legacyRenderSubtreeIntoContainer</span>(</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    element,</span><br><span class="line">    container,</span><br><span class="line">    <span class="literal">false</span>, <span class="comment">// 是否是服务器渲染，在服务器渲染中会复用DOM元素，否则会清空DOM中的内容</span></span><br><span class="line">    callback,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建-Fiber-数据结构-创建-fiberRoot-和-rootFiber"><a href="#创建-Fiber-数据结构-创建-fiberRoot-和-rootFiber" class="headerlink" title="创建 Fiber 数据结构, 创建 fiberRoot 和 rootFiber"></a>创建 Fiber 数据结构, 创建 fiberRoot 和 rootFiber</h4><p>legacyRenderSubtreeIntoContainr 函数将子树渲染到容器中，开始创建fiberRoot，此函数接受5个参数：</p><ol><li>parentComponent：父 react 组件</li><li>children：子节点列表</li><li>container：要渲染子树的容器</li><li>forceHydrate：是否启用服务器渲染</li><li>callback： 渲染完成后的回调</li></ol><p>在初始渲染时，只需传入element 到 children ，container ， callback 三个参数</p><ol><li>访问<code>container._reactRootContainer</code> 判断该 container 是<strong>执行初始化渲染，还是更新渲染</strong></li><li>初始渲染下，使用 DOM 元素 container，调用<code>legacyCreateRootFromDOMContainer(container)</code>创建 <code>fiberRoot</code>和 <code>rootFIber</code></li><li>此时 上面说到的current fiber tree 已经构建完成</li><li>处理 callback 的 this 指向，指向 root DOM的实例，函数组件作为 root DOM 时初始化渲染时<strong>没有实例的</strong></li><li>调用<code>updateContainer</code>使用非批量更新，防止初始化渲染时，更新被打断</li><li>返回 <code>ReactDOM.render</code> 中第一个参数的 DOM 实例对象，如果是 React 组件 那么返回 null ，在初始化时，这里返回null</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">legacyRenderSubtreeIntoContainer</span>(<span class="params"></span></span><br><span class="line"><span class="params">  parentComponent: ?React$Component&lt;<span class="built_in">any</span>, <span class="built_in">any</span>&gt;,</span></span><br><span class="line"><span class="params">  children: ReactNodeList,</span></span><br><span class="line"><span class="params">  container: Container,</span></span><br><span class="line"><span class="params">  forceHydrate: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params">  callback: ?<span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 开发者警告提示</span></span><br><span class="line">  <span class="comment">// if (__DEV__) &#123; ...&#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 此处访问_reactRootContainer 是为了检测是否已经是初始化后的容器</span></span><br><span class="line">  <span class="comment">// _reactRootContainer 不存在 以为着需要进行初始渲染</span></span><br><span class="line">  <span class="comment">// _reactRootContainer 存在 意味着需要进行更新渲染</span></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">root</span>: <span class="title class_">RootType</span> = (container.<span class="property">_reactRootContainer</span>: <span class="built_in">any</span>);</span><br><span class="line">  <span class="keyword">let</span> fiberRoot;</span><br><span class="line">  <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">    <span class="comment">// 初始化挂载，创建fiberRoot</span></span><br><span class="line">    root = container.<span class="property">_reactRootContainer</span> = <span class="title function_">legacyCreateRootFromDOMContainer</span>(</span><br><span class="line">      container,</span><br><span class="line">      forceHydrate,</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 取得 fiberRoot</span></span><br><span class="line">    fiberRoot = root.<span class="property">_internalRoot</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> originalCallback = callback;</span><br><span class="line">      callback = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> instance = <span class="title function_">getPublicRootInstance</span>(fiberRoot);</span><br><span class="line">        originalCallback.<span class="title function_">call</span>(instance);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Initial mount should not be batched.</span></span><br><span class="line">    <span class="comment">// 初始化挂载不执行批量更新</span></span><br><span class="line">    <span class="comment">// 由于批量更新 batchUpdates 可以被打断，但是初始化时需要一次性渲染完成，不能被打断</span></span><br><span class="line">    <span class="title function_">unbatchedUpdates</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">updateContainer</span>(children, fiberRoot, parentComponent, callback);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 更新渲染的分支</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回的是 ReactDOM.render 中第一个参数的DOM实例对象</span></span><br><span class="line">  <span class="comment">// 如果是 React 组件 那么返回 null ，在初始化时，这里一般返回null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getPublicRootInstance</span>(fiberRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="进入-legacyCreateRootFromDOMContainer-container，forceHydrate-，清空root-DOM-内容"><a href="#进入-legacyCreateRootFromDOMContainer-container，forceHydrate-，清空root-DOM-内容" class="headerlink" title="进入 legacyCreateRootFromDOMContainer(container，forceHydrate)，清空root DOM 内容"></a>进入 legacyCreateRootFromDOMContainer(container，forceHydrate)，清空root DOM 内容</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">legacyCreateRootFromDOMContainer</span>(<span class="params"></span></span><br><span class="line"><span class="params">  container: Container,</span></span><br><span class="line"><span class="params">  forceHydrate: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">RootType</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> shouldHydrate =</span><br><span class="line">    forceHydrate || <span class="title function_">shouldHydrateDueToLegacyHeuristic</span>(container);</span><br><span class="line">  <span class="comment">//非服务器渲染下， 先清空这个root DOM 内的所有元素</span></span><br><span class="line">  <span class="keyword">if</span> (!shouldHydrate) &#123;</span><br><span class="line">    <span class="keyword">let</span> warned = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> rootSibling;</span><br><span class="line">    <span class="comment">// 这里从DOM内的最后一个孩子开始移除</span></span><br><span class="line">    <span class="keyword">while</span> ((rootSibling = container.<span class="property">lastChild</span>)) &#123;</span><br><span class="line">     <span class="comment">// if (__DEV__)  &#123; ... &#125;</span></span><br><span class="line">      container.<span class="title function_">removeChild</span>(rootSibling);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// if (__DEV__)  &#123; ... &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清空完成之后，调用创建 Root 的方法，返回 一个对象，将初始化完成后的 fiberRoot对象 挂载到 _internalRoot 属性 上</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createLegacyRoot</span>(</span><br><span class="line">    container,</span><br><span class="line">    shouldHydrate</span><br><span class="line">      ? &#123;</span><br><span class="line">          <span class="attr">hydrate</span>: <span class="literal">true</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      : <span class="literal">undefined</span>,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>先判断是否服务器渲染，在服务器渲染下，不会清空节点内容</li><li>不是服务器渲染，那么使用循环从DOM内部的最后一个子元素开始删除所有内部DOM元素</li><li>返回 <code>createLegacyRoot(container, shouldHydrate)</code> 调用后的结果，由于后续均为非服务器渲染，这里先忽略服务器渲染的参数</li></ol><ul><li><strong>问题：为什么要先清除DOM中的内容？</strong><ul><li>React 需要将DOM 中的内容进行全面托管，避免了不受控制的DOM掺杂进去影响页面</li><li>避免React渲染结果与现有的元素冲突</li><li>清除无用的事件监听，清除DOM，那么也就清除了监听事件</li></ul></li></ul><p>所以说，清除 DOM 内容是为了确保 React 在开始渲染之前处于一个干净、一致且可控制的状态，以便它可以有效地构建和管理整个应用的渲染。</p><h5 id="进入-createLegacyRoot-container-options-，创建-fiberRoot-的外层对象-rootType"><a href="#进入-createLegacyRoot-container-options-，创建-fiberRoot-的外层对象-rootType" class="headerlink" title="进入 createLegacyRoot(container, options)，创建 fiberRoot 的外层对象 rootType"></a>进入 createLegacyRoot(container, options)，创建 fiberRoot 的外层对象 rootType</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">RootType</span> = &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="attr">children</span>: <span class="title class_">ReactNodeList</span>): <span class="built_in">void</span>,</span><br><span class="line">  <span class="title function_">unmount</span>(): <span class="built_in">void</span>,</span><br><span class="line">  <span class="attr">_internalRoot</span>: <span class="title class_">FiberRoot</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createLegacyRoot</span>(<span class="params"></span></span><br><span class="line"><span class="params">  container: Container,</span></span><br><span class="line"><span class="params">  options?: RootOptions,</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">RootType</span> &#123;</span><br><span class="line">  <span class="comment">// 使用root DOM， LegacyRoot 类型的常量，返回一个 ReactDOMBlockingRoot 实例化的新对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReactDOMBlockingRoot</span>(container, <span class="title class_">LegacyRoot</span>, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>此函数中，直接返回了 <code>ReactDOMBlockingRoot(container, LagacyRoot, options)</code>实例化的js对象，类型为 RootType，其中第二个参数 LegacyRoot 是一个值为 0 的类型常量，</li><li>此处的 LegacyRoot 其实代表的是使用 ReactDOM.render 渲染的 root</li><li>React 每个版本都在添加一些实验性的功能来改变渲染的方式：</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// react v17.0.2 </span></span><br><span class="line"><span class="comment">// src/react/packages/react-reconciler/src/ReactRootTags.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">RootTag</span> = <span class="number">0</span> | <span class="number">1</span> | <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过调用 ReactDOM.render 的 Root类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">LegacyRoot</span> = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 通过调用 ReactDOM.createBlockingRoot</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">BlockingRoot</span> = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 通过调用 ReactDOM.createRoot</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ConcurrentRoot</span> = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h5 id="进入-new-ReactDOMBlockingRoot-container-LegacyRoot-options-，创建一个-fiberRoot实例"><a href="#进入-new-ReactDOMBlockingRoot-container-LegacyRoot-options-，创建一个-fiberRoot实例" class="headerlink" title="进入 new ReactDOMBlockingRoot(container, LegacyRoot, options)，创建一个 fiberRoot实例"></a>进入 new ReactDOMBlockingRoot(container, LegacyRoot, options)，创建一个 fiberRoot实例</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ReactDOMBlockingRoot</span>(<span class="params"></span></span><br><span class="line"><span class="params">  container: Container,</span></span><br><span class="line"><span class="params">  tag: RootTag,</span></span><br><span class="line"><span class="params">  options: <span class="built_in">void</span> | RootOptions,</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 将 fiberRoot 挂载到 _internalRoot 属性上</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_internalRoot</span> = <span class="title function_">createRootImpl</span>(container, tag, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReactDOMBlockingRoot 其实就是返回了一个只有一个<code>_internalRoot</code>属性的对象，<code>this._internalRoot</code>使用<code>createRootImpl(container, tag, options)</code>创建的</p><h5 id="进入-createRootImpl-container-tag-options"><a href="#进入-createRootImpl-container-tag-options" class="headerlink" title="进入 createRootImpl(container, tag, options)"></a>进入 createRootImpl(container, tag, options)</h5><p>这个方法内主要是 使用<code>createContainer(container, tag, hydrate, hydrationCallbacks)</code>创建fiberRoot对象，并且标记DOM 为fiber的根节点，然后再使用事件委托接管DOM上的所有事件，最后返回fiberRoot</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// createRootImpl 函数创建 fiberRoot 后 并委托 root DOM上的所有事件，返回 fiberRoot 对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createRootImpl</span>(<span class="params"></span></span><br><span class="line"><span class="params">  container: Container,</span></span><br><span class="line"><span class="params">  tag: RootTag,</span></span><br><span class="line"><span class="params">  options: <span class="built_in">void</span> | RootOptions,</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// Tag is either LegacyRoot or Concurrent Root</span></span><br><span class="line">  <span class="comment">// 标签 为 LegacyRoot 或者 Concurrent Root 其中之一</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ... 省略一些服务器渲染相关代码</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建 fiberRoot 对象，并且创建 fiberRoot.current = rootFiber</span></span><br><span class="line">  <span class="keyword">const</span> root = <span class="title function_">createContainer</span>(container, tag, hydrate, hydrationCallbacks);</span><br><span class="line">  <span class="comment">//标记DOM为根容器，将rootFiber 挂载到 DOM对象的 [__reactContainer$ + 随机数字] key 中</span></span><br><span class="line">  <span class="title function_">markContainerAsRoot</span>(root.<span class="property">current</span>, container);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取该DOM 的nodeType 属性，类型为 数字</span></span><br><span class="line">  <span class="keyword">const</span> containerNodeType = container.<span class="property">nodeType</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enableEagerRootListeners 默认为 true</span></span><br><span class="line">  <span class="keyword">if</span> (enableEagerRootListeners) &#123;</span><br><span class="line">    <span class="comment">// 这里判断DOM是否是 html的注释类型的DOM，如果是，就取这个节点的父节点</span></span><br><span class="line">    <span class="keyword">const</span> rootContainerElement =</span><br><span class="line">      container.<span class="property">nodeType</span> === <span class="variable constant_">COMMENT_NODE</span> ? container.<span class="property">parentNode</span> : container;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听根 DOM 上所有支持的事件，React 开始 接管 root DOM 上的事件</span></span><br><span class="line">    <span class="title function_">listenToAllSupportedEvents</span>(rootContainerElement);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if (mutableSources) &#123; ... &#125; 服务器渲染相关</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="进入-createContainer-container-tag-hydrate-hydrationCallbacks"><a href="#进入-createContainer-container-tag-hydrate-hydrationCallbacks" class="headerlink" title="进入 createContainer(container, tag, hydrate, hydrationCallbacks)"></a>进入 createContainer(container, tag, hydrate, hydrationCallbacks)</h5><p><code>createContainer</code>其实内部就返回了<code>createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks);</code>的返回结构，真是套娃😓，这下<code>createFiberRoot</code>总算进入创建 fiberRoot 阶段了吧</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">FiberRoot</span> = &#123;</span><br><span class="line">  ...<span class="title class_">BaseFiberRootProperties</span>,</span><br><span class="line">  ...<span class="title class_">ProfilingOnlyFiberRootProperties</span>,</span><br><span class="line">  ...<span class="title class_">SuspenseCallbackOnlyFiberRootProperties</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// createContainer_old</span></span><br><span class="line"><span class="comment">// 使用DOM 创建 fiberRoot</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createContainer</span>(<span class="params"></span></span><br><span class="line"><span class="params">  containerInfo: Container,</span></span><br><span class="line"><span class="params">  tag: RootTag,</span></span><br><span class="line"><span class="params">  hydrate: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params">  hydrationCallbacks: <span class="literal">null</span> | SuspenseHydrationCallbacks,</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">FiberRoot</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createFiberRoot</span>(containerInfo, tag, hydrate, hydrationCallbacks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="进入-createFiberRoot-containerInfo-tag-hydrate-hydrationCallbacks"><a href="#进入-createFiberRoot-containerInfo-tag-hydrate-hydrationCallbacks" class="headerlink" title="进入 createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks)"></a>进入 createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks)</h5><p>createFiberRoot 内，首先通过 构造函数<code>FiberRootNode</code>实例化 fiberRoot 对象<br>然后再使用createHostRootFiber(tag) 创建 一个未初始化的fiber节点uninitializedFiber，此fiber节点就是rootFIber<br>将fiberRoot.current -&gt; rootFIber   rootFiber.stateNode -&gt; fiberRoot<br>最后再初始化rootFIber中的更新队列updateQueue对象，第一个更新任务是空更新</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值先创建 fiberRoot 然后再创建 rootFiber ，初始化 rootFiber.updateQueue</span></span><br><span class="line"><span class="comment">// 返回 fiberRoot</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createFiberRoot</span>(<span class="params"></span></span><br><span class="line"><span class="params">  containerInfo: <span class="built_in">any</span>,</span></span><br><span class="line"><span class="params">  tag: RootTag,</span></span><br><span class="line"><span class="params">  hydrate: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params">  hydrationCallbacks: <span class="literal">null</span> | SuspenseHydrationCallbacks,</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">FiberRoot</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 FiberRootNode 创建 fiberRoot 对象，fiberRoot 用于管理fiber树以及记录fiber 等更新信息</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">root</span>: <span class="title class_">FiberRoot</span> = (<span class="keyword">new</span> <span class="title class_">FiberRootNode</span>(containerInfo, tag, hydrate): <span class="built_in">any</span>);</span><br><span class="line">  <span class="keyword">if</span> (enableSuspenseCallback) &#123;</span><br><span class="line">    root.<span class="property">hydrationCallbacks</span> = hydrationCallbacks;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Cyclic construction. This cheats the type system right now because</span></span><br><span class="line">  <span class="comment">// stateNode is any.</span></span><br><span class="line">  <span class="comment">// 先创建一个未初始化的 root fiber， 也就是 fiber 树根，第一次渲染时，tag为LegacyRoot</span></span><br><span class="line">  <span class="comment">// uninitializedFiber 的 类型 为 Fiber，也就是rootFiber</span></span><br><span class="line">  <span class="keyword">const</span> uninitializedFiber = <span class="title function_">createHostRootFiber</span>(tag);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将rootFiber 放入 rootFiber.current中</span></span><br><span class="line">  root.<span class="property">current</span> = uninitializedFiber;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将rootFiber 的stateNode 指为 fiberRoot</span></span><br><span class="line">  uninitializedFiber.<span class="property">stateNode</span> = root;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对 rootFiber.updateQueue 对象 进行初始化</span></span><br><span class="line">  <span class="title function_">initializeUpdateQueue</span>(uninitializedFiber);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="进入-new-FiberRootNode-containerInfo-tag-hydrate-，-创建F"><a href="#进入-new-FiberRootNode-containerInfo-tag-hydrate-，-创建F" class="headerlink" title="进入 new FiberRootNode(containerInfo, tag, hydrate)， 创建F"></a>进入 new FiberRootNode(containerInfo, tag, hydrate)， 创建F</h5><p><code>FiberRootNode</code> 是fiberRoot对象的构造函数，初始化了一堆默认的属性</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FiberRoot 构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">FiberRootNode</span>(<span class="params">containerInfo, tag, hydrate</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">tag</span> = tag;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">containerInfo</span> = containerInfo;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pendingChildren</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">current</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pingCache</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">finishedWork</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">timeoutHandle</span> = noTimeout;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">context</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pendingContext</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">hydrate</span> = hydrate;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">callbackNode</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">callbackPriority</span> = <span class="title class_">NoLanePriority</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">eventTimes</span> = <span class="title function_">createLaneMap</span>(<span class="title class_">NoLanes</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">expirationTimes</span> = <span class="title function_">createLaneMap</span>(<span class="title class_">NoTimestamp</span>);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pendingLanes</span> = <span class="title class_">NoLanes</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">suspendedLanes</span> = <span class="title class_">NoLanes</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pingedLanes</span> = <span class="title class_">NoLanes</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">expiredLanes</span> = <span class="title class_">NoLanes</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">mutableReadLanes</span> = <span class="title class_">NoLanes</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">finishedLanes</span> = <span class="title class_">NoLanes</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">entangledLanes</span> = <span class="title class_">NoLanes</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">entanglements</span> = <span class="title function_">createLaneMap</span>(<span class="title class_">NoLanes</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (supportsHydration) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">mutableSourceEagerHydrationData</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableSchedulerTracing) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">interactionThreadID</span> = <span class="title function_">unstable_getThreadID</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">memoizedInteractions</span> = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">pendingInteractionMap</span> = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (enableSuspenseCallback) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hydrationCallbacks</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// DEV 警告</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="进入-createHostRootFiber-tag"><a href="#进入-createHostRootFiber-tag" class="headerlink" title="进入 createHostRootFiber(tag)"></a>进入 createHostRootFiber(tag)</h5><p>createHostRootFiber主要是创建 fiber的根 rootFiber，此时会通过tag的类型来决定渲染模式mod，使用<code>ReactDOM.render</code>渲染下，mode 为 同步模式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">TypeOfMode</span> = <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// react 的渲染模式</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">NoMode</span> = <span class="number">0b00000</span>; <span class="comment">// 同步渲染</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">StrictMode</span> = <span class="number">0b00001</span>; <span class="comment">// 严格模式</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Remove BlockingMode and ConcurrentMode by reading from the root</span></span><br><span class="line"><span class="comment">// tag instead</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">BlockingMode</span> = <span class="number">0b00010</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ConcurrentMode</span> = <span class="number">0b00100</span>; <span class="comment">// 并发模式</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ProfileMode</span> = <span class="number">0b01000</span>; <span class="comment">// 性能测试模式</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">DebugTracingMode</span> = <span class="number">0b10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// createHostRootFiber 用于 使用tag来决定渲染模式，也就是说不同类型的组件会使用不同的渲染模式</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createHostRootFiber</span>(<span class="params">tag: RootTag</span>): <span class="title class_">Fiber</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> mode;</span><br><span class="line">  <span class="keyword">if</span> (tag === <span class="title class_">ConcurrentRoot</span>) &#123;</span><br><span class="line">    <span class="comment">// mode = 0b00100 | 0b00010 | 0b00001 = 0b00111</span></span><br><span class="line">    mode = <span class="title class_">ConcurrentMode</span> | <span class="title class_">BlockingMode</span> | <span class="title class_">StrictMode</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag === <span class="title class_">BlockingRoot</span>) &#123;</span><br><span class="line">    <span class="comment">// mode = 0b00010 | 0b00001 = 0b00011</span></span><br><span class="line">    mode = <span class="title class_">BlockingMode</span> | <span class="title class_">StrictMode</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 在使用ReactDOM.render()创建root fiber时，使用的是同步渲染模式</span></span><br><span class="line">    <span class="comment">// mode = 0b00000</span></span><br><span class="line">    mode = <span class="title class_">NoMode</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableProfilerTimer &amp;&amp; isDevToolsPresent) &#123;</span><br><span class="line">    <span class="comment">// Always collect profile timings when DevTools are present.</span></span><br><span class="line">    <span class="comment">// This enables DevTools to start capturing timing at any point–</span></span><br><span class="line">    <span class="comment">// Without some nodes in the tree having empty base times.</span></span><br><span class="line">    <span class="comment">// mode = mode | ProfileMode</span></span><br><span class="line">    mode |= <span class="title class_">ProfileMode</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个fiber</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createFiber</span>(<span class="title class_">HostRoot</span>, <span class="literal">null</span>, <span class="literal">null</span>, mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 mode 使用 按位或<code>|</code>来巧妙的将不同模式进行归类或者说是聚合，这样后续就可以将mode使用按位与<code>&amp;</code>运算来将结果和目标模式进行对比，以此判断mod中是否包含该目标模式，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mode = <span class="number">0b1100</span>; <span class="comment">// 二进制表示的 mode 变量，假设是 0b1100</span></span><br><span class="line"><span class="keyword">const</span> profileMode = <span class="number">0b0010</span>; <span class="comment">// 二进制表示的需要检查的模式，假设是 0b0010</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用按位与操作符进行检查</span></span><br><span class="line"><span class="keyword">if</span> ((mode &amp; profileMode) === profileMode) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;mode 包含了 profileMode&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;mode 不包含 profileMode&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="进入-createFiber-HostRoot-null-null-mode-，创建rootFiber"><a href="#进入-createFiber-HostRoot-null-null-mode-，创建rootFiber" class="headerlink" title="进入 createFiber(HostRoot, null, null, mode)，创建rootFiber"></a>进入 createFiber(HostRoot, null, null, mode)，创建rootFiber</h5><p>HostRoot表示该fiber节点是一个根Fiber，mode指明该fiber 是什么渲染模式，这里使用的是noMode，即同步渲染<br>在其中返回了一个<code>FiberNode</code>函数的实例化对象 类型为 <code>Fiber</code>， 初始化的 <code>props</code> 和 <code>key</code> 都为空</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createFiber = <span class="keyword">function</span>(<span class="params"></span></span><br><span class="line"><span class="params">  tag: WorkTag,</span></span><br><span class="line"><span class="params">  pendingProps: mixed,</span></span><br><span class="line"><span class="params">  key: <span class="literal">null</span> | <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  mode: TypeOfMode,</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Fiber</span> &#123;</span><br><span class="line">  <span class="comment">// $FlowFixMe: the shapes are exact here but Flow doesn&#x27;t like constructors</span></span><br><span class="line">  <span class="comment">// 通过FiberNode 构造函数创建了一个Fiber实例，而不是使用Fiber</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FiberNode</span>(tag, pendingProps, key, mode);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="进入-new-FiberNode-tag-pendingProps-key-mode-，实例化-rootFiber"><a href="#进入-new-FiberNode-tag-pendingProps-key-mode-，实例化-rootFiber" class="headerlink" title="进入 new FiberNode(tag, pendingProps, key, mode)，实例化 rootFiber"></a>进入 new FiberNode(tag, pendingProps, key, mode)，实例化 rootFiber</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fiber对象实例构造函数，</span></span><br><span class="line"><span class="comment">// 这个构造函数仅仅将fiber 代表的组件类型tag ，即将接受的props，key，该fiber的渲染模式进行了初始化</span></span><br><span class="line"><span class="comment">// 其余值均为空，所以返回的对象 是一个 未完全初始化的fiber 对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">FiberNode</span>(<span class="params"></span></span><br><span class="line"><span class="params">  tag: WorkTag,</span></span><br><span class="line"><span class="params">  pendingProps: mixed,</span></span><br><span class="line"><span class="params">  key: <span class="literal">null</span> | <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  mode: TypeOfMode,</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// Instance</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">tag</span> = tag;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">key</span> = key;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">elementType</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">stateNode</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fiber</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">return</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">child</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sibling</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">index</span> = <span class="number">0</span>;   <span class="comment">// root fiber 的 index = 0</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">ref</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pendingProps</span> = pendingProps;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">memoizedProps</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">updateQueue</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">memoizedState</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">dependencies</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">mode</span> = mode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Effects</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">flags</span> = <span class="title class_">NoFlags</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">nextEffect</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">firstEffect</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">lastEffect</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">lanes</span> = <span class="title class_">NoLanes</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">childLanes</span> = <span class="title class_">NoLanes</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">alternate</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调试相关属性</span></span><br><span class="line">  <span class="comment">// if (enableProfilerTimer) &#123; ... &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// DEV 相关 debug 调试 属性</span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="comment">// This isn&#x27;t directly used but is handy for debugging internals:</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_debugID</span> = debugCounter++;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_debugSource</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_debugOwner</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_debugNeedsRemount</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_debugHookTypes</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!hasBadMapPolyfill &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">Object</span>.<span class="property">preventExtensions</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="更新阶段-fiberRoot-以及-rootFiber"><a href="#更新阶段-fiberRoot-以及-rootFiber" class="headerlink" title="更新阶段 fiberRoot 以及 rootFiber"></a>更新阶段 fiberRoot 以及 rootFiber</h4><p>接着调用<code>updateContainer</code>会正式进入 render 阶段，遍历生成 WIP fiber 树，React 16 + 使用了可中断的循环来模拟递归<br><code>unbatchedUpdates</code>指的是不进行批量更新，首屏渲染需要尽快将画面呈现在页面上</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initial mount should not be batched.</span></span><br><span class="line"><span class="comment">// 初始化挂载不执行批量更新</span></span><br><span class="line"><span class="comment">// 由于批量更新batchUpdates 可以被打断，但是初始化时需要一次性渲染完成，不能被打断</span></span><br><span class="line"><span class="title function_">unbatchedUpdates</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">updateContainer</span>(children, fiberRoot, parentComponent, callback);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="workLoop-模拟可中断递归"><a href="#workLoop-模拟可中断递归" class="headerlink" title="workLoop 模拟可中断递归"></a>workLoop 模拟可中断递归</h5><p>生成WIP fiber 树主要开始于<code>performSyncWorkOnRoot</code>或<code>performConcurrentWorkOnRoot</code>方法的调用，取决于本次更新是同步还是异步可中断更新（初始化的时候调用的是同步更新）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// performSyncWorkOnRoot会调用该方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">workLoopSync</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="title function_">performUnitOfWork</span>(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// performConcurrentWorkOnRoot会调用该方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">workLoopConcurrent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span> &amp;&amp; !<span class="title function_">shouldYield</span>()) &#123;</span><br><span class="line">    <span class="title function_">performUnitOfWork</span>(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>workLoopConcurrent</code>中新增了一个<code>shouldYield</code>函数，<code>shouldYield</code>可以决定工作循环是否继续执行，如果当前帧没有剩余的线程空闲时间，那么就会等到下一个帧再决定是否继续遍历<br><code>workInProgress</code>代表的是当前已经创建的 workInProgress fiber 节点通过循环调用<code>performUnitOfWork</code>来模拟递归</p><p>在 <code>workLoopConcurrent</code> 并发模式下我们创建一个比较大的列表：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(e =&gt; e + 1)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">      &#123;new Array(50000).fill(0).map((_, i) =&gt; <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;i + count&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>)&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候我们打开浏览器的performance调试，就会看到以下的结果：<br><code>performWorkUntilDeadline</code>的执行时间基本都是在 5ms 以内<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28280007/1694080669272-2af83f84-5df6-4090-8419-9ee9ab30cd3a.png#averageHue=%23c8e4c0&clientId=uc11177c6-3c41-4&from=paste&height=603&id=u290dca91&originHeight=1206&originWidth=2826&originalType=binary&ratio=2&rotation=0&showTitle=false&size=358656&status=done&style=none&taskId=u1b5872bf-dbb9-459c-82b3-8068c2eb314&title=&width=1413" alt="image.png"><br>而在当我们在点击一次 ul ，也就是触发一次更新后，疯狂移动鼠标，那么就会发现这样的一种情况<br>这里的 蓝色 Hit Test 指的是浏览器确定用户的鼠标事件，也就是在处理我们疯狂移动鼠标的过程，<br>因为在下一帧生成之前 鼠标事件检测占用了太多的 时间，导致只有几个帧的空闲时间给协调器做差异对比，导致后面React 直接决定调用 <code>renderRootSync</code> 来处理剩下的 fiber，再极端一点，如果整个过程中线程空闲时候非常少，那么React 就不会启用 并发渲染模式，而是直接使用 同步渲染<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28280007/1694081390685-7a7d1078-f88b-4ee1-a0af-83d53e1cad7e.png#averageHue=%23dae8e0&clientId=uc11177c6-3c41-4&from=paste&height=570&id=u3276a25a&originHeight=1140&originWidth=3252&originalType=binary&ratio=2&rotation=0&showTitle=false&size=319973&status=done&style=none&taskId=u1260e4e4-f83c-4afb-b4db-b04f514644d&title=&width=1626" alt="image.png"></p><h5 id="performUnitOfWork-递归创建-fiber-单链树结构"><a href="#performUnitOfWork-递归创建-fiber-单链树结构" class="headerlink" title="performUnitOfWork 递归创建 fiber 单链树结构"></a>performUnitOfWork 递归创建 fiber 单链树结构</h5><p><code>performUnitOfWork</code> 会从 <code>WIP rootFiber</code>节点开始，参考其对等的 <code>unitOfWork.alternate</code> 进行深度优先遍历，该函数工作会有两个阶段：<strong>递</strong> 和 <strong>归</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">performUnitOfWork</span>(<span class="params">unitOfWork: Fiber</span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="comment">// The current, flushed, state of this fiber is the alternate. Ideally</span></span><br><span class="line">  <span class="comment">// nothing should rely on this, but relying on it here means that we don&#x27;t</span></span><br><span class="line">  <span class="comment">// need an additional field on the work in progress.</span></span><br><span class="line">  <span class="keyword">const</span> current = unitOfWork.<span class="property">alternate</span>; <span class="comment">// 拿到 current fiber 树 对应的节点</span></span><br><span class="line">  <span class="title function_">setCurrentDebugFiberInDEV</span>(unitOfWork);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> next;</span><br><span class="line">  <span class="keyword">if</span> (enableProfilerTimer &amp;&amp; (unitOfWork.<span class="property">mode</span> &amp; <span class="title class_">ProfileMode</span>) !== <span class="title class_">NoMode</span>) &#123;</span><br><span class="line">    <span class="title function_">startProfilerTimer</span>(unitOfWork);</span><br><span class="line">    <span class="comment">// 将current fiber节点(current) 与 当前 已创建的WIP fiber 节点(unitOfWork) </span></span><br><span class="line">    <span class="comment">// 交给beginWork，生成下一个节点</span></span><br><span class="line">    next = <span class="title function_">beginWork</span>(current, unitOfWork, subtreeRenderLanes);</span><br><span class="line">    <span class="title function_">stopProfilerTimerIfRunningAndRecordDelta</span>(unitOfWork, <span class="literal">true</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next = <span class="title function_">beginWork</span>(current, unitOfWork, subtreeRenderLanes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">resetCurrentDebugFiberInDEV</span>();</span><br><span class="line">  unitOfWork.<span class="property">memoizedProps</span> = unitOfWork.<span class="property">pendingProps</span>;</span><br><span class="line">  <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// If this doesn&#x27;t spawn new work, complete the current work.</span></span><br><span class="line">    <span class="title function_">completeUnitOfWork</span>(unitOfWork);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    workInProgress = next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title class_">ReactCurrentOwner</span>.<span class="property">current</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="“递”阶段"><a href="#“递”阶段" class="headerlink" title="“递”阶段"></a>“递”阶段</h5><p><code>performUnitOfWork</code>内会将 current fiber节点(current) 与 当前已创建的WIP fiber 节点(unitOfWork) 交给beginWork，进行深度优先遍历来创建子fiber节点，直到遍历到叶子fiber节点（没有子组件的节点）,就进入 <strong>“归”</strong> 阶段</p><h5 id="“归”阶段"><a href="#“归”阶段" class="headerlink" title="“归”阶段"></a>“<strong>归</strong>”阶段</h5><p>归阶段会调用<code>completeUnitOfWork</code>处理当前 fiber 节点，当前Fiber 节点如果有兄弟节点 <code>unitOfWork.sibilings !== null</code>那么就会进入到兄弟 fiber 节点的 <strong>“递”</strong>阶段<br>如果不存在兄弟 fiber 节点，那么进入<code>unitOfWork.return</code>的 “归” 阶段，也就是当前 fiber 节点的父节点<br>最终，递归交替执行，会归到 <code>rootFiber</code>，<code>render</code>阶段结束<br>以上面的 App 结构为例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">a</span>&gt;</span>link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">img</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的递归 fiber 树顺序为:</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28280007/1694077085158-ed88d267-ff6c-4925-856c-edb3b1d94266.png#averageHue=%23fbefee&clientId=uc11177c6-3c41-4&from=paste&height=611&id=u5ab37064&originHeight=1222&originWidth=1320&originalType=binary&ratio=2&rotation=0&showTitle=false&size=136030&status=done&style=none&taskId=u350a6e44-7d40-4bde-bad2-400f7b8efb4&title=&width=660" alt="image.png"></p><h6 id="performUnitOfWork总结"><a href="#performUnitOfWork总结" class="headerlink" title="performUnitOfWork总结"></a>performUnitOfWork总结</h6><p>现在我们大致了解：<br>React 16+ 使用 <code>workLoopSync/workLoopConcurrent</code>配合 <code>performUnitOfWork</code> 以循环的方式深度遍历整个 fiber 树，以此来达到同步、异步可中断的更新<br>其中<code>workLoopSync</code>的更新是不可中断的，其更新模式也也叫 Legacy 模式，用于兼容旧的同步更新，而<code>workLoopConcurrent</code> 则为并发模式，其任务可以被打断，避免协调器长时间占用主线程对界面产生卡顿的问题。<br><code>performUnitOfWork</code>是用于在循环中通过深度遍历 fiber 单链结构树 来构建 <code>workingInProgress</code>fiber 树的，实现了树的非递归遍历，因此可以配合<code>workLoopConcurrent</code> 实现将任务分配到<strong>时间切片</strong>中进行调用</p><h5 id="beginWork"><a href="#beginWork" class="headerlink" title="beginWork"></a>beginWork</h5><p>beginWork 做的事情，就是创建当前WIP fiber 节点的子节点 <code>workInProgress.child</code>，相关的代码有 接近 1200 行</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">beginWork</span>(<span class="params"></span></span><br><span class="line"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  workInProgress: Fiber,</span></span><br><span class="line"><span class="params">  renderLanes: Lanes,</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Fiber</span> | <span class="literal">null</span> &#123;</span><br><span class="line"> <span class="comment">// update时：如果current存在可能存在优化路径，可以复用current（即上一次更新的Fiber节点）</span></span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复用current</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">bailoutOnAlreadyFinishedWork</span>(</span><br><span class="line">      current,</span><br><span class="line">      workInProgress,</span><br><span class="line">      renderLanes,</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在首次渲染的时候，除了rootFiber，其余的 WIP fiber 的 current 都为 null ，也就是说，current fiber 树是一颗只有一个节点的树<br>这里使用 current 是为 null 将 beginWork 工作分为两个部分：</p><ul><li>update：本次是更新，那么满足一定调节可以复用 current</li><li>mount：初始化挂载，那么需要创建每一个 子 fiber</li></ul><p>复用 current 一般发生在该节点在 更新时并没有发生任何变化， 这样可以在 beginWork 中优化<br>在确实需要更新的路径上，通过 fiber 不同的 tag ，以不同的逻辑创建 子 fiber</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mount时：根据tag不同，创建不同的Fiber节点</span></span><br><span class="line"><span class="keyword">switch</span> (workInProgress.<span class="property">tag</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="title class_">IndeterminateComponent</span>: </span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">  <span class="keyword">case</span> <span class="title class_">LazyComponent</span>: </span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">  <span class="keyword">case</span> <span class="title class_">FunctionComponent</span>: </span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">  <span class="keyword">case</span> <span class="title class_">ClassComponent</span>: </span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">  <span class="keyword">case</span> <span class="title class_">HostRoot</span>:</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">  <span class="keyword">case</span> <span class="title class_">HostComponent</span>:</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">  <span class="keyword">case</span> <span class="title class_">HostText</span>:</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">    <span class="comment">// ...省略其他类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常见的函数组件、类组件的创建子 fiber 逻辑最终都会进入 reconcileChildren</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">reconcileChildren</span>(<span class="params"></span></span><br><span class="line"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  workInProgress: Fiber,</span></span><br><span class="line"><span class="params">  nextChildren: <span class="built_in">any</span>,</span></span><br><span class="line"><span class="params">  renderLanes: Lanes</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 对于mount的组件</span></span><br><span class="line">    workInProgress.<span class="property">child</span> = <span class="title function_">mountChildFibers</span>(</span><br><span class="line">      workInProgress,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      nextChildren,</span><br><span class="line">      renderLanes,</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 对于update的组件</span></span><br><span class="line">    workInProgress.<span class="property">child</span> = <span class="title function_">reconcileChildFibers</span>(</span><br><span class="line">      workInProgress,</span><br><span class="line">      current.<span class="property">child</span>,</span><br><span class="line">      nextChildren,</span><br><span class="line">      renderLanes,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>reconcileChildren</code> 实现了 Reconciler 的核心逻辑，而 <code>mountChildFibers</code> 、<code>reconcileChildFibers</code> 都来自于同一个函数 <code>ChildReconciler</code>，他们逻辑基本一致</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reconcileChildFibers = <span class="title class_">ChildReconciler</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mountChildFibers = <span class="title class_">ChildReconciler</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>函数 <code>reconcileChildFibers</code> 的目的就是通过 diff 算法，生成一个新的 fiber 节点，<code>mountChildFibers</code>不同的是，生成的 fiber 节点<strong>没有</strong>标识更新的 flag 属性（之前为effectTag属性）<br>在 <code>src/react/packages/react-reconciler/src/ReactFiberFlags.js</code>中可以看到Flag 的 所有类型，都是以二进制表示，以便使用位操作赋值多个 flag effect</p><p>并且在mount 的情况下，WIP fiber 树中只有 rootFiber 会有 flag 标签，也就是说 mount 情况下 只有一次对 DOM 的操作</p><p>beginWork 阶段做的就是以当前 WIP fiber 节点，区分mount 和 update 状态，创建 或者 复用 current fiber 子节点 来构建 WIP fiber 子树，给需要更新的 current fiber 子节点 对应的 WIP fiber 节点 打上 flag 更新标志，整个过程属于前面 performUnitOfWork 中的 <strong>“递” 阶段</strong>，直到叶子节点，那么就会调用<code>completeWork</code>进入 <strong>“归” 阶段</strong></p><h5 id="completeWork"><a href="#completeWork" class="headerlink" title="completeWork"></a>completeWork</h5><p>类似<code>beginWork</code>，<code>completeWork</code> 也是针对不同 <code>fiber.tag</code>调用不同的处理逻辑。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">completeWork</span>(<span class="params"></span></span><br><span class="line"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  workInProgress: Fiber,</span></span><br><span class="line"><span class="params">  renderLanes: Lanes,</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Fiber</span> | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> newProps = workInProgress.<span class="property">pendingProps</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.<span class="property">tag</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">IndeterminateComponent</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">LazyComponent</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">SimpleMemoComponent</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">FunctionComponent</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">ForwardRef</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Fragment</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Mode</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Profiler</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">ContextConsumer</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">MemoComponent</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">ClassComponent</span>: &#123;</span><br><span class="line">      <span class="comment">// ...省略</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">HostRoot</span>: &#123;</span><br><span class="line">      <span class="comment">// ...省略</span></span><br><span class="line">      <span class="title function_">updateHostContainer</span>(workInProgress);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">HostComponent</span>: &#123;</span><br><span class="line">      <span class="comment">// ...省略</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// ...省略</span></span><br></pre></td></tr></table></figure><p>completeWork 主要对 WIP fiber 做以下操作：</p><ol><li>如果是挂载（mount）类型<ol><li>调用<code>createInstance</code>，创建该 fiber 对应的 离屏DOM（offScreen DOM）节点，然后赋给 <code>fiber.stateNode</code></li><li>调用<code>appendAllChildren</code>，将所有孩子节点都插入到当前的离屏 DOM节点中</li><li>处理 传递给 子节点的 props 和 事件监听</li></ol></li><li>如果是更新（update）类型<ol><li>diff props，返回一个需要更新props的 数组 like：<code>[propName1, propValue1, propName2, propsValue2 ]</code></li><li>将 props 更新数组放入 updatePayload 赋给 当前 completeWork的 fiber.updateQueue</li></ol></li><li>将有所有 使用 flag标记的 子 fiber 挂载到当前 fiber 的 effectList 末尾，也就是 <code>fiber.firstEffect</code> 和 <code>fiber.lastEffect</code>指向的更新单向链表，这样在 commit 阶段就不需要再遍历一次 WIP fiber 树 来判断每个节点是否有 更新 flag 了，在 commit 阶段，<strong>只需要从 rootFiber.firstEffect 开始访问，就可以找到所有需要更新的 fiber 节点</strong></li></ol><blockquote><p>React团队成员<strong>Dan Abramov</strong>：<code>effectList</code> 相较于 <code>Fiber 树</code>，就像圣诞树上挂的那一串彩灯。</p></blockquote><p>在 workLoop 完成之后，接下来就进入到 commit 阶段</p><h3 id="Commit-阶段"><a href="#Commit-阶段" class="headerlink" title="Commit 阶段"></a>Commit 阶段</h3><p>当整个fiberRoot中的rootFiber 通过 模拟递归 完成 WIP fiber 树的创建之后，会调用 <code>commitRoot(fiberRoot)</code>进入 commit 阶段<br>commit 阶段的主要工作就是 调用 Renderer ，包括执行链表<code>rootFiber.firstEffect</code>上的副作用、调用生命周期Hooks等，该阶段分为三个子阶段，分别对应操作DOM前、中、后：</p><ol><li>before mutation：主要处理 useEffect 回调、处理 rootFiber 的副作用</li><li>mutation： 操作DOM</li><li>layout ：操作 DOM 之后</li></ol><p>在 commit 阶段中的大致流程为：</p><ol><li>执行或者调度 useEffect 的回调，确保所以 useEffect 的回调都完全被调度，保证他们延迟执行</li><li>处理 rootFiber 副作用，如果 rootFiber 有副作用，那么添加到自身的 effectList 末尾</li><li>触发生命周期hook，包括<code>componentDidXxx</code> 和 <code>useLayoutEffect</code> <code>useEffect</code> 等，如果这些方法中产生了新的副作用，那么就会开启新的一轮 render -&gt; commit 流程</li></ol><h4 id="Before-Mutation-子阶段"><a href="#Before-Mutation-子阶段" class="headerlink" title="Before Mutation 子阶段"></a>Before Mutation 子阶段</h4><p>此阶段主要工作是：</p><ol><li>处理DOM节点渲染/删除后的 autoFocus、blur逻辑</li><li>调用 getSnapshotBeforeUpdate 钩子函数</li><li>遍历 effectList ，目的是调度 useEffect 的 callback</li></ol><h5 id="为什么要调用-getSnapshotBeforeUpdate？"><a href="#为什么要调用-getSnapshotBeforeUpdate？" class="headerlink" title="为什么要调用 getSnapshotBeforeUpdate？"></a>为什么要调用 getSnapshotBeforeUpdate？</h5><p>为了代替 componentWillXXX 的钩子，在react 16 之前，componentWillXXX钩子是在render 阶段调用，由于 之前使用的是不可中断的递归遍历，使得 componentWillXXX 在同步递归中只会执行一次，而 react 16 render 阶段可能被中断、重新开始，使得 componentWillXXX 可能会被调用多次<br>官方在react 16 中 使用 getSnapshotBeforeUpdate 作为新的替代钩子，由于commit 阶段是同步的，不可被中断，那么 getSnapshotBeforeUpdate 钩子就只会在执行commit 时 执行一次</p><h5 id="如何调用-调度-useEffect-的-callback"><a href="#如何调用-调度-useEffect-的-callback" class="headerlink" title="如何调用/调度 useEffect 的 callback"></a>如何调用/调度 useEffect 的 callback</h5><p>在React 16 中，before mutation 阶段同步地执行完毕了所有的 callback，而在React 17 中所有的 useEffect 的 callback 都是被异步调用的，也就是延迟到页面渲染之后</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调度useEffect</span></span><br><span class="line"><span class="keyword">if</span> ((effectTag &amp; <span class="title class_">Passive</span>) !== <span class="title class_">NoEffect</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!rootDoesHavePassiveEffects) &#123;</span><br><span class="line">    rootDoesHavePassiveEffects = <span class="literal">true</span>;</span><br><span class="line">    <span class="title function_">scheduleCallback</span>(<span class="title class_">NormalSchedulerPriority</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 触发useEffect</span></span><br><span class="line">      <span class="title function_">flushPassiveEffects</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scheduleCallback 是 Scheduler 库提供的，目的是以某个优先级调度callback，flushPassiveEffects 是真正执行 useEffect 方法的函数，也就是说 调用flushPassiveEffects() 会执行 副作用回调函数<br>effectList中链式保存了需要执行副作用的子Fiber节点，包括对DOM 的插入 更新 和删除 等操作，并且如果该Fiber对应的是一个函数组件，该函数组件含有 useEffect 或者 useLayoutEffect，那么该Fiber 的 flag 也会被赋值为 hooks副作用 <code>HasEffect</code><br>useEffect 是在 before mutation 阶段进行异步调度，在 layout 阶段之后进行 callback 调用链的赋值，浏览器完成布局和绘制之后的异步延迟时间中进行的链式调用，这样做是为了避免这些副作用在执行时，阻塞浏览器的渲染过程<br>而 react 提供了 useLayoutEffect ，可以使 effect 在 浏览器 绘制下一帧之前执行</p><h4 id="Mutation-子阶段"><a href="#Mutation-子阶段" class="headerlink" title="Mutation 子阶段"></a>Mutation 子阶段</h4><p>渲染页面阶段，也是遍历 effectList 副作用链，只不过执行的是 <code>commitMutationEffects</code>函数 ，这些副作用都与页面上的内容有关，可以理解为执行WIP fiber 上需要更新的副作用，这里的操作主要是操作DOM，对DOM进行插入、更新、删除<br><code>commitMutationEffects</code>函数中对不同的DOM 操作 有不同的处理函数</p><h5 id="Placement-effect"><a href="#Placement-effect" class="headerlink" title="Placement effect"></a>Placement effect</h5><p>该操作是指需要将flag为 Placement 的fiber 节点中的 DOM 内容插入到页面中，其中调用react-dom中的方法操作DOM</p><h5 id="Update-effect"><a href="#Update-effect" class="headerlink" title="Update effect"></a>Update effect</h5><p>指该fiber 节点需要更新，一般来说该Fiber 节点类型为 一个函数组件<code>FunctionComponent</code>或者原生DOM组件<code>HostComponent</code><br>如果是函数组件，那么会调用 <code>commitHookEffectListUnmount</code>遍历 effectList 中的 useLayoutEffect callback中<strong>返回的销毁函数</strong><br>如果是DOM组件，则会调用 <code>commitUpdate</code>，最终会处理style children 以及一些 props ，将fiber.updateQueue 中更新的内容渲染到页面上</p><h5 id="Deletion-effect"><a href="#Deletion-effect" class="headerlink" title="Deletion effect"></a>Deletion effect</h5><p>如果fiber的flag是 Deletion ，那么fiber对应的DOM阶段需要从页面中删除，这个阶段会调用与生命周期结束相关的钩子 例如 useEffect callback 的返回函数， 类组件的 <code>componentWillUnmount</code>，同时解绑释放ref</p><h4 id="Layout-阶段"><a href="#Layout-阶段" class="headerlink" title="Layout 阶段"></a>Layout 阶段</h4><p>这个阶段的代码均是在 操作完所有的DOM 后被调用的<br>这里有一个时间差：由于js是同步执行了修改DOM这一系列操作，此时DOM 信息已经在浏览器中改变，但是浏览器并没有渲染这些DOM到页面上，也就是说，这个时机是在浏览器主线程执行因DOM的改变而产生的渲染之前，也就是下一帧更新画面到来之前。<br>在这个阶段，会同步执行<code>commitLayoutEffect</code>，这可能会让浏览器延迟渲染更新的画面<br><code>commitLayoutEffect</code>同样是去遍历effectList，执行所有<code>useLayoutEffect</code>的callback<br>其过程会调用 <code>commitLayoutEffectOnFiber</code>函数，在其中，会调用Class 组件中 设置状态的第二个callback</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">xxx</span>: <span class="number">1</span> &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;i am update~&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里可以发现， <code>useLayoutEffect</code> 和 <code>useEffect</code>的本质区别， 前者的callback 和 销毁return 都是 同步调用，分别layout之后渲染之前、DOM更新之前，而后者 <code>useEffect</code> 则需要先调度，然后再layout 阶段完成之后（代码执行完之后）再<strong>异步执行</strong><br>ReactDOM.render的第三个参数callback也会在此时同步地调用<br>在layout开始前 mutation结束后，会将 WIP rootFiber 赋值到 fiberRoot.current ，这样就将 WIP fiber 变为了 current fiber，此时切换是为了 layout 阶段中的生命周期函数能获取到更新后的DOM</p><h2 id="Diffing-算法"><a href="#Diffing-算法" class="headerlink" title="Diffing 算法"></a>Diffing 算法</h2><p>该算法的主要使用场景是：在 render 阶段循环递归 fiber 树时，对于 Update 操作，对比更新前后的fiber 节点，将结果生成新的 fiber 节点，结果可能是复制（没有发生变化），部分复制，其余更新（发生变化）</p><h3 id="DOM-节点的关系"><a href="#DOM-节点的关系" class="headerlink" title="DOM 节点的关系"></a>DOM 节点的关系</h3><p>在React 中，一个DOM 节点会有4个相关对象：</p><ol><li>current fiber 节点，当前页面上 DOM 对应的 fiber</li><li>workingInProgress fiber 节点，代表即将即将对该DOM 进行 更新的 fiber</li><li>DOM 本身</li><li>JSX 对象，也就是该DOM节点对应的React Element 对象</li></ol><p>Diff 算法运行的本质其实就是将 1 和 4 对比之后，生成 2</p><h3 id="Diff-算法限制"><a href="#Diff-算法限制" class="headerlink" title="Diff 算法限制"></a>Diff 算法限制</h3><p>如果要对比两棵fiber树的所有节点，带来指数级的算法复杂度 <code>O(n^3)</code>这里的n指的是树中节点的数量，为了降低复杂度，React的Diff 算法做了三个复杂度限制：</p><ol><li>只对同级元素进行Diff 计算，如果 一个节点在更新中跨域了层级，那么直接会对其进行销毁并重构，</li></ol><blockquote><p>例如：<br>如果父节点下的子节点有一颗子树，如果更新后子节点变成了父节点的兄弟节点，那么react 会直接删除掉子节点以及所有的子树，然后再父节点的后面的兄弟节点上 重新创建新的 子节点 和 下面的子树</p></blockquote><ol start="2"><li>针对不同类型的元素会生成不同的树，如果元素由div 更新 为了 p ，但其子树都不变，那么，React会销毁 div 以及子树，然后新建 p 以及子树</li><li>要求开发者在循环渲染的中使用key props进行性能优化</li></ol><h3 id="Diff-的实现"><a href="#Diff-的实现" class="headerlink" title="Diff 的实现"></a>Diff 的实现</h3><p>Diff 算法的入口在<code>reconcileChildFiber</code> 这里是使用父Fiber 进行 孩子的 Diff</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据newChild类型选择不同diff函数处理</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reconcileChildFibers</span>(<span class="params"></span></span><br><span class="line"><span class="params">  returnFiber: Fiber,</span></span><br><span class="line"><span class="params">  currentFirstChild: Fiber | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  newChild: <span class="built_in">any</span>,</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Fiber</span> | <span class="literal">null</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> isObject = <span class="keyword">typeof</span> newChild === <span class="string">&#x27;object&#x27;</span> &amp;&amp; newChild !== <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isObject) &#123;</span><br><span class="line">    <span class="comment">// object类型，可能是 REACT_ELEMENT_TYPE 或 REACT_PORTAL_TYPE</span></span><br><span class="line">    <span class="keyword">switch</span> (newChild.<span class="property">$$typeof</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="attr">REACT_ELEMENT_TYPE</span>:</span><br><span class="line">        <span class="comment">// 调用 reconcileSingleElement 处理</span></span><br><span class="line">        <span class="comment">// // ...省略其他case</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> newChild === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用 reconcileSingleTextNode 处理</span></span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isArray</span>(newChild)) &#123;</span><br><span class="line">    <span class="comment">// 调用 reconcileChildrenArray 处理</span></span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一些其他情况调用处理函数</span></span><br><span class="line">  <span class="comment">// ...省略</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以上都没有命中，删除节点</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">deleteRemainingChildren</span>(returnFiber, currentFirstChild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Diff的同级比较有两种类型：</p><ol><li>newChild是单一节点，例如文字节点，单个元素</li><li>newChild 是数组节点，也就是同级下有多个节点</li></ol><h4 id="单节点Diff"><a href="#单节点Diff" class="headerlink" title="单节点Diff"></a>单节点Diff</h4><p>当 newChild 为 jsx 对象或者 string、number 时，进入 <code>reconcileSingleElement</code>进行对比<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28280007/1694487553950-f9b65086-c3bf-4db5-aa93-724e0246c3c5.png#averageHue=%23f5f9f8&clientId=u4c83b350-96e2-4&from=paste&height=609&id=u3d701418&originHeight=1218&originWidth=1582&originalType=binary&ratio=2&rotation=0&showTitle=true&size=310287&status=done&style=none&taskId=u5b22c8e6-fed0-401c-8e63-9a34b971f53&title=%E6%AD%A4%E5%9B%BE%E7%89%87%E6%9D%A5%E8%87%AA%20%E5%8D%A1%E9%A2%82%20%E7%9A%84%20React%20%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98&width=791" alt="此图片来自 卡颂 的 React 技术揭秘" title="此图片来自 卡颂 的 React 技术揭秘"><br><code>reconcileSingleElement</code>中主要对比 React element 与 current fiber 的 key 以及 type，当key 和 type都相同时，会根据 新的 React element 的props 和复用 现有的 current fiber 创建新的fiber 名为 <code>existing</code>，<br>如果 type 不相同，那么说明两者不属于一个组件，切需要清空 兄弟元素<br>由于React 的 fiber 节点的child 是一个链表结构，当新旧节点的key不相同时，那么说明该fiber 不能被复用，需要删除当前 fiber ，但是兄弟元素不会被删除，因为可能后面的fiber可以复用<br>最后会通过new react element，也就是new child 创建一个新的 fiber</p><h4 id="多节点Diff"><a href="#多节点Diff" class="headerlink" title="多节点Diff"></a>多节点Diff</h4><p>此处会处理子节点数组的情况，这是diff 算法的核心部分，比较难以理解，先放到后面再说</p><h2 id="状态更新"><a href="#状态更新" class="headerlink" title="状态更新"></a>状态更新</h2><p>在React 中，触发更新的基本都是以下几个api：</p><ul><li>ReactDOM.render</li><li>this.setState</li><li>this.forceUpdate</li><li>useState</li><li>useReducer</li></ul><p>虽然使用场景不相同，但是他们背后会接入一套统一的更新机制，去触发 render 到 commit ，以更新视图<br>每次状态更新 都会生成一个 <code>Update</code>对象，来保存更新状态的内容，切这个对象保存在触发状态更新的current fiber 节点上<br>调用<code>markUpdateLaneFromFiberToRoot</code>方法，会一直沿着 fiber 的 return 属性，找到 顶层的 rootFiber，然后返回rootFiber<br>拿到rootFiber 后 ，react 就要 调度本次更新任务，决定优先级<code>Lane</code>以及同步或者异步更新<br>调度的回调函数为 render 的 更新阶段入口，也就是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">performSyncWorkOnRoot.<span class="title function_">bind</span>(<span class="literal">null</span>, root);</span><br><span class="line">performConcurrentWorkOnRoot.<span class="title function_">bind</span>(<span class="literal">null</span>, root);</span><br></pre></td></tr></table></figure><p>说以说，状态更新的主要路径为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">触发状态更新（根据场景调用不同方法）</span><br><span class="line"></span><br><span class="line">  |</span><br><span class="line">  |</span><br><span class="line">  v</span><br><span class="line"></span><br><span class="line">创建<span class="title class_">Update</span>对象（<span class="string">`updateContainer`</span>）</span><br><span class="line"></span><br><span class="line">  |</span><br><span class="line">  |</span><br><span class="line">  v</span><br><span class="line"></span><br><span class="line">从fiber到root（<span class="string">`markUpdateLaneFromFiberToRoot`</span>）</span><br><span class="line"></span><br><span class="line">  |</span><br><span class="line">  |</span><br><span class="line">  v</span><br><span class="line"></span><br><span class="line">调度更新（<span class="string">`ensureRootIsScheduled`</span>）</span><br><span class="line"></span><br><span class="line">  |</span><br><span class="line">  |</span><br><span class="line">  v</span><br><span class="line"></span><br><span class="line">render阶段（<span class="string">`performSyncWorkOnRoot`</span> 或 <span class="string">`performConcurrentWorkOnRoot`</span>）</span><br><span class="line"></span><br><span class="line">  |</span><br><span class="line">  |</span><br><span class="line">  v</span><br><span class="line"></span><br><span class="line">commit阶段（<span class="string">`commitRoot`</span>）</span><br></pre></td></tr></table></figure><h3 id="心智模型"><a href="#心智模型" class="headerlink" title="心智模型"></a>心智模型</h3><p>React 的更新方式分为 两种： 同步更新 和并发更新<br>将两个更新类比与代码版本控制：</p><h4 id="同步更新"><a href="#同步更新" class="headerlink" title="同步更新"></a>同步更新</h4><p>使用<code>ReactDOM.render</code>创建的应用都是通过同步更新的方式进行状态更新，他们的状态更新顺序是没有优先级的概念类似于版本迭代<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28280007/1694501930485-6faa9f6c-371b-43bd-a0ff-c8762392f94d.png#averageHue=%23fbf5f4&clientId=u4c83b350-96e2-4&from=paste&height=181&id=u61da5d69&originHeight=362&originWidth=1540&originalType=binary&ratio=2&rotation=0&showTitle=false&size=115851&status=done&style=none&taskId=u00dc7dca-cc32-4fdf-b0f9-ce0c20e1065&title=&width=770" alt="image.png"><br>其中 蓝色 代表普通优先级， 红色代表高优先级</p><h4 id="并发更新"><a href="#并发更新" class="headerlink" title="并发更新"></a>并发更新</h4><p>在React中，通过<code>ReactDOM.createBlockingRoot</code>和<code>ReactDOM.createRoot</code>创建的应用会采用并发的方式更新状态。<br>也就类似于，使用 git flow 中应对 hotfix 的操作，hotfix 为优先级最高的修复分支<br>当项目出现bug时，需要从 master 切 出一个 hotfix 分支用于紧急修复，并且优先级大于dev分支<br>在修复完成后就hotfix 分支就尽快合并到 master 上，然后 此时 dev 分支上的 旧提交就和 新 master 分支一不一致，那么就要对dev 分支使用 <code>git rebase master</code>来重新接入 dev 分支，保证包含了 hotfix 修复的内容。<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28280007/1694502310510-0ad65564-1357-4b7d-8cb9-783d257fb7cf.png#averageHue=%23faf3f2&clientId=u4c83b350-96e2-4&from=paste&height=278&id=udb220a2b&originHeight=556&originWidth=1342&originalType=binary&ratio=2&rotation=0&showTitle=false&size=136898&status=done&style=none&taskId=ub79b6521-9cbb-4877-a840-3486c4b444a&title=&width=671" alt="image.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28280007/1694502317396-330a1684-2ffb-48bb-b2af-9ad4dffd31ae.png#averageHue=%23fdfcfa&clientId=u4c83b350-96e2-4&from=paste&height=355&id=ue1608a84&originHeight=792&originWidth=1490&originalType=binary&ratio=2&rotation=0&showTitle=false&size=207352&status=done&style=none&taskId=ud4fdd134-bfbb-4013-9645-8f16cccb1d5&title=&width=668" alt="image.png"><br>此时的 D 可以理解为 React 更新中的高优先级更新，他可以打断 其余 蓝色 低优先级的更新，先完成 render - commit 阶段<br>也就是说，<strong>React并发模式</strong>的低优先级任务会<strong>根据</strong>高优先级任务<strong>更新后的结果来进行更新</strong></p><h2 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h2><h3 id="理念"><a href="#理念" class="headerlink" title="理念"></a>理念</h3><p>正在整理中，未完待续</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> React </tag>
            
            <tag> 源码 </tag>
            
            <tag> 开源架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript正则表达式学习笔记</title>
      <link href="/2023/07/24/regexp/"/>
      <url>/2023/07/24/regexp/</url>
      
        <content type="html"><![CDATA[<h2 id="否定字符集"><a href="#否定字符集" class="headerlink" title="否定字符集"></a>否定字符集</h2><p>字符集放置在<code>[]</code>内部，要创建<code>否定字符集</code>，你需要在开始括号后面和不想匹配的字符前面放置<code>插入字符</code>（即<code>^</code>）。</p><p>例如，<code>/[^aeiou]/gi</code>匹配所有非元音字符。注意，字符<code>.</code>、<code>!</code>、<code>[</code>、<code>@</code>、<code>/</code>和空白字符等也会被匹配</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> quoteSample = <span class="string">&quot;3 blind mice.&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> myRegex = <span class="regexp">/[^0-9|aeiou]/gi</span>; <span class="comment">// 匹配数字以及元音以外的所有字符</span></span><br><span class="line"><span class="keyword">let</span> result = quoteSample.<span class="title function_">match</span>(myRegex); </span><br></pre></td></tr></table></figure><h2 id="匹配出现一次或多次的字符"><a href="#匹配出现一次或多次的字符" class="headerlink" title="匹配出现一次或多次的字符"></a>匹配出现一次或多次的字符</h2><p>匹配出现一次或者连续多次的的字符（或字符组）。它可能出现一次或者多次</p><p>使用<code>+</code>符号来检查情况是否如此。记住，字符或匹配模式必须一个接一个地连续出现。</p><p>例如，<code>/a+/g</code>会在<code>&quot;abc&quot;</code>中匹配到一个匹配项，并且返回<code>[&quot;a&quot;]</code>。因为<code>+</code>的存在，它也会在<code>&quot;aabc&quot;</code>中匹配到一个匹配项，然后返回<code>[&quot;aa&quot;]</code>。</p><p>如果它是检查字符串<code>&quot;abab&quot;</code>，它将匹配到两个匹配项并且返回<code>[&quot;a&quot;, &quot;a&quot;]</code>，因为<code>a</code>字符不连续，在它们之间有一个<code>b</code>字符。最后，因为在字符串<code>&quot;bcd&quot;</code>中没有<code>&quot;a&quot;</code>，因此找不到匹配项。</p><h2 id="匹配出现零次或多次的字符"><a href="#匹配出现零次或多次的字符" class="headerlink" title="匹配出现零次或多次的字符"></a>匹配出现零次或多次的字符</h2><p>创建一个变量为<code>chewieRegex</code>的正则表达式，使用<code>*</code>符号在<code>chewieQuote</code>中匹配<code>&quot;A&quot;</code>及其之后出现的零个或多个<code>&quot;a&quot;</code>。你的正则表达式不需要使用修饰符，也不需要匹配引号。</p><ul><li><p>你的正则表达式<code>chewieRegex</code>应该使用<code>*</code>符号匹配<code>&quot;A&quot;</code>之后出现的零个或多个<code>&quot;a&quot;</code>字符。</p></li><li><p>你的正则表达式<code>chewieRegex</code>应该匹配 16 个字符。</p></li><li><p>你的正则表达式应该匹配<code>&quot;Aaaaaaaaaaaaaaaa&quot;</code>。</p></li><li><p>你的正则表达式在<code>&quot;He made a fair move. Screaming about it can&#39;t help you.&quot;</code>中不应该匹配任何字符。</p></li><li><p>你的正则表达式在<code>&quot;Let him have it. It&#39;s not wise to upset a Wookiee.&quot;</code>中不应该匹配任何字符</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> chewieQuote = <span class="string">&quot;Aaaaaaaaaaaaaaaarrrgh!&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> chewieRegex = <span class="regexp">/Aa*/g</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = chewieQuote.<span class="title function_">match</span>(chewieRegex);</span><br></pre></td></tr></table></figure><h2 id="用惰性匹配来查找字符"><a href="#用惰性匹配来查找字符" class="headerlink" title="用惰性匹配来查找字符"></a>用惰性匹配来查找字符</h2><p>在正则表达式中，<code>贪婪</code>匹配会匹配到符合正则表达式匹配模式的字符串的最长可能部分，并将其作为匹配项返回。另一种方案称为<code>懒惰</code>匹配，它会匹配到满足正则表达式的字符串的最小可能部分。</p><p>你可以将正则表达式<code>/t[a-z]*i/</code>应用于字符串<code>&quot;titanic&quot;</code>。这个正则表达式是一个以<code>t</code>开始，以<code>i</code>结束，并且中间有一些字母的匹配模式。</p><p>正则表达式默认是<code>贪婪</code>匹配，因此匹配返回为<code>[&quot;titani&quot;]</code>。它会匹配到适合该匹配模式的最大子字符串。</p><p>但是，你可以使用<code>?</code>字符来将其变成<code>懒惰</code>匹配。调整后的正则表达式<code>/t[a-z]*?i/</code>匹配字符串<code>&quot;titanic&quot;</code>返回<code>[&quot;ti&quot;]</code>。</p><h2 id="匹配所有的字母和数字"><a href="#匹配所有的字母和数字" class="headerlink" title="匹配所有的字母和数字"></a>匹配所有的字母和数字</h2><p>使用字符类，你可以使用<code>[a-z]</code>搜寻字母表中的所有字母。这种字符类是很常见的，它有一个缩写，但这个缩写也包含额外的字符。</p><p>JavaScript 中与字母表匹配的最接近的字符类是<code>\w</code>，这个缩写等同于<code>[A-Za-z0-9_]</code>。它不仅可以匹配大小写字母和数字，注意，它还会匹配下划线字符（<code>_</code>）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回字符串内英文句子的单词数</span></span><br><span class="line"><span class="keyword">let</span> quoteSample = <span class="string">&quot;The five boxing wizards jump quickly .&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> alphabetRegexV2 = <span class="regexp">/\w+/g</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = quoteSample.<span class="title function_">match</span>(alphabetRegexV2).<span class="property">length</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure><h2 id="匹配除了字母和数字的所有符号"><a href="#匹配除了字母和数字的所有符号" class="headerlink" title="匹配除了字母和数字的所有符号"></a>匹配除了字母和数字的所有符号</h2><p>你已经了解到可以使用缩写<code>\w</code>来匹配字母和数字<code>[A-Za-z0-9_]</code>。不过，有可能你想要搜寻的匹配模式与字母数字相反。</p><p>你可以使用<code>\W</code>搜寻和<code>\w</code>相反的匹配模式。注意，相反匹配模式使用大写字母。此缩写与<code>[^A-Za-z0-9_]</code>是一样的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> quoteSample = <span class="string">&quot;The five boxing wizards jump quickly.&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> nonAlphabetRegex = <span class="regexp">/\W/g</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = quoteSample.<span class="title function_">match</span>(nonAlphabetRegex).<span class="property">length</span>; <span class="comment">// result = 6</span></span><br></pre></td></tr></table></figure><h2 id="匹配所有非数字"><a href="#匹配所有非数字" class="headerlink" title="匹配所有非数字"></a>匹配所有非数字</h2><p>查找非数字字符的缩写是<code>\D</code>。这等同于字符串<code>[^0-9]</code>，它查找不是 0 - 9 之间数字的单个字符。</p><h2 id="案例：限制可能的用户名"><a href="#案例：限制可能的用户名" class="headerlink" title="案例：限制可能的用户名"></a>案例：限制可能的用户名</h2><p>你需要检查数据库中的所有用户名。以下是用户在创建用户名时必须遵守的一些简单规则。</p><ol><li><p>用户名中的数字必须在最后，且数字可以有零个或多个。</p></li><li><p>用户名字母可以是小写字母和大写字母。</p></li><li><p>用户名长度必须至少为两个字符。两位用户名只能使用字母。</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> username = <span class="string">&quot;JackOfAllTrades&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> userCheck = <span class="regexp">/[a-z][a-z]\d*/i</span>;</span><br><span class="line"><span class="keyword">let</span> result = userCheck.<span class="title function_">test</span>(username);</span><br></pre></td></tr></table></figure><h2 id="匹配空白字符"><a href="#匹配空白字符" class="headerlink" title="匹配空白字符"></a>匹配空白字符</h2><p>迄今为止的挑战包括匹配的字母和数字。你还可以匹配字母之间的空格。</p><p>你可以使用<code>\s</code>搜寻空格，其中<code>s</code>是小写。此匹配模式不仅匹配空格，还匹配回车符、制表符、换页符和换行符，你可以将其视为与<code>[\r\t\f\n\v]</code>类似。</p><h2 id="指定匹配的上限和下限"><a href="#指定匹配的上限和下限" class="headerlink" title="指定匹配的上限和下限"></a>指定匹配的上限和下限</h2><p>回想一下，你使用加号<code>+</code>查找一个或多个字符，使用星号<code>*</code>查找零个或多个字符。这些都很方便，但有时你需要匹配一定范围的匹配模式。</p><p>你可以使用<code>数量说明符</code>指定匹配模式的上下限。数量说明符与花括号（<code>&#123;</code>和<code>&#125;</code>）一起使用。你可以在花括号之间放两个数字，这两个数字代表匹配模式的上限和下限。</p><p>例如，要在字符串<code>&quot;ah&quot;</code>中匹配仅出现<code>3</code>到<code>5</code>次的字母<code>a</code>，你的正则表达式应为<code>/a&#123;3,5&#125;h/</code>。</p><ul><li>匹配在<code>&quot;Oh no&quot;</code>中仅出现<code>3</code>到<code>6</code>次的字母<code>h</code>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ohStr = <span class="string">&quot;Ohhh no&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> ohRegex = <span class="regexp">/Oh&#123;3,6&#125; no/</span>;</span><br><span class="line"><span class="keyword">let</span> result = ohRegex.<span class="title function_">test</span>(ohStr);</span><br></pre></td></tr></table></figure><h2 id="指定匹配的确切数量"><a href="#指定匹配的确切数量" class="headerlink" title="指定匹配的确切数量"></a>指定匹配的确切数量</h2><p>你可以使用带有花括号的<code>数量说明符</code>来指定匹配模式的上下限。但有时你只需要特定数量的匹配。</p><p>要指定一定数量的匹配模式，只需在大括号之间放置一个数字。</p><p>例如，要只匹配字母<code>a</code>出现<code>3</code>次的单词<code>&quot;hah&quot;</code>，你的正则表达式应为<code>/ha&#123;3&#125;h/</code>。</p><h2 id="检查全部或无"><a href="#检查全部或无" class="headerlink" title="检查全部或无"></a>检查全部或无</h2><p>有时，你想要搜寻的匹配模式可能有不确定是否存在的部分。尽管如此，你还是想检查它们。</p><p>为此，你可以使用问号<code>?</code>指定可能存在的元素。这将检查前面的零个或一个元素。你可以将此符号视为前面的元素是可选的</p><ul><li>匹配美式英语（favorite）和英式英语（favourite）的单词版本。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> favWord = <span class="string">&quot;favorite&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> favRegex = <span class="regexp">/favou?rite/</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = favRegex.<span class="title function_">test</span>(favWord);</span><br></pre></td></tr></table></figure><h2 id="正向先行断言和负向先行断言"><a href="#正向先行断言和负向先行断言" class="headerlink" title="正向先行断言和负向先行断言"></a>正向先行断言和负向先行断言</h2><p><strong>先行断言</strong>是告诉 JavaScript 在字符串中向前查找的匹配模式。当你想要在同一个字符串上搜寻多个匹配模式时，这非常有用。</p><p>有两种先行断言方式：<code>正向先行断言</code>和<code>负向先行断言</code></p><p><strong>正向先行断言</strong>会查看并确保搜索匹配模式中的元素存在，但实际上并不匹配。正向先行断言的用法是<code>(?=...)</code>，其中<code>...</code>就是需要存在但不会被匹配的部分，每个<code>(?=...)</code>都是一个对整个测试对象的测试规则，</p><p>另一方面，<strong>负向先行断言</strong>会查看并确保搜索匹配模式中的元素不存在。负向先行断言的用法是<code>(?!...)</code>，其中<code>...</code>是你希望不存在的匹配模式。如果负向先行断言部分不存在，将返回匹配模式的其余部分。</p><ul><li><p><strong>先行断言</strong>的更实际用途是检查一个字符串中的两个或更多匹配模式。这里有一个简单的密码检查器，密码规则是 3 到 6 个字符且至少包含一个数字：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> password = <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> checkPass = <span class="regexp">/(?=\w&#123;3,6&#125;)(?=\D*\d)/</span>;</span><br><span class="line">checkPass.<span class="title function_">test</span>(password); <span class="comment">// Returns true</span></span><br></pre></td></tr></table></figure></li><li><p>使用<strong>先行断言</strong>以匹配至少5个字符且有两个连续数字的密码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sampleWord = <span class="string">&quot;astronaut&quot;</span>;</span><br><span class="line"><span class="comment">// \D* 匹配前面多个非数字字符，这2个(?=) 为串行匹配，意思为，先通过第一个(?=)，然后再通过第二个(?=)，每个</span></span><br><span class="line"><span class="keyword">let</span> pwRegex = <span class="regexp">/(?=\w&#123;5,&#125;)(?=\D*\d&#123;2,&#125;)/</span>; </span><br><span class="line"><span class="keyword">let</span> result = pwRegex.<span class="title function_">test</span>(sampleWord);</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用捕获组重用模式（重要）"><a href="#使用捕获组重用模式（重要）" class="headerlink" title="使用捕获组重用模式（重要）"></a>使用捕获组重用模式（重要）</h2><p>如果要搜寻的匹配模式会在字符串中出现多次，那么手动重复该正则表达式不是一个高效的方法。此时就需要用到<strong>捕获组</strong></p><p>你可以使用<strong>捕获组</strong>搜寻重复的子字符串。括号<code>(</code>和<code>)</code>可以用来匹配重复的子字符串。你只需要把重复匹配模式的正则表达式放在括号中即可。</p><p>要指定重复字符串将出现的位置，可以使用反斜杠（<code>\</code>）后接一个数字。这个数字从 1 开始，随着你使用的每个捕获组的增加而增加。这里有一个示例，<code>\1</code>可以匹配第一个组。</p><p>下面的示例匹配任意两个被空格分割的单词：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> repeatStr = <span class="string">&quot;regex regex&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> repeatRegex = <span class="regexp">/(\w+)\s\1/</span>; <span class="comment">// </span></span><br><span class="line">repeatRegex.<span class="title function_">test</span>(repeatStr); <span class="comment">// Returns true</span></span><br><span class="line">repeatStr.<span class="title function_">match</span>(repeatRegex); <span class="comment">// Returns [&quot;regex regex&quot;, &quot;regex&quot;]</span></span><br></pre></td></tr></table></figure><ul><li>此处的\1 为占位符，复用一号位<code>(\w+)</code>匹配到的值作为规则在当前位置进行检测</li><li><code>(\w+)</code> 捕获到第一个单词<code>regex</code> ，那么后面的\1就以这个<code>regex</code>作为当前\1所在位置的规则进行匹配</li></ul><p>在字符串上使用<code>.match()</code>方法将返回一个数组，其中包含它匹配的字符串及其捕获组。</p><ul><li><p>在正则表达式<code>reRegex</code>中使用<code>捕获组</code>，以匹配在字符串中仅重复三次的数字，每一个都由空格分隔。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> repeatNum = <span class="string">&quot;42 42 42&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> reRegex =  <span class="regexp">/^(\d+)\s\1\s\1$/</span>; <span class="comment">//使用开头^和结尾$来包裹表达式模板进行严格匹配,\1处复用第一个匹配到的值作为规则</span></span><br><span class="line"><span class="keyword">let</span> result = reRegex.<span class="title function_">test</span>(repeatNum);</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用捕获组搜索和替换"><a href="#使用捕获组搜索和替换" class="headerlink" title="使用捕获组搜索和替换"></a>使用捕获组搜索和替换</h2><p>搜索功能是很有用的。但是，当你的搜索也执行更改（或替换）匹配文本的操作时，搜索功能就会显得更加强大。</p><p>可以使用字符串上<code>.replace()</code>方法来搜索并替换字符串中的文本。<code>.replace()</code>的输入首先是你想要搜索的正则表达式匹配模式，第二个参数是用于替换匹配的字符串或用于执行某些操作的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wrongText = <span class="string">&quot;The sky is silver.&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> silverRegex = <span class="regexp">/silver/</span>;</span><br><span class="line">wrongText.<span class="title function_">replace</span>(silverRegex, <span class="string">&quot;blue&quot;</span>);</span><br><span class="line"><span class="comment">// Returns &quot;The sky is blue.&quot;</span></span><br></pre></td></tr></table></figure><p>你还可以使用美元符号（<code>$</code>）访问替换字符串中的捕获组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Code Camp&quot;</span>.<span class="title function_">replace</span>(<span class="regexp">/(\w+)\s(\w+)/</span>, <span class="string">&#x27;$2 $1&#x27;</span>);</span><br><span class="line"><span class="comment">// Returns &quot;Camp Code&quot;</span></span><br></pre></td></tr></table></figure><h2 id="案例：删除开头和结尾的空白"><a href="#案例：删除开头和结尾的空白" class="headerlink" title="案例：删除开头和结尾的空白"></a>案例：删除开头和结尾的空白</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hello = <span class="string">&quot;   Hello, World!  &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> wsRegex = <span class="regexp">/^\s+|\s+$/g</span>; <span class="comment">// 匹配多个空格开头和结尾的多个空格</span></span><br><span class="line"><span class="keyword">let</span> result = hello.<span class="title function_">replace</span>(wsRegex,<span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="案例：验证或者匹配文本中的邮箱"><a href="#案例：验证或者匹配文本中的邮箱" class="headerlink" title="案例：验证或者匹配文本中的邮箱"></a>案例：验证或者匹配文本中的邮箱</h2><ul><li><p>匹配出邮箱</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> email = <span class="string">&quot;my email is  ljp123456@sina.com&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> emailRegex = <span class="regexp">/\w&#123;5,16&#125;@\D&#123;2,&#125;.[com|net|org|cn]$/</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = email.<span class="title function_">match</span>(emailRegex)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">[</span><br><span class="line">  <span class="string">&#x27;ljp123456@sina.com&#x27;</span>,</span><br><span class="line">  <span class="attr">index</span>: <span class="number">13</span>,</span><br><span class="line">  <span class="attr">input</span>: <span class="string">&#x27;my email is  ljp123456@sina.com&#x27;</span>,</span><br><span class="line">  <span class="attr">groups</span>: <span class="literal">undefined</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>验证邮箱格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> email = <span class="string">&quot;ljp123456@sina.com&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> emailRegex = <span class="regexp">/^\w&#123;5,16&#125;@\D&#123;2,&#125;.[com|net|org|cn]$/</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = emailRegex.<span class="title function_">test</span>(email)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure></li></ul><h2 id="案例：短线连接格式转换"><a href="#案例：短线连接格式转换" class="headerlink" title="案例：短线连接格式转换"></a>案例：短线连接格式转换</h2><p>在这道题目中，我们需要写一个函数，把一个字符串转换为“短线连接格式”。短线连接格式的意思是，所有字母都是小写，且用<code>-</code>连接。比如，对于<code>Hello World</code>，应该转换为<code>hello-world</code>；对于<code>I love_Javascript-VeryMuch</code>，应该转换为<code>i-love-javascript-very-much</code>。</p><ul><li><p><code>spinalCase(&quot;This Is Spinal Tap&quot;)</code>应该返回<code>&quot;this-is-spinal-tap&quot;</code>。</p></li><li><p><code>spinalCase(&quot;thisIsSpinalTap&quot;)</code>应该返回<code>&quot;this-is-spinal-tap&quot;</code>。</p></li><li><p><code>spinalCase(&quot;The_Andy_Griffith_Show&quot;)</code>应该返回<code>&quot;the-andy-griffith-show&quot;</code>。</p></li><li><p><code>spinalCase(&quot;Teletubbies say Eh-oh&quot;)</code>应该返回<code>&quot;teletubbies-say-eh-oh&quot;</code>。</p></li><li><p><code>spinalCase(&quot;AllThe-small Things&quot;)</code>应该返回<code>&quot;all-the-small-things&quot;</code></p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">spinalCase</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> temp = str.<span class="title function_">replace</span>(<span class="regexp">/^\s+|\s+$/</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  temp = (temp.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>() + temp.<span class="title function_">substring</span>(<span class="number">1</span>)) <span class="comment">//将字符串头部</span></span><br><span class="line">    .<span class="title function_">replace</span>(<span class="regexp">/[\-]/g</span>,<span class="string">&#x27; &#x27;</span>) </span><br><span class="line">    .<span class="title function_">match</span>(<span class="regexp">/\w+/g</span>)</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>() + item.<span class="title function_">substring</span>(<span class="number">1</span>))</span><br><span class="line">    .<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    .<span class="title function_">match</span>(<span class="regexp">/[A-Z][a-z]+/g</span>)</span><br><span class="line">    .<span class="title function_">join</span>(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">    .<span class="title function_">toLowerCase</span>()</span><br><span class="line">  <span class="keyword">return</span> temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">spinalCase</span>(<span class="string">&#x27;This Is Spinal Tap&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="儿童黑话"><a href="#儿童黑话" class="headerlink" title="儿童黑话"></a>儿童黑话</h2><p>我们需要写一个函数，把传入的字符串翻译成“儿童黑话”。</p><p><a href="http://en.wikipedia.org/wiki/Pig_Latin">儿童黑话</a>的基本转换规则很简单，只需要把一个英文单词的第一个辅音字母或第一组辅音从移到单词的结尾，并在后面加上<code>ay</code>即可。在英语中，字母 a、e、i、o、u 为元音，其余的字母均为辅音。辅音从的意思是连续的多个辅音字母。</p><p>额外地，如果单词本身是以元音开头的，那只需要在结尾加上<code>way</code>。</p><p>在本题中，传入的单词一定会是英文单词，且所有字母均为小写。</p><ul><li><p><code>translatePigLatin(&quot;california&quot;)</code>应该返回 “aliforniacay”。</p></li><li><p><code>translatePigLatin(&quot;paragraphs&quot;)</code>应该返回 “aragraphspay”。</p></li><li><p><code>translatePigLatin(&quot;glove&quot;)</code>应该返回 “oveglay”。</p></li><li><p><code>translatePigLatin(&quot;algorithm&quot;)</code>应该返回 “algorithmway”。</p></li><li><p><code>translatePigLatin(&quot;eight&quot;)</code>应该返回 “eightway”。</p></li><li><p>你的代码应当能够处理第一个元音字母在单词结尾的情况。比如<code>translatePigLatin(&quot;she&quot;)</code>应该返回 “eshay”。</p></li><li><p>你的代码应当能够处理单词中不含元音字母的情况。比如<code>translatePigLatin(&quot;rhythm&quot;)</code>应该返回 “rhythmay”。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">translatePigLatin</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = str.<span class="title function_">match</span>(<span class="regexp">/[aeiou]\w*/</span>) <span class="comment">// 匹配元音开头且后续字母出现0次或多次的片段</span></span><br><span class="line">  <span class="keyword">let</span> b = str.<span class="title function_">match</span>(<span class="regexp">/^[^aeiou]+/</span>) <span class="comment">// 匹配以元音字母开头且后续至少一次的片段</span></span><br><span class="line">  <span class="comment">// 如果是以字符串</span></span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/^[aeiou]+/</span>.<span class="title function_">test</span>(str) ? str + <span class="string">&#x27;way&#x27;</span> : (a ? a : <span class="string">&#x27;&#x27;</span>) + (b ? (b + <span class="string">&#x27;ay&#x27;</span>) : <span class="string">&#x27;way&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">translatePigLatin</span>(<span class="string">&quot;consonant&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="搜索和替换"><a href="#搜索和替换" class="headerlink" title="搜索和替换"></a>搜索和替换</h2><p>我们需要写一个字符串的搜索与替换函数，它的返回值为完成替换后的新字符串。</p><p>这个函数接收的第一个参数为待替换的句子。第二个参数为句中需要被替换的单词。第三个参数为替换后的单词。</p><p><strong>注意：</strong><br>需要保留被替换单词首字母的大小写格式。即如果传入的第二个参数为 “Book”，第三个参数为 “dog”，那么替换后的结果应为 “Dog”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myReplace</span> (str, before, after) &#123;</span><br><span class="line">  <span class="keyword">let</span> regExp = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">`<span class="subst">$&#123;before&#125;</span>`</span>, <span class="string">&#x27;gi&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/[A-Z]/</span>.<span class="title function_">test</span>(str.<span class="title function_">match</span>(regExp)[<span class="number">0</span>].<span class="title function_">charAt</span>(<span class="number">0</span>)) ?</span><br><span class="line">    str.<span class="title function_">replace</span>(regExp, after.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>() + after.<span class="title function_">slice</span>(<span class="number">1</span>))</span><br><span class="line">    :</span><br><span class="line">    str.<span class="title function_">replace</span>(regExp, after)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myReplace</span>(<span class="string">&#x27;He is Sleeping on the couch&#x27;</span>, <span class="string">&#x27;Sleeping&#x27;</span>, <span class="string">&#x27;sitting&#x27;</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript 泛型</title>
      <link href="/2023/07/24/typescript-generics/"/>
      <url>/2023/07/24/typescript-generics/</url>
      
        <content type="html"><![CDATA[<h2 id="泛型条件类型"><a href="#泛型条件类型" class="headerlink" title="泛型条件类型"></a>泛型条件类型</h2><p>使用三元运算符，类型A需要满足类型B的约束，返回满足条件的类型，即：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> hhh = T <span class="keyword">extends</span> U ? X: Y;</span><br></pre></td></tr></table></figure><p>这里使用<code>extends</code>关键字检查泛型T是否满足泛型U的类型约束，是则返回类型X，否则返回类型Y</p><h3 id="infer关键词"><a href="#infer关键词" class="headerlink" title="infer关键词"></a>infer关键词</h3><p>微软ts官方给出的解释原文/译文为：</p><blockquote><p>Within the <code>extends</code> clause of a conditional type, it is now possible to have <code>infer</code> declarations that introduce a type variable to be inferred. Such inferred type variables may be referenced in the true branch of the conditional type. It is possible to have multiple <code>infer</code> locations for the same type variable.</p></blockquote><blockquote><p><code>infer</code> 关键词常在条件类型中和 <code>extends</code> 关键词一同出现，表示将要推断的类型，作为类型变量可以在三元表达式的 True 部分引用。而 <code>ReturnType</code> 正是使用这种方式提取到了函数的返回类型。</p></blockquote><p><code>Infer</code>关键词主要是推断某个<strong>满足约束</strong>的 泛型变量的类型，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">SomeType</span>&lt;T&gt; = T <span class="keyword">extends</span> (infer U)[] ? <span class="attr">U</span>: T</span><br><span class="line"></span><br><span class="line"><span class="title class_">SomeType</span>&lt;<span class="built_in">string</span>[]&gt; <span class="comment">// string</span></span><br><span class="line"><span class="title class_">SomeType</span>&lt;<span class="built_in">string</span>&gt; <span class="comment">// string</span></span><br></pre></td></tr></table></figure><p><code>U</code>是由传入参数推倒出来的类型：即如果 <code>T</code> 遵循 <code>any[]</code> 这样一个结构，那么<code>U</code>即为传入的数组的item的<code>类型</code></p><p>泛型SomeType的表达式含义为：如果传入的类型符合 <code>any</code>类型的数组 的约束，则返回 <code>any</code> 的类型，否则返回自身的类型<code>any</code></p><p><code>(infer U)[]</code>可以理解为<code>[infer U, infer U,infer U, ...]</code>这样的数组</p><p>infer同样也适合联合类型，例如：对于固定索引值类型的数组</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">SomeType</span>&lt;[<span class="built_in">number</span>, <span class="built_in">string</span>]&gt; <span class="comment">// U = number | string</span></span><br></pre></td></tr></table></figure><p>其实这不是一个很好的例子，需要从需求与设计方面来理解为什么需要infer</p><h3 id="理解infer"><a href="#理解infer" class="headerlink" title="理解infer"></a>理解infer</h3><p>设想一个使用ts编写的函数的需求： 需要一个函数，接受的参数为任何类型的数组，返回该数组的第一项(只能是第一项)</p><p>其实不使用infer，写法也很简单：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getFirstItem&lt;T&gt;(<span class="attr">array</span>: T[]): T &#123;</span><br><span class="line">  <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">GetFirstParamType</span>&lt;T&gt; = T <span class="keyword">extends</span> (...<span class="attr">args</span>: infer R) =&gt; <span class="built_in">any</span> ? R[<span class="number">0</span>] : <span class="built_in">never</span></span><br></pre></td></tr></table></figure><p>但是如果传入的参数是一个对象，假设需要一个函数，返回对象拥有一个<code>onChange</code>的回调函数这个<code>key</code>的返回值，普通<code>type</code>泛型显然做不到，因为T是一个调用时传入的类型整体，不具备在调用时<code>Pick T</code>子类型的能力，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">SubType</span>&lt;T&gt; = &#123; </span><br><span class="line">  <span class="attr">objType</span>: T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">SubType</span>&lt;&#123;<span class="attr">name</span>: <span class="built_in">string</span>&#125;&gt;</span><br></pre></td></tr></table></figure><p><code>T = &#123;name: string&#125;</code>, 即给<code>objType</code> 的类型定义为 <code>&#123;name: string&#125;</code></p><p>但是如果在上方<code>SubType</code>中当我们传入<code>T = &#123;name: string&#125;</code>, <code>objType</code> 需要为<code>&#123;name: string&#125;</code>中<code>name</code>的类型，此时是做不到的，因为泛型是一个不可拆分的整体。</p><p>使用<code>infer</code>，可以解决获取<code>name</code>的类型的问题，上述的对象的<code>onChange</code>的属性的返回值类型也能使用相同的方式获取</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">SubType</span>&lt;T&gt; = T <span class="keyword">extends</span> &#123; <span class="attr">name</span>: infer U &#125; ? <span class="attr">U</span>: T</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">SubType</span>&lt;T&gt; = T <span class="keyword">extends</span> &#123; <span class="attr">onChange</span>: <span class="function">() =&gt;</span> infer U &#125; ? <span class="attr">U</span>: T</span><br></pre></td></tr></table></figure><p><code>Infer</code> 还可以用于元组转 联合类型，意味着可以将类型放在元组（元素可以是不同类型的数组）中，然后将其转换为联合类型 <code>xxx | xxx | xxx</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> typeTuple = [<span class="number">1</span>, <span class="string">&#x27;12&#x27;</span>, [<span class="number">1</span>], <span class="literal">false</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypeTupleToUnion</span>&lt;T&gt; = T <span class="keyword">extends</span> (infer U)[] ? <span class="attr">U</span>: <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> unionTuple = union&lt;<span class="keyword">typeof</span> typeTuple&gt; </span><br><span class="line"><span class="comment">// type unionTuple = string | number | number[] | boolean</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="常用typescript类型应用"><a href="#常用typescript类型应用" class="headerlink" title="常用typescript类型应用"></a>常用typescript类型应用</h2><h3 id="得到返回值类型："><a href="#得到返回值类型：" class="headerlink" title="得到返回值类型："></a>得到返回值类型：</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到函数第一个参数等类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">GetFirstParamType</span>&lt;T&gt; = T <span class="keyword">extends</span> (...<span class="attr">args</span>: infer R) =&gt; <span class="built_in">any</span> ? R[<span class="number">0</span>] : <span class="built_in">never</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到函数的返回值类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">GetFuncReturnType</span>&lt;T&gt; = T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; infer U ? U : <span class="built_in">never</span></span><br></pre></td></tr></table></figure><h3 id="忽略属性："><a href="#忽略属性：" class="headerlink" title="忽略属性："></a>忽略属性：</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Exclude</span>&lt;T, U&gt; = T <span class="keyword">extends</span> U ? <span class="attr">never</span>: T</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">OmitProps</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> <span class="title class_">Exclude</span>&lt;keyof T, K&gt;]: T[P]</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Pick</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Omit</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = <span class="title class_">Pick</span>&lt;T, <span class="title class_">Exclude</span>&lt;keyof T, K&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// extends 执行分配律</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyExclude</span>&lt;T, E&gt; = T <span class="keyword">extends</span> E ? <span class="attr">never</span>: T</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> C = <span class="title class_">MyExclude</span>&lt;<span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span> | <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;c&#x27;</span> | <span class="string">&#x27;d&#x27;</span>&gt;   <span class="comment">// &#x27;a&#x27; | &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C eq D code </span></span><br><span class="line"><span class="keyword">type</span> D = (<span class="string">&#x27;a&#x27;</span> <span class="keyword">extends</span> (<span class="string">&#x27;c&#x27;</span> | <span class="string">&#x27;d&#x27;</span>) ? <span class="built_in">never</span> : <span class="string">&#x27;a&#x27;</span>) | </span><br><span class="line">         (<span class="string">&#x27;b&#x27;</span> <span class="keyword">extends</span> (<span class="string">&#x27;c&#x27;</span> | <span class="string">&#x27;d&#x27;</span>) ? <span class="built_in">never</span> : <span class="string">&#x27;b&#x27;</span>) | </span><br><span class="line">         (<span class="string">&#x27;c&#x27;</span> <span class="keyword">extends</span> (<span class="string">&#x27;c&#x27;</span> | <span class="string">&#x27;d&#x27;</span>) ? <span class="built_in">never</span> : <span class="string">&#x27;c&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyExtract</span>&lt;T, U&gt; = T <span class="keyword">extends</span> U ? <span class="attr">T</span>: <span class="built_in">never</span>;  </span><br></pre></td></tr></table></figure><h3 id="取出Class-构造器中的参数组成元组"><a href="#取出Class-构造器中的参数组成元组" class="headerlink" title="取出Class 构造器中的参数组成元组"></a>取出Class 构造器中的参数组成元组</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyConstructorParameters</span>&lt;T <span class="keyword">extends</span> <span class="keyword">new</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> <span class="keyword">new</span> (...<span class="attr">args</span>: infer U) =&gt; <span class="built_in">any</span> ? U : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span> (<span class="attr">a</span>: <span class="built_in">string</span>, <span class="attr">b</span>: <span class="built_in">number</span>, <span class="attr">c</span>: <span class="built_in">boolean</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> C = <span class="title class_">MyConstructorParameters</span>&lt;<span class="keyword">typeof</span> <span class="title class_">Foo</span>&gt; </span><br><span class="line"><span class="comment">// [a: string, b: number, c: boolean]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;&#125;</span><br><span class="line"><span class="comment">// typeof Foo 等价于 new () =&gt; any</span></span><br></pre></td></tr></table></figure><h3 id="TypeScript-4-1-新特性：模板字符串类型"><a href="#TypeScript-4-1-新特性：模板字符串类型" class="headerlink" title="TypeScript 4.1 新特性：模板字符串类型"></a>TypeScript 4.1 新特性：模板字符串类型</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">EventName</span>&lt;T <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = <span class="string">`<span class="subst">$&#123;T&#125;</span>Changed`</span>;</span><br><span class="line"><span class="comment">// 模板字符串符合排列组合</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T3</span> = <span class="string">`<span class="subst">$&#123;<span class="string">&#x27;top&#x27;</span> | <span class="string">&#x27;bottom&#x27;</span>&#125;</span>-<span class="subst">$&#123;<span class="string">&#x27;left&#x27;</span> | <span class="string">&#x27;right&#x27;</span>&#125;</span>`</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加了4个字符处理的关键字</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Cases</span>&lt;T <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = <span class="string">`<span class="subst">$&#123;uppercase T&#125;</span> <span class="subst">$&#123;lowercase T&#125;</span> <span class="subst">$&#123;capitalize T&#125;</span> <span class="subst">$&#123;uncapitalize T&#125;</span>`</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意⚠️</p><ul><li>字符串模板中的 <code>infer</code> 会一直匹配到字符串的结尾，比如用 <code>$&#123;infer T&#125;x</code> 去匹配 <code>&#39;abcxxx&#39;</code> 会把 <code>T</code> 推断为 <code>&#39;abcxx&#39;</code>。</li></ul><ol start="2"><li>字符串模板中两个 <code>infer</code> 相邻，第一个 <code>infer</code> 只会推断出单个字符，这有助于一些递归操作，比如 <code>$&#123;infer A&#125;$&#123;infer B&#125;</code> 去推断 <code>abcd</code>，<code>A</code> 会推断为 <code>a</code>，而 <code>B</code> 会推断为 <code>bcd</code></li></ol><p>实现元组到联合类型 [x,x,x] =&gt; x | x | x</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TupleToUnion</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [infer U, ...infer R] ? U | <span class="title class_">TupleToUnion</span>&lt;R&gt; : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><h3 id="实现Join"><a href="#实现Join" class="headerlink" title="实现Join"></a>实现Join</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Join</span>&lt;T <span class="keyword">extends</span> (<span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span> | <span class="built_in">bigint</span>)[], D <span class="keyword">extends</span> <span class="built_in">string</span>&gt; =</span><br><span class="line">    T <span class="keyword">extends</span> [] ? <span class="string">&#x27;&#x27;</span> :</span><br><span class="line">    T <span class="keyword">extends</span> [<span class="built_in">unknown</span>] ? <span class="string">`<span class="subst">$&#123;T[<span class="number">0</span>]&#125;</span>`</span> :</span><br><span class="line">    T <span class="keyword">extends</span> [<span class="built_in">unknown</span>, ...infer U] ? <span class="string">`<span class="subst">$&#123;T[<span class="number">0</span>]&#125;</span><span class="subst">$&#123;D&#125;</span><span class="subst">$&#123;Join&lt;U, D&gt;&#125;</span>`</span> : <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T30</span> = <span class="title class_">Join</span>&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="string">&#x27;.&#x27;</span>&gt;;  <span class="comment">// &#x27;1.2.3.4&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T31</span> = <span class="title class_">Join</span>&lt;[<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>], <span class="string">&#x27;-&#x27;</span>&gt;;  <span class="comment">// &#x27;foo-bar-baz&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="判断是否空类型"><a href="#判断是否空类型" class="headerlink" title="判断是否空类型"></a>判断是否空类型</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">IsEmptyType</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; ?</span><br><span class="line">  [keyof T] <span class="keyword">extends</span> [<span class="built_in">never</span>] ? <span class="attr">true</span>: <span class="literal">false</span> </span><br><span class="line">  : <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="判断是否为any类型"><a href="#判断是否为any类型" class="headerlink" title="判断是否为any类型"></a>判断是否为any类型</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">IsAny</span>&lt;T&gt; = <span class="number">0</span> <span class="keyword">extends</span> <span class="number">1</span> &amp; T ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="数字字符串转换为number-利用模板字符串判断0值"><a href="#数字字符串转换为number-利用模板字符串判断0值" class="headerlink" title="数字字符串转换为number   利用模板字符串判断0值"></a>数字字符串转换为number   利用模板字符串判断0值</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ToNumber</span>&lt;T <span class="keyword">extends</span> <span class="built_in">string</span>, N <span class="keyword">extends</span> <span class="built_in">number</span>[] = []&gt; = <span class="string">`<span class="subst">$&#123;N[<span class="string">&#x27;length&#x27;</span>]&#125;</span>`</span> <span class="keyword">extends</span> T ? N[<span class="string">&#x27;length&#x27;</span>] : <span class="title class_">ToNumber</span>&lt;T, [<span class="number">1</span>, ...N]&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> TypeScript </tag>
            
            <tag> 基础概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>W3C代码标准规范是什么，那有些规定</title>
      <link href="/2023/07/24/w3c/"/>
      <url>/2023/07/24/w3c/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-W3C？"><a href="#什么是-W3C？" class="headerlink" title="什么是 W3C？"></a>什么是 W3C？</h2><ul><li>W3C 指万维网联盟（<em>World Wide Web Consortium</em>）</li><li>W3C 创建于<em>1994年10月</em></li><li>W3C 由 <em>Tim Berners-Lee</em> 创建</li><li>W3C 是一个<em>会员组织</em></li><li>W3C 的工作是<em>对 web 进行标准化</em></li><li>W3C 创建并维护 <em>WWW 标准</em></li><li>W3C 标准被称为 <em>W3C 推荐（W3C 规范）</em></li></ul><blockquote><p>W3C 最重要的工作是发展 Web 规范</p></blockquote><h2 id="为什么要设计规范？"><a href="#为什么要设计规范？" class="headerlink" title="为什么要设计规范？"></a>为什么要设计规范？</h2><p>主要解决残障人士方便的获得Web内容相关的技术问题并形成解决方案，包括Web信息无障碍的基本原则、实现技术、评估方法等。</p><h2 id="为什么要遵循标准？"><a href="#为什么要遵循标准？" class="headerlink" title="为什么要遵循标准？"></a>为什么要遵循标准？</h2><p>作为生产者实际上只是位于中游，既不是上游的浏览器制造商，他们是标准的真正制定者，也不算是下游，他们是浏览器的终端使用者。这个角色就意味着我们位于一个接口的位置，我们需要想办法满足下游的用户使用上游不同浏览器时看到的是同样的内容。</p><p>我们想方设法让我们的页面、我们的程序能够支持所有的浏览器、能够满足尽可能多的用户。我们要满足所有的客户，即使做不到，我们也要满足我们技术范围之内的所有用户。</p><h2 id="遵循标准的目的"><a href="#遵循标准的目的" class="headerlink" title="遵循标准的目的"></a>遵循标准的目的</h2><p>制作一个标准的网站，让使用者感觉不到跟标准有关</p><h2 id="W3C代码标准规范内容"><a href="#W3C代码标准规范内容" class="headerlink" title="W3C代码标准规范内容"></a>W3C代码标准规范内容</h2><h3 id="废弃-lt-font-gt-标签"><a href="#废弃-lt-font-gt-标签" class="headerlink" title="废弃&lt;font&gt;标签"></a>废弃<code>&lt;font&gt;</code>标签</h3><p>抛弃font标签，新的页面中不应该再出现如<code>&lt;font color=&quot;red&quot;&gt;&lt;/font&gt;</code>，而是使用<code>span</code>进行替代：<code>&lt;span class=&quot;red&quot;&gt;&lt;/span&gt;</code></p><h3 id="文档声明"><a href="#文档声明" class="headerlink" title="文档声明"></a>文档声明</h3><p>一个标准XHTML头信息格式，可以利于搜索引擎优化（SEO）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span> <span class="attr">lang</span>=<span class="string">&quot;gb2312&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>W3Cschool - 学技术查资料，从w3cschool开始!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge,chrome=1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;renderer&quot;</span> <span class="attr">content</span>=<span class="string">&quot;webkit&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;关键字，以逗号分隔&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;网页描述文字&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>DOCTYPE</strong></p><p>浏览器需要解析文档头部的DOCTYPE来解释页面的标识，并展现出来，所以DOCTYPE是建立符合标准的XHTML网页的必不可少的部分，没有DOCTYPE的XHTML的任何标识都不会生效</p><p>DOCTYPE分为三种类型：</p><ol><li><p>过渡模式Transitional：允许你继续使用HTML4.01的标识</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>严格模式Strict：不能使用任何表现层的标识和属性，例如<code>&lt;br&gt;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>框架模式Frameset：专门针对框架页面设计</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="定义语言编码"><a href="#定义语言编码" class="headerlink" title="定义语言编码"></a>定义语言编码</h3><p>为了被浏览器正确解释和通过W3C代码校验，所有的XHTML文档都必须声明它们所使用的编码语言，我们一般使用UTF-8</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="JavaScript定义"><a href="#JavaScript定义" class="headerlink" title="JavaScript定义"></a>JavaScript定义</h3><p>JavaScript必须要用<code>&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;</code>来定义，并且需要加个注释符<code>//&lt;![CDATA[ ... //]]&gt;  </code>，以保证不在不支持js的浏览器上直接显示出代码来。 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&quot;javascript&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-handlebars"><span class="language-xml"> </span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">//&lt;![CDATA[ </span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">var a = 1</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">//]]&gt; </span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br></pre></td></tr></table></figure><h3 id="CSS定义"><a href="#CSS定义" class="headerlink" title="CSS定义"></a>CSS定义</h3><p>CSS标签必须要用<code>&lt;style type=&quot;text/css&quot;&gt;</code>来定义，与js相同，最好加入html注释，且所有数值单位最好带上对应单位，以保证兼容性，</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen&quot;</span>&gt;</span><span class="language-xml"> </span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!-- </span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    body &#123;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">        margin:0px;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">        padding:0px;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">        text-align:center</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    &#125; </span></span></span><br><span class="line"><span class="comment"><span class="language-xml">--&gt;</span> </span></span><br><span class="line"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p> 不要在注释内容中使用 –</p></blockquote><h3 id="所有标签的元素和属性的名字都必须使用小写"><a href="#所有标签的元素和属性的名字都必须使用小写" class="headerlink" title="所有标签的元素和属性的名字都必须使用小写"></a>所有标签的元素和属性的名字都必须使用小写</h3><p>XHTML对大小写敏感，例如<code>&lt;title&gt;</code>和<code>&lt;TITLE&gt;</code>是不同的标签，XHTML要求所有的标签和属性的名字都必须使用小写</p><h3 id="所有的属性必须用引号-quot-quot-括起来"><a href="#所有的属性必须用引号-quot-quot-括起来" class="headerlink" title="所有的属性必须用引号&quot; &quot;括起来"></a>所有的属性必须用引号<code>&quot; &quot;</code>括起来</h3><p>例如：<code>&lt;div height=80&gt;&lt;/div&gt;</code>必须修改为：<code>&lt;div height=&quot;80&quot;&gt;&lt;/div&gt;</code>,单引号可以使用<code>&amp;apos</code>代替</p><h3 id="把所有-lt-和-amp-特殊符号用编码表示"><a href="#把所有-lt-和-amp-特殊符号用编码表示" class="headerlink" title="把所有&lt;和&amp;特殊符号用编码表示"></a>把所有&lt;和&amp;特殊符号用编码表示</h3><p>任何小于号 <code>&lt;</code>，不是标签的一部分，都必须被编码为 <code>&amp;lt;</code><br>任何大于号<code>&gt;</code>，不是标签的一部分，都必须被编码为 <code>&amp;gt;</code><br>任何与号<code>&amp;</code>，不是实体的一部分的，都必须被编码为 <code>&amp;amp;</code> </p><h3 id="标签所有属性必须赋一个值"><a href="#标签所有属性必须赋一个值" class="headerlink" title="标签所有属性必须赋一个值"></a>标签所有属性必须赋一个值</h3><p>XHTML规定所有属性都必须有一个值，没有值的就重复本身</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">nowrap</span>=<span class="string">&quot;nowrap&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;shirt&quot;</span> <span class="attr">value</span>=<span class="string">&quot;medium&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="所有的标记都必须要有一个相应的结束标记"><a href="#所有的标记都必须要有一个相应的结束标记" class="headerlink" title="所有的标记都必须要有一个相应的结束标记"></a><strong>所有的标记都必须要有一个相应的结束标记</strong></h3><p>在HTML中，有些标签可以不用闭合，例如<code>&lt;p&gt;</code>和<code>&lt;li&gt;</code>而不一定写对应的<code>&lt;/p&gt;</code>和<code>&lt;/li&gt;</code>来关闭，但在XHML中这种操作不合法，所有标签必须关闭</p><h3 id="所有的标记都必须合理嵌套"><a href="#所有的标记都必须合理嵌套" class="headerlink" title="所有的标记都必须合理嵌套"></a>所有的标记都必须合理嵌套</h3><p>例如<code> &lt;li&gt;&lt;/li&gt;</code>只能出现在<code>&lt;ol&gt;</code> 或者<code>&lt;ul&gt;</code>中，在行内元素标签中不能嵌套块元素标签</p><h3 id="链接与图片添加有意义的属性"><a href="#链接与图片添加有意义的属性" class="headerlink" title="链接与图片添加有意义的属性"></a>链接与图片添加有意义的属性</h3><p>所有的<code>&lt;a&gt;</code>标签需要添加<code>title</code>来帮助显示不完整的信息</p><p>所有<code>&lt;img/&gt;</code> 标签需要添加<code>alt</code>属性来描述图片信息</p><h3 id="在form表单中增加lable，以增加用户友好度"><a href="#在form表单中增加lable，以增加用户友好度" class="headerlink" title="在form表单中增加lable，以增加用户友好度"></a>在form表单中增加<code>lable</code>，以增加用户友好度</h3><p><code>&lt;lable&gt;</code>标签的好处就是，当在点击时，自动聚焦到对应的表单输入框内</p><blockquote><p>更多W3C规范信息，请参见 <a href="https://www.w3.org/Consortium/">W3C英文官网</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> W3C规范 </tag>
            
            <tag> XHTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack 4 打包入门</title>
      <link href="/2023/07/24/webpack/"/>
      <url>/2023/07/24/webpack/</url>
      
        <content type="html"><![CDATA[<blockquote><p>webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用npm全局安装</p><blockquote><p>npm install webpack webpack-cli webpack-dev-server -g</p></blockquote><p>进入项目根目录进行局部安装</p><blockquote><p>npm install webpack webpack-cli webpack-dev-server </p></blockquote><h2 id="入口-entry"><a href="#入口-entry" class="headerlink" title="入口(entry)"></a>入口(entry)</h2><p>入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。</p><p>我们在开发环境下的项目根目录中创建<code>webpack.dev.js</code>，对webpack进行出口配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./config/webpack.dev.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    entry : <span class="string">&#x27;main.js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用数组包含多个入口文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">entry</span>: &#123;</span><br><span class="line">        <span class="attr">main</span>: [<span class="string">&#x27;./src/main.js&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>每个依赖项随即被处理，最后输出到output设置的指定的 的文件中</p><h2 id="打包环境"><a href="#打包环境" class="headerlink" title="打包环境"></a>打包环境</h2><p>与webpack3 不同，在<code>webpack.dev.js</code>中新增了一个<code>mode</code>的选项，即选择打包的模式，development（开发环境）production（生产环境），两者的区别很简单，生产环境会对代码进行压缩，即去除所有代码缩进</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">entry</span>: &#123;</span><br><span class="line">        <span class="attr">main</span>: [<span class="string">&#x27;./src/main.js&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="出口-output"><a href="#出口-output" class="headerlink" title="出口(output)"></a>出口(output)</h2><p>出口是指示将零散的模块汇入到哪一个文件中，出口中设置的文件将包含所有需要的依赖，这里我们使用node的path模块来解析目录</p><p><code>filename</code>：指定最终打包生成的js文件名，可以使用[name]获取入口js的文件名</p><p><code>path</code>：指定输出的目录</p><p><code>publicPath</code>：指定静态资源的根路径，意味着有时候静态资源需要从外部加载，那么要将<code>publicPath</code>指定为一个外部域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">entry</span>: &#123;</span><br><span class="line">        <span class="attr">main</span>: [<span class="string">&#x27;./src/main.js&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span> ，</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;[name]-bundle.js&#x27;</span>, <span class="comment">// 使用</span></span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../dist&#x27;</span>), </span><br><span class="line">        <span class="attr">publicPath</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="开发环境调试服务器"><a href="#开发环境调试服务器" class="headerlink" title="开发环境调试服务器"></a>开发环境调试服务器</h2><p>在开发环境中使用webpack并进行调试，并期望进行即时打包与错误提示，那么我们可以使用一下选项</p><p><code>contentBase</code>: 指定服务器读取文件的根目录<br><code>overlay</code>: 布尔值，开启错误提示<br><code>port</code>: 自定义端口号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">entry</span>: &#123;</span><br><span class="line">        <span class="attr">main</span>: [<span class="string">&#x27;./src/main.js&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span> ，</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;[name]-bundle.js&#x27;</span>, <span class="comment">// 使用</span></span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../dist&#x27;</span>), </span><br><span class="line">        <span class="attr">publicPath</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">contentBase</span>: <span class="string">&#x27;dist&#x27;</span>,</span><br><span class="line">        <span class="attr">overlay</span>: <span class="literal">true</span>, <span class="comment">// 为错误显示提示信息</span></span><br><span class="line">        <span class="attr">port</span>: <span class="number">9000</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打包静态资源"><a href="#打包静态资源" class="headerlink" title="打包静态资源"></a>打包静态资源</h2><p>webpack需要使用几个额外的模块来对css，图片，html文件进行打包处理</p><p>需要执行一下命令，执行局部安装</p><blockquote><p>npm install style-loader css-loader file-loader extract-loader html-loader</p></blockquote><p>style-loader：负责将打包后生成的css模块以<code>&lt;style&gt;</code>标签的形式插入到html中</p><p>css-loader：负责打包所有css样式</p><p>file-loader：负责找到所需文件资源，并返回其public中的URL</p><p>extract-loader ：它的主要用例是解决来自各自装载器的 HTML 和 CSS 内的 URL</p><p>html-loader：将 HTML 导出为字符串。当编译器要求时，HTML 被最小化（去除缩进）</p><p>我们需要在<code>./config/webpack.dev.js</code>中继续添加一个module选项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">entry</span>: &#123;</span><br><span class="line">        <span class="attr">main</span>: [<span class="string">&#x27;./src/main.js&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span> ，</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;[name]-bundle.js&#x27;</span>, <span class="comment">// 使用</span></span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../dist&#x27;</span>), </span><br><span class="line">        <span class="attr">publicPath</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">contentBase</span>: <span class="string">&#x27;dist&#x27;</span>,</span><br><span class="line">        <span class="attr">overlay</span>: <span class="literal">true</span>, <span class="comment">// 为错误显示提示信息</span></span><br><span class="line">        <span class="attr">port</span>: <span class="number">9000</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [&#123;</span><br><span class="line">                <span class="comment">// css-loaders,找到所有的css文件</span></span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                <span class="comment">// 对上面匹配到的文件使用一下模块进行打包</span></span><br><span class="line">                <span class="attr">use</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">loader</span>: <span class="string">&#x27;style-loader&#x27;</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">loader</span>: <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.html$/</span>,</span><br><span class="line">                <span class="comment">// 对上面匹配到的文件使用一下模块进行打包</span></span><br><span class="line">                <span class="attr">use</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">loader</span>: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">                        <span class="attr">options</span>: &#123;</span><br><span class="line">                            <span class="attr">name</span>: <span class="string">&#x27;[name].html&#x27;</span> <span class="comment">// 指定打包后的html文件名称，这里设置[name]就是打包之前html的名称</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123; <span class="comment">// 将html和js文件分开打包</span></span><br><span class="line">                        <span class="attr">loader</span>: <span class="string">&#x27;extract-loader&#x27;</span>,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">loader</span>: <span class="string">&#x27;html-loader&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 配置图片资源加载器image-loader</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.(jpg|git|png)/</span>,</span><br><span class="line">                </span><br><span class="line">                <span class="attr">use</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">loader</span>: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">                        <span class="comment">// 对上面匹配到的文件使用一下模块进行打包</span></span><br><span class="line">                        <span class="attr">options</span>: &#123;</span><br><span class="line">                            <span class="attr">name</span>: <span class="string">&#x27;images/[name]-[hash:8].[ext]&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ES语法兼容"><a href="#ES语法兼容" class="headerlink" title="ES语法兼容"></a>ES语法兼容</h2><p>我们知道ES6相对于ES5新增了一些语法方面的内容，这可能导致使用ES6编写的js文件在某些不支持ES6的浏览器上无法被正常执行，所以Babel就出现了，他是一个将ES6语法转换为ES5的js模块</p><p>Babel的使用方法具体可参考官方文档，在这里我们要在webpack中将打包的js文件转换为ES5的版本</p><p>首先是安装Babel核心模块，安装第七版本的babel-loader与webpack中打包使用</p><blockquote><p>npm install babel-core babel-loader@7</p></blockquote><p>安装 babel 的插件</p><blockquote><p>npm install babel-plugin-transform-es2015-arrow-functions</p></blockquote><p>安装完毕后，需要在项目根目录下新建一个文件 <code>.babelrc</code>，来配置Babel中使用的插件，内容为JSON格式</p><p>这里先配置了一个箭头函数的转换</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;transform-es2015-arrow-functions&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>然后在<code>./config/webpack.dev.js</code>的module中的rule内添加一个loader即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./config/webpack.dev.js</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 选择所有js文件进行</span></span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    <span class="attr">use</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>安装async函数语法转换插件，将async转换为<strong>使用promsie的普通函数</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;transform-es2015-arrow-functions&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;async-to-promises&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><code>Babel</code>默认只会转译语法，比如箭头函数，但是不会转换一些新增的对象方法，例如<code>Object.assign()</code>和<code>Array.prototype.includes()</code>此时，使用额外的三个Babel衍生模块就能更好的处理ECMAScript新增内容</p><p><code>babel-polyfill</code>：常规的babel打包是将打包后的js出口文件进行语法的转换，而<code>babel-polyfill</code>将语法转换提前到打包之前</p><p><code>babel-preset</code>：一个将常用的babel插件集合，也就是说，使用preset会自动配置一些常用的babel插件</p><p><code>babel-transform</code>：<code>babel-polyfill</code>会将Promise等添加成全局变量，污染全局空间，而<code>babel-transform</code>可以解决这个问题</p><p>安装<code>babel-polyfill</code> ：</p><blockquote><p>npm install babel-polyfill  </p></blockquote><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改./config/webpack.dev.js</span></span><br><span class="line"><span class="attr">entry</span>: &#123;</span><br><span class="line">        <span class="attr">main</span>: [<span class="string">&#x27;babel-polyfill&#x27;</span>, <span class="string">&#x27;./src/main.js&#x27;</span>]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>安装<code>babel-preset</code>：</p><blockquote><p>npm install babel-preset</p></blockquote><p>使用：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;presets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;env&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;debug&quot;</span><span class="punctuation">:</span><span class="keyword">true</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;transform-runtime&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> webpack </tag>
            
            <tag> 前端兼容性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 模块化规范对比</title>
      <link href="/2023/07/24/javascript_modul/"/>
      <url>/2023/07/24/javascript_modul/</url>
      
        <content type="html"><![CDATA[<h1 id="模块化的好处"><a href="#模块化的好处" class="headerlink" title="模块化的好处"></a>模块化的好处</h1><ul><li>避免变量命名冲突</li><li>更好的分离</li><li>更高的维护性</li><li>高可维护性</li></ul><h1 id="模块化模式"><a href="#模块化模式" class="headerlink" title="模块化模式"></a>模块化模式</h1><p>全局模式：直接在js模块文件中声明变量    外界能够随意修改其值，不安全<br>命名空间模式：在js模块文件中均为封装的对象  外界能够随意修改其值，不安全<br>IIFE匿名函数自调用模式(闭包)：js模块文件中使用一个立即执行函数进行包装，在内部暴露相应函数，立即执行的函数参数可以为window </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"><span class="variable language_">window</span></span>)&#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">model1</span> = &#123;foo&#125;; <span class="comment">// 将函数以对象形式传入到window对象的属性中，等价于&#123;foo：foo&#125;</span></span><br><span class="line">&#125;)(<span class="variable language_">window</span>)</span><br></pre></td></tr></table></figure><p>IIFE增强模式：在IIFE基础上 在立即函数的参数中加入代码依赖，例如使用jQuery</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"><span class="variable language_">window</span>,$</span>)&#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">changeBg</span>(<span class="params"></span>)&#123;</span><br><span class="line">        $(<span class="string">&#x27;body&#x27;</span>).<span class="title function_">css</span>(&#123;</span><br><span class="line">            background : <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">            <span class="comment">//.....</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">model1</span> = &#123;changeBg&#125;; <span class="comment">// 将函数以对象形式传入到window对象的属性中，等价于&#123;foo：foo&#125;</span></span><br><span class="line">&#125;)(<span class="variable language_">window</span>,jQuery)</span><br></pre></td></tr></table></figure><h2 id="原生JS进行模块化"><a href="#原生JS进行模块化" class="headerlink" title="原生JS进行模块化"></a>原生JS进行模块化</h2><p>使用原生的JS，以匿名函数自调用模式(闭包)的形式进行模块化，实参括号内的参数均为window对象内部属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module1.js ，没有任何依赖的模块</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"><span class="variable language_">window</span></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> msg = <span class="string">&#x27;this is a message!&#x27;</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">getMessage</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用window将getMessage进行暴露</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">message</span> = &#123;getMessage&#125;</span><br><span class="line">&#125;)(<span class="variable language_">window</span>)</span><br><span class="line"><span class="comment">//module2.js，依赖于获取数据的module1.js</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"><span class="variable language_">window</span>,message</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> msg = <span class="string">&#x27;this is a message!&#x27;</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">logMessage</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">getMessage</span>())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">showMessage</span> = &#123; logMessage &#125;</span><br><span class="line">&#125;)(<span class="variable language_">window</span>, message)</span><br><span class="line"><span class="comment">//主模块msg.js，将使用module2.js和module1.js,不需要使用window来暴露模块</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params">showMessage</span>)&#123;</span><br><span class="line">    showMessage.<span class="title function_">logMessage</span>();</span><br><span class="line">&#125;)(showMessage)</span><br></pre></td></tr></table></figure><p>原生JS的模块引用必须严格遵守模块的引用顺序</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./modules/module1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./modules/module2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;src/js/msg.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h1><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p>NodeJS使用此语法规范，不存在顶级对象window</p><h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><p>每一个文件都可以当做一个模块<br>服务器(NodeJS)端的模块都是运行时同步加载的<br>浏览器端的模块需要提交打包处理  </p><h4 id="暴露模块"><a href="#暴露模块" class="headerlink" title="暴露模块"></a>暴露模块</h4><p>暴露模块本质是吧所有对象的引用保存在exports对象中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = value</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">fun1</span> = fun1</span><br></pre></td></tr></table></figure><h4 id="引入并模块"><a href="#引入并模块" class="headerlink" title="引入并模块"></a>引入并模块</h4><p>第三方模块直接传入模块名，自定义则传入相对路径，注意，CommandJs中，需要等待require加载完模块后，才能往后执行代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable language_">module</span> = <span class="built_in">require</span>(相对路径/模块名);</span><br><span class="line"><span class="variable language_">module</span>.<span class="title function_">fun1</span>();</span><br></pre></td></tr></table></figure><h2 id="AMD-规范"><a href="#AMD-规范" class="headerlink" title="AMD 规范"></a>AMD 规范</h2><p>全名为 异步模块定义 </p><h3 id="规范-1"><a href="#规范-1" class="headerlink" title="规范"></a>规范</h3><p>专用于浏览器端，模块的加载是异步的</p><h4 id="定义暴露模块"><a href="#定义暴露模块" class="headerlink" title="定义暴露模块"></a>定义暴露模块</h4><p>定义不存在依赖关系的模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">defind</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> 模块</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>定义有依赖的模块,传入依赖模块名数组、回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入依赖模块名，将依赖的模块注入到回调函数参数中</span></span><br><span class="line"><span class="title function_">defind</span>([<span class="string">&#x27;module1&#x27;</span>,<span class="string">&#x27;module2&#x27;</span>], <span class="keyword">function</span>(<span class="params">module1, module2</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> 模块</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="引入模块"><a href="#引入模块" class="headerlink" title="引入模块"></a>引入模块</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;module1&#x27;</span>, <span class="string">&#x27;module2&#x27;</span>], <span class="keyword">function</span>(<span class="params">module1, module2</span>)&#123;</span><br><span class="line">    <span class="comment">//通过参数使用模块 </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="AMD规范引入模块实例-需要在lib文件夹下引入Require-js"><a href="#AMD规范引入模块实例-需要在lib文件夹下引入Require-js" class="headerlink" title="AMD规范引入模块实例(需要在lib文件夹下引入Require.js)"></a>AMD规范引入模块实例(需要在lib文件夹下引入Require.js)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义无依赖的模块 module1.js</span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> msg = <span class="string">&#x27;this is a message&#x27;</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">getMessage</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 暴露一个对象，内容为一个函数</span></span><br><span class="line">    <span class="keyword">return</span> &#123;getMessage&#125; </span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 定义依赖于module1.js 的 module2.js</span></span><br><span class="line"><span class="title function_">define</span>(<span class="string">&#x27;module1&#x27;</span>, <span class="keyword">function</span>(<span class="params">module1</span>)&#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">showMessage</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(module1.<span class="title function_">getMessage</span>())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;showMessage&#125;;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//  定义主模块，引用2个子模块</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    requirejs([<span class="string">&#x27;module1&#x27;</span>, <span class="string">&#x27;module2&#x27;</span>], <span class="keyword">function</span>(<span class="params">module1, module2 </span>)&#123;</span><br><span class="line">        module2.<span class="title function_">showMessage</span>();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h2 id="ES6规范"><a href="#ES6规范" class="headerlink" title="ES6规范"></a>ES6规范</h2><h3 id="规范-2"><a href="#规范-2" class="headerlink" title="规范"></a>规范</h3><p>ES6的依赖模块需要编译打包处理，常使用webpack进行打包</p><h4 id="暴露模块-1"><a href="#暴露模块-1" class="headerlink" title="暴露模块"></a>暴露模块</h4><p>均为暴露一个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">fun1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">fun2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//... </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者统一暴露</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun1</span>(<span class="params"></span>)&#123;<span class="comment">//...&#125;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun2</span>(<span class="params"></span>)&#123;<span class="comment">//...&#125;</span></span><br><span class="line"><span class="keyword">export</span> &#123;fun1,fun2, ...&#125;</span><br><span class="line"><span class="comment">//默认暴露</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">//默认暴露一个箭头函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params"></span>)  &#123;</span><br><span class="line">    <span class="comment">//默认暴露普通函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="引入模块-1"><a href="#引入模块-1" class="headerlink" title="引入模块"></a>引入模块</h4><p>引入一般暴露的模块均使用对象形式解构赋值<br>引入默认暴露的模块可自定义引用名 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;fun1&#125; <span class="keyword">from</span> <span class="string">&#x27;模块js相对路径&#x27;</span></span><br><span class="line"><span class="keyword">import</span> arrowFunc <span class="keyword">from</span> <span class="string">&#x27;默认暴露模块js相对路径&#x27;</span></span><br><span class="line"><span class="title function_">fun1</span>()</span><br><span class="line"><span class="title function_">arrowFunc</span>()</span><br></pre></td></tr></table></figure><p>注意在HTML中引入的时候，需要将脚本标签类型设定为module</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./src/js/msg.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="编辑器相关"><a href="#编辑器相关" class="headerlink" title="编辑器相关"></a>编辑器相关</h2><p>写入@ 注释以给编译器加上参数提示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绿茶准备过程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125; 一杯绿茶</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">prepareGreenTea</span> = (<span class="params"></span>) =&gt; <span class="string">&#x27;greenTea&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 备红茶准备过程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125; 一杯红茶</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">prepareBlackTea</span> = (<span class="params"></span>) =&gt; <span class="string">&#x27;blackTea&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获得一定数量的茶</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">function():string</span>&#125; prepareTea 茶的类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; numOfCups 需要茶的数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Array&lt;string&gt;</span>&#125; 给定的茶</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getTea</span> = (<span class="params">prepareTea, numOfCups</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> teaCups = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> cups = <span class="number">1</span>; cups &lt;= numOfCups; cups += <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> teaCup = <span class="title function_">prepareTea</span>();</span><br><span class="line">    teaCups.<span class="title function_">push</span>(teaCup);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> teaCups;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> JavaScript模块 </tag>
            
            <tag> 模块化规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript数据结构与算法</title>
      <link href="/2023/07/24/javascript_algorithms/"/>
      <url>/2023/07/24/javascript_algorithms/</url>
      
        <content type="html"><![CDATA[<blockquote><p>数据结构与算法是每一个计算机编程学者的必备知识，在日常生活中，算法无处不在，本文将使用JavaScript实现一些常用的数据结构与算法，例如二叉树的创建以及删除等，以及一些算法的实际应用</p></blockquote><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ul><li><p>使用队列实现约瑟夫环</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Queue</span> (size) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">items</span> = []</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">index</span> = <span class="number">0</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">maxSize</span> = size</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Queue</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">constructor</span>: <span class="title class_">Queue</span>,</span><br><span class="line">  enter (item) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">index</span> &lt; <span class="variable language_">this</span>.<span class="property">maxSize</span>) &#123;</span><br><span class="line">      item !== <span class="string">&#x27;&#x27;</span> ? <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">index</span>++] = item : <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据不能为空&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前队列已满&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  shift () &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">index</span>--</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">shift</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前队列为空&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  peek () &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="number">0</span>]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;栈当前为空&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  isEmpty () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">index</span> === <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  size () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">index</span></span><br><span class="line">  &#125;,</span><br><span class="line">  clear () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">index</span> = <span class="number">0</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span> = []</span><br><span class="line">  &#125;,</span><br><span class="line">  toString () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`head-&gt;| <span class="subst">$&#123;<span class="variable language_">this</span>.items.map(item =&gt; item)&#125;</span> |&lt;-tail`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">josephRing</span> (arr,num) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">let</span> queue = <span class="keyword">new</span> <span class="title class_">Queue</span>(arr.<span class="property">length</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    queue.<span class="title function_">enter</span>(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;arr.<span class="property">length</span>-<span class="number">1</span> ; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;num -<span class="number">1</span> ; j++) &#123;</span><br><span class="line">      queue.<span class="title function_">enter</span>(queue.<span class="title function_">shift</span>())</span><br><span class="line">    &#125;</span><br><span class="line">    res = queue.<span class="title function_">shift</span>()</span><br><span class="line">    <span class="comment">//console.log(res)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> queue.<span class="title function_">peek</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">josephRing</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],<span class="number">2</span>))</span><br></pre></td></tr></table></figure></li><li><p>使用插入排序实现优先级队列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">priorityQueue</span> (size) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">QueueElement</span> (value, priority) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">priority</span> = priority</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">items</span> = []</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">index</span> = <span class="number">0</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">maxSize</span> = size</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">enter</span> = <span class="keyword">function</span> (<span class="params">value, priority</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">index</span> &lt; <span class="variable language_">this</span>.<span class="property">maxSize</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> element = <span class="keyword">new</span> <span class="title class_">QueueElement</span>(value, priority)</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">push</span>(element)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 经典插入排序</span></span><br><span class="line">        <span class="keyword">let</span> flag = <span class="literal">false</span><span class="comment">// 扫描标志位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="title function_">size</span>(); i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">items</span>[i].<span class="property">priority</span> &gt; element.<span class="property">priority</span>) &#123; <span class="comment">//检测到有元素的优先级比新元素优先级大</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">splice</span>(i, <span class="number">0</span>, element) <span class="comment">// 在当前位置插入</span></span><br><span class="line">            flag = <span class="literal">true</span> <span class="comment">// 标识已经插入</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123; <span class="comment">// 如果队列中所有的元素优先级都比新元素小</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">push</span>(element) <span class="comment">// 放置在队列最后</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">index</span>++ <span class="comment">// 增加index</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前队列已满&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">priorityQueue.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Queue</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// 继承普通队列的一些方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pQueue = <span class="keyword">new</span> <span class="title function_">priorityQueue</span>(<span class="number">10</span>)</span><br><span class="line">pQueue.<span class="title function_">enter</span>(<span class="string">&#x27;Apple&#x27;</span>, <span class="number">10</span>)</span><br><span class="line">pQueue.<span class="title function_">enter</span>(<span class="string">&#x27;sbb&#x27;</span>, <span class="number">30</span>)</span><br><span class="line">pQueue.<span class="title function_">enter</span>(<span class="string">&#x27;xiaomi&#x27;</span>,<span class="number">20</span>)</span><br><span class="line">pQueue.<span class="title function_">enter</span>(<span class="string">&#x27;lenovo&#x27;</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pQueue)</span><br></pre></td></tr></table></figure></li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合通常是一组无序，不能重复的元素构成，常见的实现方式为哈希表</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Set</span> () &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">items</span> = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Set</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">add</span>: <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="title function_">has</span>(value)) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">items</span>[value] = value</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">has</span>: <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">hasOwnProperty</span>(value)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">remove</span>: <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">has</span>(value)) &#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">items</span>[value]</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getValues</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>.<span class="property">items</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">isSet</span>:<span class="keyword">function</span> (<span class="params">set</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> set <span class="keyword">instanceof</span> <span class="title class_">Set</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">size</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>.<span class="property">items</span>).<span class="property">length</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">clear</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span> = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Set</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Set</span></span><br></pre></td></tr></table></figure><p>集合间操作：</p><ul><li><p>并集</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">union</span>: <span class="keyword">function</span> (<span class="params">set</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!set <span class="keyword">instanceof</span> <span class="title class_">Set</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> unionSet = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">  <span class="keyword">let</span> values = <span class="variable language_">this</span>.<span class="title function_">getValues</span>()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    unionSet.<span class="title function_">add</span>(values[i])</span><br><span class="line">  &#125;</span><br><span class="line">  values = set.<span class="title function_">getValues</span>()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    unionSet.<span class="title function_">add</span>(values[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> unionSet</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>交集</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">intersection</span>:<span class="keyword">function</span>(<span class="params">set</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="title function_">isSet</span>(set)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> intersectionSet = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">    <span class="keyword">let</span> values = <span class="variable language_">this</span>.<span class="title function_">getValues</span>()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (set.<span class="title function_">has</span>(values[i]))&#123;</span><br><span class="line">        intersectionSet.<span class="title function_">add</span>(values[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intersectionSet</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li><li><p>差集</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">difference</span>:<span class="keyword">function</span>(<span class="params">set</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="title function_">isSet</span>(set)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> differenceSet = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">    <span class="keyword">let</span> values = <span class="variable language_">this</span>.<span class="title function_">getValues</span>()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      differenceSet.<span class="title function_">add</span>(values[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    values = set.<span class="title function_">getValues</span>()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (differenceSet.<span class="title function_">has</span>(values[i]))&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(values[i])</span><br><span class="line">        <span class="keyword">delete</span> differenceSet.<span class="title function_">remove</span>([values[i]])</span><br><span class="line">      &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        differenceSet.<span class="title function_">add</span>(values[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> differenceSet</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li><li><p>子集</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">isChild</span>:<span class="keyword">function</span> (<span class="params">set</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="title function_">isSet</span>(set)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> values = set.<span class="title function_">getValues</span>()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="title function_">has</span>(values[i]))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li></ul><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><ul><li><p>哈希表通常基于数组实现</p></li><li><p>优点：</p><ul><li>可以提供非常快的插入删除查找 操作</li><li>无论数据规模大小，插入和删除的时间复杂度接近常量O(1)，实际为通过计算得出</li><li>一般情况下性能比树结构快，且编码容易</li></ul></li><li><p>缺点：</p><ul><li>数据无序，且不能通过固定方式顺序遍历</li><li>key不允许重复</li></ul></li><li><p>空间利用率不高</p><ul><li>查找最大最小值不方便</li></ul></li><li><p>哈希化：将对应数据转换为数字</p></li><li><p>哈希函数：将大数字转换为小数字</p></li><li><p>解决冲突：综合来讲，链地址法的效率比较稳定</p><ul><li>链地址法：结合链表存储冲突元素（推荐）</li><li>开放地址法：寻找表中空白位置进行添加<ul><li>线性探测：<ul><li>以线性的方式向后寻找空白位置，</li><li>在查找时候遇到空白位置即停止</li><li>在删除某个冲突元素的时候，将删除后的位置的值作特殊处理</li><li>可能会产生聚集：多个元素在表中连续吗，导致哈希表性能下降</li></ul></li><li>二次探测<ul><li>在产生冲突后，使用<code>x+n^2</code>为跨度进行空白位置的探测，但探测的步长任然是固定的</li></ul></li><li>再哈希法<ul><li>当产生冲突时，将关键字用另外一个哈希函数再次哈希化</li></ul></li></ul></li></ul></li><li><p>哈希函数的选择：</p><ul><li>霍纳法则</li></ul></li><li><p>哈希表的长度：为了实现尽可能最大的均匀分布，在设置哈希表长度的时候尽量使用质数，以及N次幂的底数</p></li></ul><h3 id="实现一个Hash函数"><a href="#实现一个Hash函数" class="headerlink" title="实现一个Hash函数"></a>实现一个Hash函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 设计一个哈希函数</span></span><br><span class="line"><span class="comment">* 将字符串转换为比较大的数字HashCode</span></span><br><span class="line"><span class="comment">* 然后将Hashcode压缩到数组的范围之内</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hashFunc</span> (str, size) &#123;</span><br><span class="line">  <span class="comment">// 初始化hashCode</span></span><br><span class="line">  <span class="keyword">let</span> hashCode = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 霍纳算法，使用一个质数和Unicode编码迭代计算出该字符串的hashCode</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    hashCode = <span class="number">43</span> * hashCode + str.<span class="title function_">charCodeAt</span>(i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hashCode % size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断一个数是否为质数"><a href="#判断一个数是否为质数" class="headerlink" title="判断一个数是否为质数"></a>判断一个数是否为质数</h3><ul><li><p>普通的判断：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> (<span class="params">num</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>;i&lt;num;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num %i === <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>更高效的判断:<br>如果一个数可以被除了1和本身以外其他数字因式分解，那么他的平方根一定大于等于其因式分解的第一个数，小于等于因式分解的第二个数，如果在平方根到2的范围内不能找到与其整除的数，那么此数就为质数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> (<span class="params">num</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span> ; i&lt;= <span class="built_in">parseInt</span>(<span class="title class_">Math</span>.<span class="title function_">sqrt</span>(num)) ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num %i === <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="二叉搜索树（BST）"><a href="#二叉搜索树（BST）" class="headerlink" title="二叉搜索树（BST）"></a>二叉搜索树（BST）</h2><ul><li><p>概念：</p><ul><li>二叉搜索树可以为空</li><li>非空左子树的所有节点键值小于其根节点的键值</li><li>非空右子树的所有节点键值大于其根节点的键值</li></ul></li><li><p>基本结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span> (key) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">key</span> = key</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">left</span> = <span class="literal">null</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">right</span> = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchTree</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span> () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>常见操作：</p><ul><li><p>insert(key)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">insert (key) &#123;</span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> <span class="title class_">Node</span>(key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = newNode</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, newNode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归寻找并插入</span></span><br><span class="line">  insertNode (treeNode, newNode) &#123;</span><br><span class="line">    <span class="comment">// 需判断类型，如果不是Node类的实例，则返回false</span></span><br><span class="line">    <span class="keyword">if</span> (!newNode <span class="keyword">instanceof</span> <span class="title class_">Node</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newNode.<span class="property">key</span> &lt;= treeNode.<span class="property">key</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!treeNode.<span class="property">left</span>)&#123; <span class="comment">// 若孩子节点为空，则直接插入</span></span><br><span class="line">        treeNode.<span class="property">left</span> = newNode</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 否则 递归 插入，知道找到空位置</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(treeNode.<span class="property">left</span>, newNode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newNode.<span class="property">key</span> &gt; treeNode.<span class="property">key</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (!treeNode.<span class="property">right</span>)&#123;</span><br><span class="line">        treeNode.<span class="property">right</span> = newNode</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(treeNode.<span class="property">right</span>, newNode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>search(key)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用递归搜索二叉树  </span></span><br><span class="line"><span class="title function_">search</span>(<span class="params">key,node = <span class="variable language_">this</span>.root</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; node.<span class="property">key</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">search</span>(key,node.<span class="property">left</span>) <span class="comment">// 此处必须return，不然上级函数无法收到下级的返回值</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.<span class="property">key</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">search</span>(key,node.<span class="property">right</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 非递归搜索二叉树</span></span><br><span class="line"><span class="title function_">searchWithoutRecursive</span>(<span class="params">key</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">root</span></span><br><span class="line">    <span class="keyword">while</span> (currentNode)&#123;</span><br><span class="line">      <span class="keyword">if</span> (key &lt; currentNode.<span class="property">key</span>)&#123;</span><br><span class="line">        currentNode = currentNode.<span class="property">left</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; currentNode.<span class="property">key</span>)&#123;</span><br><span class="line">        currentNode = currentNode.<span class="property">right</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>preOrderTraverse() 前序遍历二叉树</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历节点:根左右</span></span><br><span class="line"><span class="comment">// 递归遍历</span></span><br><span class="line">  <span class="title function_">preOrderTraverse</span>(<span class="params">node = <span class="variable language_">this</span>.root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node)&#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">key</span>)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">preOrderTraverse</span>(node.<span class="property">left</span>)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">preOrderTraverse</span>(node.<span class="property">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归遍历</span></span><br><span class="line"><span class="title function_">preOrderTraverse</span>(<span class="params">root</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">let</span> stack = []</span><br><span class="line">   <span class="keyword">let</span> result = []</span><br><span class="line">   stack.<span class="title function_">push</span>(root) <span class="comment">// 第一次先推入根节点</span></span><br><span class="line">   <span class="keyword">while</span>(stack.<span class="property">length</span>)&#123; <span class="comment">// 当栈中有值时，继续遍历</span></span><br><span class="line">       <span class="keyword">let</span> node = stack.<span class="title function_">pop</span>()  <span class="comment">// 弹出栈顶节点</span></span><br><span class="line">       result.<span class="title function_">push</span>(node.<span class="property">value</span>) <span class="comment">// 推入节点值</span></span><br><span class="line">       <span class="keyword">if</span>(node.<span class="property">right</span>) &#123;     <span class="comment">// 先推入右子树，后推入左子树，即左子树先遍历</span></span><br><span class="line">           stack.<span class="title function_">push</span>(node.<span class="property">right</span>)</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(node.<span class="property">left</span>) &#123;</span><br><span class="line">           stack.<span class="title function_">push</span>(node.<span class="property">left</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>inOrderTraverse() 中序遍历二叉树</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历二叉树:左根右</span></span><br><span class="line"><span class="comment">// 递归遍历</span></span><br><span class="line"><span class="title function_">inOrderTraverse</span>(<span class="params">node = <span class="variable language_">this</span>.root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!node)&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">inOrderTraverse</span>(node.<span class="property">left</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">key</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">inOrderTraverse</span>(node.<span class="property">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归遍历，回溯算法</span></span><br><span class="line"><span class="title function_">inOrderTraverse</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">let</span> stack = []</span><br><span class="line">   <span class="keyword">let</span> result = []</span><br><span class="line">   <span class="keyword">let</span> node = root</span><br><span class="line">   stack.<span class="title function_">push</span>(root) <span class="comment">// 第一次先推入根节点</span></span><br><span class="line">   <span class="keyword">while</span>(stack.<span class="property">length</span> || node)&#123; </span><br><span class="line">       <span class="keyword">if</span>(node)&#123;  <span class="comment">// 循环找到左子树尽头</span></span><br><span class="line">           stack.<span class="title function_">push</span>(node) <span class="comment">// 记录过程中的所有双亲节点</span></span><br><span class="line">           node = node.<span class="property">left</span> <span class="comment">//指向左子树</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           node = stack.<span class="title function_">pop</span>()</span><br><span class="line">           result.<span class="title function_">push</span>(node.<span class="property">value</span>)</span><br><span class="line">           node = node.<span class="property">right</span> <span class="comment">// 指向右子树，并向左寻找到尽头重复if内的操作</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>postOrderTraverse() 后序遍历二叉树</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历二叉树:左右根</span></span><br><span class="line"> <span class="title function_">postOrderTraverse</span>(<span class="params">node = <span class="variable language_">this</span>.root</span>)&#123;</span><br><span class="line">     <span class="keyword">if</span>(!node)&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">postOrderTraverse</span>(node.<span class="property">left</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">postOrderTraverse</span>(node.<span class="property">right</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">key</span>)</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>二叉树广度优先遍历</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归遍历</span></span><br><span class="line"><span class="keyword">let</span> result = []</span><br><span class="line"><span class="keyword">let</span> stack = [root] <span class="comment">// 第0个元素作为根开始遍历</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>  <span class="comment">//记录层级，从第0层开始，也就是队列的第0个元素根元素</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bfs</span> () &#123;</span><br><span class="line">    <span class="keyword">let</span> node = stack[count] </span><br><span class="line">    <span class="keyword">if</span>(node)&#123; <span class="comment">// 依次将左右子树推入栈中，并在递归之前，增加层级吗，在下次遍历时，</span></span><br><span class="line">        result.<span class="title function_">push</span>(node.<span class="property">value</span>)</span><br><span class="line">        <span class="keyword">if</span>(node.<span class="property">left</span>) &#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(node.<span class="property">left</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.<span class="property">right</span>) &#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(node.<span class="property">right</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        count ++</span><br><span class="line">        <span class="title function_">bfs</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">bfs</span>()</span><br><span class="line">   </span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">let</span> result = [];</span><br><span class="line"><span class="keyword">let</span> stack = [root]; <span class="comment">// 先将要遍历的树压入栈</span></span><br><span class="line"><span class="keyword">let</span> bfs = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> node = stack.<span class="title function_">shift</span>() <span class="comment">// 使用出队列</span></span><br><span class="line">   <span class="keyword">if</span>(node) &#123;</span><br><span class="line">       result.<span class="title function_">push</span>(node.<span class="property">value</span>);</span><br><span class="line">       <span class="keyword">if</span>(node.<span class="property">left</span>) stack.<span class="title function_">push</span>(node.<span class="property">left</span>);</span><br><span class="line">       <span class="keyword">if</span>(node.<span class="property">right</span>) stack.<span class="title function_">push</span>(node.<span class="property">right</span>);</span><br><span class="line">       <span class="title function_">bfs</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">bfs</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bfsWithoutRecursive</span> (root) &#123;</span><br><span class="line">   <span class="keyword">let</span> result = [];</span><br><span class="line">   <span class="keyword">let</span> queue = [root];    <span class="comment">// 使用pointer模拟队列 先将要遍历的树根放入队列中</span></span><br><span class="line">   <span class="keyword">let</span> pointer = <span class="number">0</span>          <span class="comment">// 当访问一次队列头的元素，就让指针向后移动一位，即指针之前代表已经出队列的元素</span></span><br><span class="line">     <span class="comment">// pointer &lt; queue.length 模拟队列中的所有元素还未被访问，即队列没有为空</span></span><br><span class="line">   <span class="keyword">while</span>(pointer &lt; queue.<span class="property">length</span>)&#123;</span><br><span class="line">   <span class="keyword">let</span> node = queue[pointer++] <span class="comment">// 获得指针指向的元素，在让指针增加，相当于出队列</span></span><br><span class="line">       result.<span class="title function_">push</span>(node.<span class="property">value</span>) </span><br><span class="line">       node.<span class="property">left</span> &amp;&amp; queue.<span class="title function_">push</span>(node.<span class="property">left</span>) <span class="comment">// 将当前层级的左右子树推入队列中</span></span><br><span class="line">       node.<span class="property">right</span> &amp;&amp; queue.<span class="title function_">push</span>(node.<span class="property">right</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">bfsWithoutRecursive</span>()</span><br></pre></td></tr></table></figure></li><li><p>min()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">min</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">root</span>)&#123; <span class="comment">// 空根，退出</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">root</span> <span class="comment">// 一直向左子树寻找，直到左子树为null</span></span><br><span class="line">      <span class="keyword">while</span>(currentNode.<span class="property">left</span>)&#123;</span><br><span class="line">          currentNode = currentNode.<span class="property">left</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> currentNode.<span class="property">key</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>max()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">max</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">root</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">root</span></span><br><span class="line">    <span class="keyword">while</span>(currentNode.<span class="property">right</span>)&#123;</span><br><span class="line">      currentNode = currentNode.<span class="property">right</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currentNode.<span class="property">key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>remove(key)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">removeNode</span>(<span class="params">key</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">root</span></span><br><span class="line">    <span class="keyword">let</span> prevNode = <span class="variable language_">this</span>.<span class="property">root</span></span><br><span class="line">    <span class="keyword">let</span> isLeftChild = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">search</span>(key))&#123;</span><br><span class="line">      <span class="keyword">while</span> (currentNode.<span class="property">key</span> !== key)&#123;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; currentNode.<span class="property">key</span>)&#123;</span><br><span class="line">          isLeftChild = <span class="literal">true</span></span><br><span class="line">          prevNode = currentNode</span><br><span class="line">          currentNode = currentNode.<span class="property">left</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; currentNode.<span class="property">key</span>)&#123;</span><br><span class="line">          isLeftChild = <span class="literal">false</span></span><br><span class="line">          prevNode = currentNode</span><br><span class="line">          currentNode = currentNode.<span class="property">right</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(prevNode)</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(currentNode)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 情况1： 删除的节点是叶子节点，或者是没有孩子的根节点</span></span><br><span class="line">      <span class="keyword">if</span> (! (currentNode.<span class="property">left</span> &amp;&amp; currentNode.<span class="property">right</span>) )&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentNode === <span class="variable language_">this</span>.<span class="property">root</span>)&#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( isLeftChild )&#123;</span><br><span class="line">          prevNode.<span class="property">left</span> = <span class="literal">null</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          prevNode.<span class="property">right</span> = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 情况2： 删除的节点只有一个子节点</span></span><br><span class="line">      <span class="comment">// 如果删除的节点只有右子节点</span></span><br><span class="line">      <span class="keyword">if</span>(!currentNode.<span class="property">left</span>)&#123;</span><br><span class="line">        <span class="comment">// 如果删除的节点是根节点，且只有右子节点</span></span><br><span class="line">        <span class="keyword">if</span>( currentNode === <span class="variable language_">this</span>.<span class="property">root</span>)&#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">root</span> = <span class="variable language_">this</span>.<span class="property">root</span>.<span class="property">right</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果删除的节点是上一个节点的左节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild)&#123;</span><br><span class="line">          prevNode.<span class="property">left</span> = currentNode.<span class="property">right</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果删除的节点是上一个节点的右节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          prevNode.<span class="property">right</span> = currentNode.<span class="property">right</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment">// 如果删除的节点只有左子节点</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!currentNode.<span class="property">right</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果删除的节点是根节点，且只有左子节点</span></span><br><span class="line">        <span class="keyword">if</span>( currentNode === <span class="variable language_">this</span>.<span class="property">root</span>)&#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">root</span> = <span class="variable language_">this</span>.<span class="property">root</span>.<span class="property">left</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果删除的节点是上一个节点的左节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild)&#123;</span><br><span class="line">          prevNode.<span class="property">left</span> = currentNode.<span class="property">left</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果删除的节点是上一个节点的右节点，将上一个节点的右节点连接到当前节点的左节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          prevNode.<span class="property">right</span> = currentNode.<span class="property">left</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 情况3：如果删除的节点有2个子节点，情况就复杂起来了</span></span><br><span class="line">      <span class="comment">// 经过多个情况的综合探查，如果要删除有2个子节点的节点，需要找到一个节点将其替换</span></span><br><span class="line">      <span class="comment">// 这个节点必须是删除节点左子树的最大值，称为删除节前驱 或者 右子树的最小值，称为后继</span></span><br><span class="line">      &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 此处的后继要么没有子节点，要么只有右节点，没有左节点</span></span><br><span class="line">        <span class="keyword">let</span> successor = <span class="variable language_">this</span>.<span class="title function_">getNodeSuccessor</span>(currentNode)</span><br><span class="line">        <span class="comment">// 如果当前删除的节点是根</span></span><br><span class="line">        <span class="keyword">if</span>(currentNode === <span class="variable language_">this</span>.<span class="property">root</span>)&#123;</span><br><span class="line">          successor.<span class="property">left</span> = currentNode.<span class="property">left</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果被删除的节点是双亲节点的左节点</span></span><br><span class="line">        <span class="keyword">if</span> (isLeftChild)&#123;</span><br><span class="line">          prevNode.<span class="property">left</span> = successor</span><br><span class="line">          <span class="comment">// 如果删除的节点是上一个节点的右节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          prevNode.<span class="property">right</span> = successor</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后将删除的节点的左节点接上后继节点</span></span><br><span class="line">        successor.<span class="property">left</span> = currentNode.<span class="property">left</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//  没有找到这个节点，返回false</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 获取后继节点</span></span><br><span class="line">  <span class="title function_">getNodeSuccessor</span>(<span class="params">node</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> successorParent = node.<span class="property">right</span></span><br><span class="line">    <span class="keyword">let</span> successor = node.<span class="property">right</span></span><br><span class="line">    <span class="comment">// 找到后继节点</span></span><br><span class="line">    <span class="keyword">while</span>(successor.<span class="property">left</span>)&#123;</span><br><span class="line">      successorParent = successor</span><br><span class="line">      successor = successor.<span class="property">left</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果后继节点不是删除的节点的右子树的根</span></span><br><span class="line">    <span class="keyword">if</span> (successor !== node.<span class="property">right</span>)&#123;</span><br><span class="line">      <span class="comment">// 让后继节点的右节点成为 后继节点的双亲节点的左节点（因为后继节点上所有节点都比后继节点的双亲节点小）</span></span><br><span class="line">      successorParent.<span class="property">left</span> = successor.<span class="property">right</span></span><br><span class="line">      <span class="comment">// 让后继节点的双亲节点成为 后继节点的右节点（比后继大的节点）</span></span><br><span class="line">      successor.<span class="property">right</span> = node.<span class="property">right</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> successor</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在实际操作中，删除二叉树节点操作编码比较复杂，而且开销相对较大，所以一般情况下，尽量避免删除操作，而是给Node节点类添加一个<code>isDelete</code>的Boolean值，来标识当前节点是否删除，这样只需要寻找到删除的节点即可，而标识了被删除的节点在寻找时不会被返回，而是向下寻找或者跳出，但是这种处理方法会浪费大量的空间。</p><h3 id="寻找二叉树的最小深度"><a href="#寻找二叉树的最小深度" class="headerlink" title="寻找二叉树的最小深度"></a>寻找二叉树的最小深度</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">run</span>(<span class="params"> root </span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!root)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(!root.<span class="property">left</span> &amp;&amp; !root.<span class="property">right</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">let</span> depth = <span class="number">0</span></span><br><span class="line">      <span class="keyword">let</span> queue = []</span><br><span class="line">      queue.<span class="title function_">push</span>(root);</span><br><span class="line">      <span class="keyword">while</span>(queue.<span class="property">length</span>)&#123;</span><br><span class="line">          <span class="keyword">let</span> len = queue.<span class="property">length</span> <span class="comment">// 必须记录上次放入的节点数，否则depth不会增加</span></span><br><span class="line">          depth++;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">              <span class="keyword">let</span> cur = queue.<span class="title function_">shift</span>()        </span><br><span class="line">              <span class="keyword">if</span>(!cur.<span class="property">left</span> &amp;&amp; !cur.<span class="property">right</span>)</span><br><span class="line">                  <span class="keyword">return</span> depth;</span><br><span class="line">              <span class="keyword">if</span>(cur.<span class="property">left</span>)</span><br><span class="line">                  queue.<span class="title function_">push</span>(cur.<span class="property">left</span>);</span><br><span class="line">              <span class="keyword">if</span>(cur.<span class="property">right</span>)</span><br><span class="line">                  queue.<span class="title function_">push</span>(cur.<span class="property">right</span>);</span><br><span class="line">          &#125;              </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树的缺陷"><a href="#二叉搜索树的缺陷" class="headerlink" title="二叉搜索树的缺陷"></a>二叉搜索树的缺陷</h3><p>当按照有序，或者大部分有序的的方式插入数据，二叉搜索树的根节点会出现左子树过小，右子树过大，和与之相反的情况，二叉搜索树将失去平衡</p><p>解决方法：</p><ul><li>使用AVL树，自平衡二叉查找树，每个节点多存储了一个额外的数据</li><li>红黑树：目前广泛使用的平衡树，使用一些特性来保持平衡，在插入、删除操作时，性能优于AVL树<ul><li>节点只有红色和黑色两种</li><li>根节点是黑色</li><li>每个叶子节点都是黑色的空节点(NIL)</li><li>每个红色节点的两个子节点都是黑色</li><li>从任意节点到其每个叶子姐弟啊你的所有路径都包含相同数目的黑色节点</li></ul></li></ul></li></ul><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p>普通完全二叉树的问题：n个节点一共有2n个指针，除了根节点之外，n-1个节点都被2n个指针中的n-1个指针引用着，所以剩下2n-(n-1) = n + 1个指针域为null</p><p>如果我们将这n + 1 个指针域在某种遍历次序下存放下一个遍历的前驱或者后继，那么这样的二叉树成为线索二叉树</p><p>按照遍历次序不同可分为三种线索二叉树：前序、中序、后序</p><p>空节点指向规则：</p><ul><li>如果节点的左指针没有被使用，那么左指针指向遍历次序的前驱节点</li><li>如果节点的右指针没有被使用，那么右指针指向遍历次序的后继节点</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线索化二叉树方法,在搜索二叉树的基础上实现</span></span><br><span class="line">inOrderThreadedNodes = <span class="function">(<span class="params">node = <span class="variable language_">this</span>.root</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node)&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线索化左子树</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">inOrderThreadedNodes</span>(node.<span class="property">left</span>)</span><br><span class="line">    <span class="comment">// 处理前驱节点</span></span><br><span class="line">    <span class="keyword">if</span> (!node.<span class="property">left</span>)&#123;</span><br><span class="line">        node.<span class="property">left</span> = <span class="variable language_">this</span>.<span class="property">pre</span></span><br><span class="line">        node.<span class="property">leftIstree</span> = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理后继节点，使用一个全局变量指向中序遍历的上一个节点，为上一个节点线索后继指针</span></span><br><span class="line">    <span class="comment">// 当pre不为空，且pre的后继指针没有被使用的时候，pre的后继就是当前节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">pre</span> &amp;&amp; !<span class="variable language_">this</span>.<span class="property">pre</span>.<span class="property">right</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">pre</span>.<span class="property">right</span> = node</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">pre</span>.<span class="property">rightIstree</span> = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理节点后，改变pre成为下一个前驱节点</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">pre</span> = node</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线索化右子树</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">inOrderThreadedNodes</span>(node.<span class="property">right</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inOrderTraverseThreadedNodes = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="variable language_">this</span>.<span class="property">root</span></span><br><span class="line">    <span class="comment">// 当p不为空的时候循环</span></span><br><span class="line">    <span class="keyword">while</span> (p)&#123;</span><br><span class="line">        <span class="comment">// 当p的节点的左指针指向的是子树而不是前驱，则一直循环直到找到最左的元素</span></span><br><span class="line">        <span class="keyword">while</span> (p.<span class="property">leftIstree</span>)&#123;</span><br><span class="line">            p = p.<span class="property">left</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出这个值</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">key</span>)</span><br><span class="line">        <span class="comment">// 如果p的右节点指向的不是子树，而是后继节点，则直接向后继节点访问</span></span><br><span class="line">        <span class="keyword">while</span> (!p.<span class="property">rightIstree</span>)&#123;</span><br><span class="line">            p = p.<span class="property">right</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">key</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当遇到了右指针指向子树的节点，则跳转到这个节点，继续循环以上步骤，直到p为null</span></span><br><span class="line">        p = p.<span class="property">right</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="红黑树（概念）"><a href="#红黑树（概念）" class="headerlink" title="红黑树（概念）"></a>红黑树（概念）</h2><p>红黑树规则</p><ol><li>节点只能是红色和黑色</li><li>根节点是黑色</li><li>每个叶子节点都是黑色且空节点（NIL节点）</li><li>黑节点可以连续，红节点不能连续出现</li><li>红节点的子节点都必须是黑色节点</li><li>从任意节点到其子树的叶子节点的路径上包含相同的黑色节点</li></ol><p>红黑树特性：</p><ul><li>  从根到叶子的最长路径，不会超过最短路径的两倍</li></ul><p>红黑树变换</p><ul><li>  插入：新节点一般默认为红色节点，如果新节点为黑色会难以调整</li><li>  左旋转：逆时针旋转</li><li>  右旋转：顺时针旋转</li></ul><p>红黑树插入</p><p>相关节点角色：红色新节点:N  新节点的兄弟节点:B    新节点的双亲节点:P    新节点的祖节点:G    新节点的双亲节点的兄弟节点:U</p><p>在搜索二叉树规则下进行插入新节点替换为某个黑色NIL节点之后，在红色新节点上添加2个叶子节点NIL，此时有5种可能的情况</p><ol><li><p>N是根节点，直接将N的红色变为黑色（规则2）</p></li><li><p>N的P是黑色，不做任何变换</p></li><li><p>P是红色，U也是红色，G一定为黑色，此时需将P和U变为黑色，G变为红色</p><ol><li>如果变化后G为根节点，则将G以及整个子树都插入到内容为空的红黑树中，即G变为黑色</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/EricReevess/proxy/master/img/image-20200822114725471.png" alt="image-20200822114725471"></p></li><li><p>N是P的左子节点，P为红色，且P的右子节点不为空，U为黑色，G为黑色，此时需要将P变为黑色，G变为红色，再进行右旋转</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/EricReevess/proxy/master/img/image-20200822115425240.png" alt="image-20200822115425240"><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/EricReevess/proxy/master/img/image-20200822115551815.png" alt="image-20200822115551815"></p></li><li><p>N是P的右子节点，P为红色，且P的左子节点B不为空，U为黑色，G为黑色，此时</p><ol><li>以P为根进行左旋转</li><li>将G变为红色，N变为黑色，以G为根进行右旋转   </li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/EricReevess/proxy/master/img/image-20200822123122453.png" alt="image-20200822123122453"></p></li></ol><h2 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h2><ul><li><p>插入排序</p><p>基本思路：以第一个元素作为参照，将之后的元素插入到前方有序数组中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insertSort</span> (arr) &#123;</span><br><span class="line">    <span class="keyword">let</span> arrCpy = arr.<span class="title function_">slice</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> i,j</span><br><span class="line">    <span class="keyword">let</span> temp</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; arrCpy.<span class="property">length</span>; i++) &#123; <span class="comment">// 一共循环n-1次，因为一第一个元素为参照进行插入</span></span><br><span class="line">        temp = arrCpy[i]<span class="comment">// 保存要插入值</span></span><br><span class="line">        <span class="comment">// 从前面的有序序列的最后一个位置开始向前与插入值比较，如果遇到比插入值大的元素，则将该元素往后移一位</span></span><br><span class="line">        <span class="keyword">for</span> (j = i-<span class="number">1</span>; j &gt;=<span class="number">0</span> &amp;&amp; arrCpy[j] &gt; temp; j--) &#123; </span><br><span class="line">            <span class="comment">// 如果遇到元素的值比插入值小，则直接跳出循环，此时j指向的是比插入值小的元素，j+1此时要么指向i 要么指向已经向后移位的元素</span></span><br><span class="line">            arrCpy[j+<span class="number">1</span>] = arrCpy[j]</span><br><span class="line">        &#125;</span><br><span class="line">        arrCpy[j+<span class="number">1</span>] = temp <span class="comment">// 将值插入进去</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrCpy</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">insertSort</span>([<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">23</span>,<span class="number">6</span>]) )</span><br></pre></td></tr></table></figure></li><li><p>选择排序</p><p>基本思路：每一次循环从数组中选择一个最小/大的数，并记录下标，在循环结束后交换位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">selectSort</span> (array) &#123;</span><br><span class="line">    <span class="keyword">const</span> arrCpy = array.<span class="title function_">slice</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> i,j,minIndex</span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i&lt;arrCpy.<span class="property">length</span> - <span class="number">1</span> ;i++)&#123;</span><br><span class="line">    minIndex = i <span class="comment">// 保存初始下标</span></span><br><span class="line">        <span class="keyword">for</span>( j = i + <span class="number">1</span> ; j &lt; arrCpy.<span class="property">length</span> ; j++)&#123;</span><br><span class="line">            <span class="comment">// 如果找到比minIndex位置小的元素，则更新minIndex</span></span><br><span class="line">            <span class="keyword">if</span>(arrCpy[j] &lt; arrCpy[minIndex])&#123; </span><br><span class="line">                minIndex = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minIndex !== i)&#123;</span><br><span class="line">            [arrCpy[i],arrCpy[minIndex]]=[arrCpy[minIndex],arrCpy[i]]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrCpy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>交换排序</p><p>基本思路：每一次循环都对比两个数的大小，满足条件就进行交换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">swapSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> arrCpy = array.<span class="title function_">slice</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; arrCpy.<span class="property">length</span> -<span class="number">1</span> ; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span> ; j &lt; arrCpy.<span class="property">length</span> ; j ++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arrCpy[i] &gt; arrCpy[j])&#123;</span><br><span class="line">        [arrCpy[i], arrCpy[j]] = [arrCpy[j], arrCpy[i]]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arrCpy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>冒泡排序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> arrCpy = array.<span class="title function_">slice</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; arrCpy.<span class="property">length</span>  ; i++)&#123;</span><br><span class="line">    flag = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span> ; j&lt; arrCpy.<span class="property">length</span> -i ; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arrCpy[j] &gt; arrCpy[j+<span class="number">1</span>])&#123;</span><br><span class="line">        [arrCpy[j],arrCpy[j+<span class="number">1</span>]] = [arrCpy[j+<span class="number">1</span>],arrCpy[j]]</span><br><span class="line">        flag = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123; <span class="comment">// 如果没有进行过冒泡过程，说明数组已经有序</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arrCpy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>希尔排序</p><p>属于插入排序的改进版本，需要选择合适增量，通过从数组中间元素开始向前的位置进行插入排序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shellSort</span> (array) &#123;</span><br><span class="line">  <span class="keyword">const</span> arrCpy = array.<span class="title function_">slice</span>()</span><br><span class="line">  <span class="keyword">const</span> length = arrCpy.<span class="property">length</span></span><br><span class="line">  <span class="comment">// 初始化间隔</span></span><br><span class="line">  <span class="keyword">let</span> gap = <span class="title class_">Math</span>.<span class="title function_">floor</span>(length / <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">let</span> i, j</span><br><span class="line">  <span class="comment">// 当间隔大于1时循环</span></span><br><span class="line">  <span class="keyword">while</span> (gap &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 插入排序的起始位置从数组中间开始，每次都向后方移动一位，与前面对应间隔位置处进行插入排序</span></span><br><span class="line">    <span class="keyword">for</span> (i = gap; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="comment">// 保存插入值</span></span><br><span class="line">      <span class="keyword">const</span> temp = arrCpy[i]</span><br><span class="line">      <span class="comment">// 从插入值i元素的前一个间隔位置开始与 插入值i 比较，如果大于则使用j以间隔向后覆盖</span></span><br><span class="line">      <span class="comment">// 如果遇到小值或者已经到达边界，退出，插入值到j的上一个位置</span></span><br><span class="line">      <span class="keyword">for</span> (j = i - gap; temp &lt; arrCpy[j] &amp;&amp; j &gt;= <span class="number">0</span>; j -= gap) &#123;</span><br><span class="line">        arrCpy[j + gap] = arrCpy[j]</span><br><span class="line">      &#125;</span><br><span class="line">      arrCpy[j + gap] = temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// gap减半继续循环</span></span><br><span class="line">    gap = <span class="title class_">Math</span>.<span class="title function_">floor</span>(gap / <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arrCpy</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">shellSort</span>([<span class="number">15</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">123</span>, <span class="number">2352</span>, <span class="number">3</span>]))</span><br></pre></td></tr></table></figure></li><li><p>js快速排序</p><ul><li>目前最优的排序算法，O(n*log2 n)</li><li>改进版的冒泡排序，每经过一个循环，就确定一个元素在数组中所在的最终位置，不会再被位移</li><li>选择枢纽，使得枢纽左右相对平衡或者随机平衡</li><li>快速排序可以在一次大循环中（包含递归），找出某个元素的正确的位置，并且不需要再次移动</li><li>核心思想：分而治之，选择一个基数，将数组分为2部分，将小于基数的放在左边，大于基数的放在右边，由此可以得到基数最终的位置</li><li>选择一个枢纽，取头 中 尾元素中的一个中位数，例如头部第一个值为3 中部的值为8 尾部值为 1，则选择中部的8作为枢纽</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getPivot</span> (array, left, right) &#123;</span><br><span class="line">  <span class="comment">// 取数组中部index</span></span><br><span class="line">  <span class="keyword">let</span> center = <span class="title class_">Math</span>.<span class="title function_">floor</span>((left + right) / <span class="number">2</span>)</span><br><span class="line">  <span class="comment">// 将前 中 后 三个元素进行排序并交换位置</span></span><br><span class="line">  <span class="keyword">if</span> (array[left] &gt; array[right]) &#123;</span><br><span class="line">    [array[left], array[right]] = [array[right], array[left]]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (array[left] &gt; array[center]) &#123;</span><br><span class="line">    [array[left], array[center]] = [array[center], array[left]]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (array[center] &gt; array[right]) &#123;</span><br><span class="line">    [array[right], array[center]] = [array[center], array[right]]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 此时得到有序的前 中 后 三个元素，中间的元素被选择为第一次递归的排序枢纽</span></span><br><span class="line">  <span class="comment">// 将中部元素与末尾元素的前一个元素进行交换，因为末尾元素在上面三元素排序的时候已经确定比枢纽元素的值大</span></span><br><span class="line">  [array[center], array[right - <span class="number">1</span>]] = [array[right - <span class="number">1</span>], array[center]]</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回处于倒数第二个位置的枢纽元素</span></span><br><span class="line">  <span class="keyword">return</span> array[right - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span> (array) &#123;</span><br><span class="line">  <span class="keyword">let</span> arrCpy = array.<span class="title function_">slice</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="title function_">quick</span>(arrCpy, <span class="number">0</span>, arrCpy.<span class="property">length</span> - <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> arrCpy</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种递归</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">quick1</span> (array, low, high) &#123;</span><br><span class="line">  <span class="comment">// 结束条件</span></span><br><span class="line">  <span class="keyword">if</span> (low &gt;= high) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 得到当前分组的枢纽</span></span><br><span class="line">  <span class="keyword">let</span> pivot = <span class="title function_">getPivot</span>(array, low, high) <span class="comment">//得到枢纽，以及处于倒数第二个元素的子数组</span></span><br><span class="line">  <span class="keyword">let</span> i = low</span><br><span class="line">  <span class="keyword">let</span> j = high - <span class="number">2</span>  <span class="comment">// 从当前子数组倒数第二个元素开始</span></span><br><span class="line">  <span class="keyword">while</span> ( <span class="literal">true</span> ) &#123;</span><br><span class="line">    <span class="comment">// 从低位到高位扫描，当扫描元素值小于等于枢纽值则继续扫描，当扫描值大于枢纽值，跳出</span></span><br><span class="line">    <span class="keyword">while</span> (array[i] &lt; pivot ) &#123;</span><br><span class="line">      i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 跳出从低位到高位扫描后，从高向低扫描，当扫描元素值大于等于枢纽值则继续扫描，当扫描值小于枢纽值，跳出</span></span><br><span class="line">    <span class="keyword">while</span> (array[j] &gt; pivot ) &#123;</span><br><span class="line">      j--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当以上循环均跳出，且i和j没有穿过彼此(i是要小于j才说明扫描并未结束)，交换双方位置的值，否则，这一轮扫描与交换结束</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; j ) &#123;</span><br><span class="line">      [array[i], array[j]] = [array[j], array[i]]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  [array[i], array[high - <span class="number">1</span>]] = [array[high - <span class="number">1</span>], array[i]]</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">arguments</span>.<span class="title function_">callee</span>(array, low, i - <span class="number">1</span>)</span><br><span class="line">  <span class="variable language_">arguments</span>.<span class="title function_">callee</span>(array, i + <span class="number">1</span>, high)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二种递归</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">quick</span> (array, low, high) &#123;</span><br><span class="line">  <span class="comment">// 结束条件</span></span><br><span class="line">  <span class="keyword">if</span> (low &gt;= high) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 得到当前分组的枢纽</span></span><br><span class="line">  <span class="keyword">let</span> pivot = <span class="title function_">getPivot</span>(array, low, high) <span class="comment">//得到枢纽，以及处于倒数第二个元素的子数组</span></span><br><span class="line">  <span class="comment">// 在寻找完枢纽后，三个以下的元素不用再继续排序，否则两两排序会出现问题</span></span><br><span class="line">  <span class="keyword">if</span>(high - low &lt;= <span class="number">2</span> )&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> i = low</span><br><span class="line">  <span class="keyword">let</span> j = high - <span class="number">1</span>  <span class="comment">// 从当前子数组倒数第二个元素开始</span></span><br><span class="line">  <span class="keyword">while</span> ( <span class="literal">true</span> ) &#123;</span><br><span class="line">    <span class="comment">// 从低位到高位扫描，从最低位的后一位开始，当扫描元素值小于等于枢纽值则继续扫描，当扫描值大于枢纽值，跳出</span></span><br><span class="line">    <span class="keyword">while</span> (array[++i] &lt; pivot ) &#123;&#125;</span><br><span class="line">    <span class="comment">// 跳出从低位到高位扫描后，从枢纽位的前一位开始，从高向低扫描，当扫描元素值大于等于枢纽值则继续扫描，当扫描值小于枢纽值，跳出</span></span><br><span class="line">    <span class="keyword">while</span> (array[--j] &gt; pivot ) &#123;&#125;</span><br><span class="line">    <span class="comment">// 当以上循环均跳出，且i和j没有穿过彼此(i是要小于j才说明扫描并未结束)，交换双方位置的值，否则，这一轮扫描与交换结束</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; j ) &#123;</span><br><span class="line">      [array[i], array[j]] = [array[j], array[i]]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果i与high -1 指向的不是同一个位置，则交换</span></span><br><span class="line">  <span class="keyword">if</span>(i !== high -<span class="number">1</span>)</span><br><span class="line">  [array[i], array[high - <span class="number">1</span>]] = [array[high - <span class="number">1</span>], array[i]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">arguments</span>.<span class="title function_">callee</span>(array, low, i - <span class="number">1</span>)</span><br><span class="line">  <span class="variable language_">arguments</span>.<span class="title function_">callee</span>(array, i + <span class="number">1</span>, high)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h2><h3 id="计算逆波兰式（后缀表达式）的值"><a href="#计算逆波兰式（后缀表达式）的值" class="headerlink" title="计算逆波兰式（后缀表达式）的值"></a>计算逆波兰式（后缀表达式）的值</h3><ul><li><p>使用递归方法 加 字符串拼接和eval(）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">evalRPN</span> (tokens) &#123;</span><br><span class="line">  <span class="keyword">if</span> (tokens.<span class="property">length</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; tokens.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="regexp">/^[+\-*\/]$/</span>.<span class="title function_">test</span>(tokens[i])) &#123;</span><br><span class="line">        <span class="keyword">let</span> res = <span class="string">`(<span class="subst">$&#123;tokens[i - <span class="number">2</span>]&#125;</span>)<span class="subst">$&#123;tokens[i]&#125;</span>(<span class="subst">$&#123;tokens[i - <span class="number">1</span>]&#125;</span>)`</span></span><br><span class="line">        tokens.<span class="title function_">splice</span>(i - <span class="number">2</span>, <span class="number">3</span>, <span class="built_in">parseInt</span>(<span class="built_in">eval</span>(res)))</span><br><span class="line">        evalRPN(tokens)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tokens[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(evalRPN([<span class="string">&quot;4&quot;</span>, <span class="string">&quot;13&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;/&quot;</span>, <span class="string">&quot;+&quot;</span>]))</span><br></pre></td></tr></table></figure></li><li><p>栈方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">evalRPN2</span> (tokens) &#123;</span><br><span class="line">  <span class="keyword">const</span> arrCpy = tokens.<span class="title function_">slice</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> temp = []</span><br><span class="line">  <span class="keyword">const</span> reg = <span class="regexp">/^[+\-*\/]$/</span></span><br><span class="line">  <span class="keyword">const</span> _operators = &#123;</span><br><span class="line">    <span class="string">&#x27;+&#x27;</span>: <span class="function">(<span class="params">a, b</span>) =&gt;</span> (+a) + (+b),</span><br><span class="line">    <span class="string">&#x27;-&#x27;</span>: <span class="function">(<span class="params">a, b</span>) =&gt;</span> (+a) - (+b),</span><br><span class="line">    <span class="string">&#x27;*&#x27;</span>: <span class="function">(<span class="params">a, b</span>) =&gt;</span> (+a) * (+b),</span><br><span class="line">    <span class="string">&#x27;/&#x27;</span>: <span class="function">(<span class="params">a, b</span>) =&gt;</span> (+a) / (+b),</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (arrCpy.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!reg.<span class="title function_">test</span>(arrCpy[<span class="number">0</span>])) &#123;</span><br><span class="line">      temp.<span class="title function_">push</span>(arrCpy.<span class="title function_">shift</span>())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> num2 = temp.<span class="title function_">pop</span>()</span><br><span class="line">      <span class="keyword">const</span> num1 = temp.<span class="title function_">pop</span>()</span><br><span class="line">      <span class="keyword">const</span> operator = arrCpy.<span class="title function_">shift</span>()</span><br><span class="line">      temp.<span class="title function_">push</span>(_operators[operator](num1, num2))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> temp.<span class="title function_">toString</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="转换数字为分隔格式"><a href="#转换数字为分隔格式" class="headerlink" title="转换数字为分隔格式"></a>转换数字为分隔格式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">paddingNum</span>(<span class="params">number</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> str = number.<span class="title function_">toString</span>()</span><br><span class="line">  <span class="keyword">let</span> arr = str.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> left = arr[<span class="number">0</span>].<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">//得到整数部分</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = left.<span class="property">length</span> - <span class="number">3</span>; i &gt; <span class="number">0</span> ; i -= <span class="number">3</span>) &#123; <span class="comment">//从倒数第三位开始，向前扫描，并插入逗号</span></span><br><span class="line">    left.<span class="title function_">splice</span>(i, <span class="number">0</span>, <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回处理后的整数部分+小数部分</span></span><br><span class="line">  <span class="keyword">return</span> left.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">concat</span>(arr[<span class="number">1</span>] ? <span class="string">&#x27;.&#x27;</span>+arr[<span class="number">1</span>]:<span class="string">&#x27;&#x27;</span> )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归实现数组扁平化"><a href="#递归实现数组扁平化" class="headerlink" title="递归实现数组扁平化"></a>递归实现数组扁平化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">steamrollArray</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="comment">// 扁平化，扁平化……</span></span><br><span class="line">  <span class="keyword">let</span> res= []</span><br><span class="line">  arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(item <span class="keyword">instanceof</span> <span class="title class_">Array</span>)&#123;</span><br><span class="line">      res.<span class="title function_">push</span>(...<span class="title function_">steamrollArray</span>(item)) <span class="comment">// 调用自身为了深入类型还是Array的元素，使用...为了将返回的数组类型的res进行解开作为上一个push的多个参数，依次递归</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用reduce</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span> (array) &#123;</span><br><span class="line">  <span class="keyword">return</span> array.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> </span><br><span class="line">            prev.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(cur) ? <span class="title function_">flatten</span>(cur) : cur))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用some + concat</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatWithConcat</span> (array) &#123;</span><br><span class="line">  <span class="keyword">while</span> (array.<span class="title function_">some</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="title class_">Array</span>.<span class="title function_">isArray</span>(item)))&#123;</span><br><span class="line">    array = [].<span class="title function_">concat</span>(...array)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES7解决方案</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeDuplicate</span> (array) &#123;</span><br><span class="line">  <span class="keyword">var</span> res = []</span><br><span class="line">    array.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      res.<span class="title function_">includes</span>(item) &amp;&amp; res.<span class="title function_">push</span>(item)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6解决方案</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeDuplicate1</span> (array) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(array))</span><br><span class="line">  <span class="comment">// 或者 return [...new Set(array)]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeDuplicate2</span> (array) &#123;</span><br><span class="line">  <span class="keyword">var</span> res = []</span><br><span class="line">  array.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">indexOf</span>(item) === -<span class="number">1</span> &amp;&amp; res.<span class="title function_">push</span>(item)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用filter()</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeDuplicate3</span> (array) &#123;</span><br><span class="line">  <span class="keyword">var</span> res = []</span><br><span class="line">  array.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">indexOf</span>(item) === -<span class="number">1</span> &amp;&amp; res.<span class="title function_">push</span>(item)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现斐波拉契数列"><a href="#实现斐波拉契数列" class="headerlink" title="实现斐波拉契数列"></a>实现斐波拉契数列</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归，n不能超过75025</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">FibonacciArray</span>(<span class="params">n,a1=<span class="number">1</span>,a2=<span class="number">1</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;=<span class="number">1</span>) <span class="keyword">return</span> a2;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">FibonacciArray</span>(n-<span class="number">1</span>,a2,a1+a2 );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非递归</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fibonacci</span> (n,f1=<span class="number">1</span>,f2=<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> f = <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> (n&lt;=<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;=n ; i++) &#123;</span><br><span class="line">    f = f1 + f2</span><br><span class="line">    f1 = f2</span><br><span class="line">    f2 = f</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React基础与学习笔记</title>
      <link href="/2023/07/24/react-basis/"/>
      <url>/2023/07/24/react-basis/</url>
      
        <content type="html"><![CDATA[<blockquote><p>React 是一个声明式，高效且灵活的用于构建用户界面的 JavaScript 库。使用 React 可以将一些简短、独立的代码片段组合成复杂的 UI 界面，这些代码片段被称作“组件”。</p><p>本文部分内容来源于React官方文档</p></blockquote><h1 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h1><p>JSX是JavaScript的扩展语法，即 JavaScript XML。在React中使用JSX，JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式，且具有 JavaScript 的全部功能，JSX 可以生成 React “元素”。</p><h2 id="为什么要使用JSX？"><a href="#为什么要使用JSX？" class="headerlink" title="为什么要使用JSX？"></a>为什么要使用JSX？</h2><ul><li>React认为 元素的逻辑和以及UI存在一定的耦合，一些HTML元素与JS的事件操作相连，但是React并没有采用将视图和逻辑处理分离在不同的文件中，而是将视图和逻辑处理一同存放在称之为“组件”的松散耦合的单元内，实现 关注点分离 ，JSX本身也是一种表达式，在最终打包编译时会转换为普通的JS文件</li><li>JSX 能有效防止跨站脚本攻击( XSS )，因为在React DOM 渲染所有内容之前都被转换成了字符串</li></ul><h2 id="JSX属性"><a href="#JSX属性" class="headerlink" title="JSX属性"></a>JSX属性</h2><p>使用大括号<code>&#123;&#125;</code>可插入JavaScript表达式，或者使用引号<code>&quot; &quot;</code>直接插入字符串值</p><h2 id="JSX-变量命名"><a href="#JSX-变量命名" class="headerlink" title="JSX 变量命名"></a>JSX 变量命名</h2><p>JSX的元素属性跟随React DOM使用小驼峰命名 className，不使用HTML的属性 命名约定，即<code>-</code>间隔的命名，JSX对于元素的声明，类似xml，当标签内部无内容时，可直接使用 /&gt; 来进行闭合</p><h2 id="JSX-的表示对象"><a href="#JSX-的表示对象" class="headerlink" title="JSX 的表示对象"></a>JSX 的表示对象</h2><p><code>Bable</code>规范会将JSX转译成一个名为 <code>React.createElement()</code> 函数调用，<code>React.createElement()</code> 会预先执行一些检查，并在内部创建一个React元素对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (<span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&quot;welcome&quot;</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>)</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">const</span> element = <span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">  <span class="string">&#x27;h1&#x27;</span>,</span><br><span class="line">  &#123;<span class="attr">className</span>: <span class="string">&#x27;greeting&#x27;</span>&#125;,</span><br><span class="line">  <span class="string">&#x27;Hello, world!&#x27;</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//相当于创建了这个对象</span></span><br><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">    <span class="attr">type</span>:<span class="string">&#x27;h1&#x27;</span>,</span><br><span class="line">    <span class="attr">props</span>:&#123;</span><br><span class="line">        <span class="attr">className</span>:<span class="string">&#x27;welcome&#x27;</span>,</span><br><span class="line">        <span class="attr">children</span>:<span class="string">&#x27;hello&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="React元素渲染"><a href="#React元素渲染" class="headerlink" title="React元素渲染"></a>React元素渲染</h1><ul><li>React 元素元素描述了你在屏幕上想看到的内容，此处的React元素非 React组件</li><li>React 元素 是构成 React 应用的最小砖块，且React DOM 会负责更新 浏览器原生DOM 来与 React 元素保持一致。</li></ul><h2 id="渲染React-元素为-浏览器-DOM"><a href="#渲染React-元素为-浏览器-DOM" class="headerlink" title="渲染React 元素为 浏览器 DOM"></a>渲染React 元素为 浏览器 DOM</h2><p>id为root的根节点的所有内容均由React DOM管理，仅使用 React 构建的应用通常只有单一的根 DOM 节点。<br>将 React 集成进一个已有应用，那么可以在应用中包含任意多的独立根 DOM 节点。</p><ul><li>想要将React 元素 渲染到DOM中，只需要将它们传入到 <code>ReactDOM.render()</code> 中</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello there<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(element,<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>))</span><br></pre></td></tr></table></figure><h2 id="更新已渲染的React-元素"><a href="#更新已渲染的React-元素" class="headerlink" title="更新已渲染的React 元素"></a>更新已渲染的React 元素</h2><p>React元素使用const 进行声明，所以为<strong>不可再赋值对象</strong>，一旦被创建，就无法更改它的子元素或者属性，此时这个React元素表了某个特定时刻的 UI<br>更新UI的唯一方式就是创建一个全新的元素，使用<code>ReactDOM.render()</code>重新进行渲染。<br>想要定时更新UI ，使用<code>window.setInterval()</code>重新声明React元素，调用<code>render()</code>即可 而且 React 只更新它需要更新的部分</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态渲染当前时间</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">currentTime</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> element = (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>你好世界!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前时间： &#123;new Date().toLocaleTimeString()&#125;.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">  <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(element, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(currentTime, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h2 id="React组件和Prop"><a href="#React组件和Prop" class="headerlink" title="React组件和Prop"></a>React组件和Prop</h2><p>组件: 将UI拆分为独立可复用的代码片段，每个片段拥有独立的构思，组件名称必须以大写字母开头</p><p>一种常见的应用模式是尽可能减少状态组件并创建无状态的函数组件。这有助于将状态管理包含到应用程序的特定区域。反过来，通过更容易地跟踪状态变化如何影响其行为，可以改进应用程序的开发和维护。</p><ul><li><p>组件的定义方式</p><ul><li><p>函数组件：使用JavaScript函数进行返回一个 React元素 </p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Hello</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World,I&#x27;m &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>组件名字首字母一定是大写的</p></li><li><p>返回一个jsx、或者一个字符串，jsx依赖React，所以组件内部需要<strong>引入React</strong>。</p></li><li><p>使用</p><ul><li>以标签的方式使用<code>&lt;Component/&gt;</code> ，<ul><li>组件标内的内容不会展示出来</li><li>组件的attributes内className不起作用</li></ul></li><li>直接在双括号内调用<code>&#123; Component() &#125;</code></li></ul></li><li><p>组件传参</p><ul><li>传递： <code>&lt;Component list=&#123; arrData &#125;&gt;&lt;Component&gt;</code></li><li>接收： function Component( props ){…}</li><li>使用： <code>const &#123; list &#125; = props</code>，<code>list</code>就是参数数据 </li></ul></li><li><p>缺点：</p><ul><li>无状态组件：只能实现很简单的视图展示功能，没有自己的内容数据、没有状态，没有逻辑处理</li><li>没有<code>this</code></li><li>没有生命周期，但16.7以后版本的react提供了React Hook</li><li>内部不用render函数，会自动把return返回结果当做render返回结果</li></ul></li></ul></li></ul><ul><li><p>类组件：使用ES6的类(class)继承<code>React.Component</code>来定义的组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World,I&#x27;m &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="渲染组件"><a href="#渲染组件" class="headerlink" title="渲染组件"></a>渲染组件</h3><p>react元素可以是普通HTML标签，也可以是自定义组件标签</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">Hello</span> <span class="attr">name</span>=<span class="string">&quot;jack&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="title class_">ReactDom</span>.<span class="title function_">render</span>(element, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>))</span><br></pre></td></tr></table></figure><h3 id="组合组件"><a href="#组合组件" class="headerlink" title="组合组件"></a>组合组件</h3><p>可以将多个组件组合起来组成另一个React元素，但是每个React应用的最顶层组件都是App组件</p><h3 id="拆分组件"><a href="#拆分组件" class="headerlink" title="拆分组件"></a>拆分组件</h3><p>将组件拆分为更小的组件，在通过行内<code>attribute</code>方式传递值</p><h3 id="props的只读性质"><a href="#props的只读性质" class="headerlink" title="props的只读性质"></a>props的只读性质</h3><p>在JS中 ，不改变传入参数的函数称之为 纯函数，相反，在函数执行过程中改变了参数的函数称之为 非纯函数，<br>所有React的组件必须像纯函数一样保护props，props无法被组件自身修改， 但是state可以</p><h3 id="state-以及-生命周期"><a href="#state-以及-生命周期" class="headerlink" title="state 以及 生命周期"></a>state 以及 生命周期</h3><p><code>state</code> 与 <code>props</code> 类似，但是 <code>state</code> 是私有的，并且完全受控于当前组件，<code>state</code>声明在以class创建的React组件内部的<code>constructor()</code>中，通过传入<code>props</code>，使得<code>state</code>可以接收<code>props</code>传递的数据<br>当组件第一次被渲染到页面时，在React生命周期中称为 挂载(mount)， 当组件被删除时，称之为卸载(unmount)  </p><p><code>componentDidMount()</code> 方法会在组件已经被渲染到 DOM 中后运行<br><code>componentWillUnmount() </code>方法会在组件在DOM删除之前 运行</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClockComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">data</span>:<span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">clockInterval</span> = <span class="built_in">setInterval</span>(</span><br><span class="line">        <span class="function">()=&gt;</span><span class="variable language_">this</span>.<span class="title function_">clock</span>(),</span><br><span class="line">        <span class="number">1000</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">componentWillUnmount</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">clockInterval</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">clock</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">        <span class="attr">data</span>:<span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;this.state.data.toLocaleTimeString()&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">ClockComponent</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br></pre></td></tr></table></figure><h3 id="State-注意事项"><a href="#State-注意事项" class="headerlink" title="State 注意事项"></a>State 注意事项</h3><p>不要直接修改<code>state</code>： this.state.xxx = ‘xxx’; 为错误方法<br>除了使用<code>this.setState()</code>传入新对象进行更新，构造函数是唯一可以给 <code>this.state</code> 赋值的地方</p><p><code>this.setState()</code>，该方法接收两个参数：对象或函数:</p><ul><li>对象：要修改的state的对象形式；</li><li>函数：接收2个函数：<br>第一个函数：参数为state和props，返回类型为一个对象，为state对象的形式<br>第二个函数：在state改变后触发的回调函数</li></ul><h3 id="State-的更新可能是异步的"><a href="#State-的更新可能是异步的" class="headerlink" title="State 的更新可能是异步的"></a>State 的更新可能是异步的</h3><ul><li>出于性能考虑，React 可能会把多个 <code>setState()</code> 调用合并成一个调用</li></ul><p>每当调用this.setState()时，不一定同步更新内部<code>state</code>，换句话说，<code>this.state()</code>可能不会立即执行 ,因此不会造成阻塞</p><blockquote><p>setState何时同步何时异步？</p><p>由React控制的事件处理函数:React封装的事件，比如onChange、onClick、onTouchMove等，以及生命周期函数调用setState()不会同步(立刻)更新state 。</p></blockquote><p>例如在点击按钮直接调用this.setState()的时候，React不会立即更新state中的内容，而是先渲染到页面上，延迟更新state</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">        <span class="attr">data</span>:<span class="string">&#x27;a&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">click</span> = <span class="variable language_">this</span>.<span class="property">click</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">click</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">data</span>:<span class="string">&#x27;b&#x27;</span>&#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">data</span>); <span class="comment">// log -&gt; a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要解决显示改变的结果，则将函数传入setState()的第二个参数即可在改变<code>state</code>后执行函数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">click</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">state,props</span>)=&gt;</span>(&#123;</span><br><span class="line">    <span class="attr">data</span>:<span class="string">&#x27;b&#x27;</span></span><br><span class="line">    &#125;),<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">data</span>); <span class="comment">// log -&gt; b </span></span><br><span class="line">    &#125;);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="State-的更新会被合并"><a href="#State-的更新会被合并" class="headerlink" title="State 的更新会被合并"></a>State 的更新会被合并</h3><blockquote><p>React的state的更新为浅合并，可以单独的更新(替换)指定的一个或者多个变量，而不需要提供整个state。</p></blockquote><p> React 会把以传入对象的形式调用 <code>setState()</code> 提供的对象合并到一个对象中，并更新一次状态，并且值调用一次<code>render()</code>更新界面 </p><p> React 调用多次传入函数形式的 <code>setState()</code>，来多次更新状态，不会合并返回的对象，但只调用一次<code>render()</code>更新界面 </p><p>当传入函数的形式调用 <code>setState()</code> 的时候</p><h3 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h3><ul><li><p>React中不管是任何等级的组件，都无法知道其他组件的<code>state</code>，依靠<code>state</code>的局部封装特征  </p></li><li><p>父组件可以使用它的<code>state</code>作为一个子组件的行内<code>attribute</code> 向下 传递到子组件的<code>props</code>中，但是子组件无法得知传入的props数据是来自子组件的默认props值，还是来自于子组件的<code>state</code>、或者手动设置的<code>props</code>（从实验来看，<code>props</code>是只读对象）  </p></li><li><p>任何的 <code>state</code> 总是所属于特定的组件，而且从该 <code>state</code> 派生的任何数据或 UI 只能影响树中“低于”它们的组件。</p></li></ul><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>React的时间均采用小驼峰式命名 camelCase 在JSX语法中 需要传入一个{}包裹的函数，而不是””包裹的字符串,且{}中可以为真值表达式、或者三目运算表达式  </p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;activateLasers&#125;&gt;</span><br><span class="line">  <span class="title class_">Activate</span> <span class="title class_">Lasers</span></span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>同样在回调函数中，使用参数e或者ev、event来访问事件对象    </p><p>在 JavaScript 中，class 的方法默认不会绑定 this。所有在class内部自定义的函数，都需要在构造器内部使用bind将this进行绑定<br>或者不使用这种绑定，在声明自定义函数的时候可将函数变为一个箭头函数，或者在绑定事件处，将未绑定的函数作为函数体</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">onClickHandler = <span class="function">(<span class="params">e</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="comment">//函数处理</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;button onClick = &#123;<span class="variable language_">this</span>.<span class="property">onClickHandler</span>&#125;&gt;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">onClickHandler (e) &#123;</span><br><span class="line">  <span class="comment">//函数处理</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;button onClick = &#123; <span class="function">()=&gt;</span><span class="variable language_">this</span>.<span class="title function_">onClickHandler</span>() &#125;&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure><h3 id="向事件处理函数中传递参数"><a href="#向事件处理函数中传递参数" class="headerlink" title="向事件处理函数中传递参数"></a>向事件处理函数中传递参数</h3><p>通常在一些列表中需要为每一项的删除、修改等按钮  </p><p>在绑定事件时使用箭头函数，事件对象event必须显式传递  </p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick = &#123; <span class="function">(<span class="params">e</span>)=&gt;</span><span class="variable language_">this</span>.<span class="title function_">onClickHandler</span>(e, id) &#125;&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>在事件回调为箭头处理函数的时候，需要通过bind方式，事件对象会被隐式传递  </p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick = &#123;<span class="variable language_">this</span>.<span class="property">onClickHandler</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>, id) &#125;&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><p>使用另一个函数组件通过使用if判断prop来进行渲染</p><ul><li>使用 与运算符 &amp;&amp;<br>在 JavaScript 中，true &amp;&amp; expression 总是会返回 expression, 而 false &amp;&amp; expression 总是会返回 false。</li><li>使用 三目运算符</li></ul><h3 id="阻止组件渲染"><a href="#阻止组件渲染" class="headerlink" title="阻止组件渲染"></a>阻止组件渲染</h3><p>直接在函数组件内条件返回 null 或者class组件内的render()返回null则可阻止渲染，但是不影响组件的生命周期，只是渲染内容为空而已</p><h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><p>列表渲染需要使用到Array.map()方法，可操作数组内部的每一个迭代的元素，并在最后返回一个新数组</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> doubled = numbers.<span class="title function_">map</span>(<span class="function">(<span class="params">number</span>) =&gt;</span> number * <span class="number">2</span>); <span class="comment">//-&gt; 1 4 9 16 25</span></span><br></pre></td></tr></table></figure><p>React的渲染列表的规则则是在map中返回一个带有数据的模板数组，并且每个迭代的项目必须分配一个唯一的key属性<br>而且key属性是只写属性，不可读，只会传递给React，不会传递给组件，不能通过项目上的props进行访问，如果要标识每个迭代项，则需要另外使用属性进行代替，<br>如果你选择不指定显式的 key 值，那么 React 将默认使用索引用作为列表项目的 key 值。 </p><blockquote><p>最将key设置为给的迭代的数据中的id，而不是map迭代的index，因为这样可能因为列表的顺序变化而使性能变差  </p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> doubled = numbers.<span class="title function_">map</span>(<span class="function">(<span class="params">number, index</span>) =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> <span class="attr">index</span>=<span class="string">&#123;index&#125;</span>&gt;</span>&#123;number*2&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>); <span class="comment">//-&gt; 1 4 9 16 25</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;doubled&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span>, </span><br><span class="line">   <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者这样，但是最好进行组件的提取</span></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  &#123;</span></span><br><span class="line"><span class="language-xml">    numbers.map((number, index) =&gt; </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> <span class="attr">index</span>=<span class="string">&#123;index&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;number*2&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span>)</span></span><br><span class="line"><span class="language-xml">   &#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span>, </span><br><span class="line">   <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>元素的 key 只有放在就近的数组上下文中才有意义，换句话说，必须在数据的map方法中对迭代项目进行key属性的添加。</p><h3 id="key-只是在兄弟节点之间必须唯一"><a href="#key-只是在兄弟节点之间必须唯一" class="headerlink" title="key 只是在兄弟节点之间必须唯一"></a>key 只是在兄弟节点之间必须唯一</h3><p>不同的map方法中的key可以相同，不需要要全局唯一</p><h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1><p>React中的表单一般意味着表单的组件时有状态(state)组件，表单默认拥有默认行为——跳转页面，大多数情况下，使用监听组件标签的值，将其值使用函数设置在state中，这种表单组件称之为 受控组件 —— 表单的值被JS事件函数所控制，而不是被元素本身所控制，state为表单唯一数据源</p><h2 id="input-和-textarea"><a href="#input-和-textarea" class="headerlink" title="input 和 textarea"></a>input 和 textarea</h2><p>把setState作为唯一的数据源</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">InputHandler</span> = <span class="function">(<span class="params">event</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">        <span class="attr">inputVal</span>:event.<span class="property">target</span>.<span class="property">value</span>,</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;input value=&#123;<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">inputVal</span>&#125; onInput=&#123;<span class="variable language_">this</span>.<span class="property">InputHandler</span>&#125;/&gt;</span><br></pre></td></tr></table></figure><h2 id="select-以及-option"><a href="#select-以及-option" class="headerlink" title="select 以及 option"></a>select 以及 option</h2><p>React不会在option标签上使用selected来选择项，而是在跟select标签上使用value来设置默认值，在使用onChange事件监听选中的option的value来设置state</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">SelectHandler</span> = <span class="function">(<span class="params">event</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">selectFruit</span>:event.<span class="property">target</span>.<span class="property">value</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;select value=&#123;<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">selectFruit</span>&#125; onChange=&#123;<span class="variable language_">this</span>.<span class="property">SelectHandler</span>&#125;&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">option</span> <span class="attr">disabled</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>--请选择--<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;apple&quot;</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;banana&quot;</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;pear&quot;</span>&gt;</span>梨<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;orange&quot;</span>&gt;</span>橘子<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><h2 id="文件input标签"><a href="#文件input标签" class="headerlink" title="文件input标签"></a>文件input标签</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;file&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><h2 id="处理多个输入"><a href="#处理多个输入" class="headerlink" title="处理多个输入"></a>处理多个输入</h2><p>给每个input标签添加name属性来对获取的vale进行处理</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = target.<span class="property">value</span>;</span><br><span class="line"><span class="keyword">const</span> name = target.<span class="property">name</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">  <span class="comment">//这里使用ES6动态属性名称进行更新</span></span><br><span class="line">  [name]: value</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//等同 ES5:</span></span><br><span class="line"><span class="keyword">var</span> updateObj = &#123;&#125;;</span><br><span class="line">updateObj[name] = value;</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(updateObj);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将input标签的value设置为null 或者undefined ，组件输入则不受控制</p><h1 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h1><p>如果以个父组件内部的一个子组件的状态需要共享给另一个子组件，则可以将它们共同需要的状态提升到父组件的状态中，然后再从父组件中传递到子组件内，父组件作为数据的唯一源，掌握状态控制权，且子组件没有直接控制权，或者说子组件只能通过父组件向子组件传递的props中得到父组件的接口函数，进而调用父组件的某个状态（最好在子组件的自定义函数中调用props中传入的父组件回调）</p><h1 id="组合与继承"><a href="#组合与继承" class="headerlink" title="组合与继承"></a>组合与继承</h1><p>每个子组件中的props.children接收来自父组件插入到子组件标签的内容，在子组件内部使用{props.children}进行放置插入的内容，类似于Vue的插槽slot功能，或者可以在标签的prop中传递一个组件标签，然后再通过props访问</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件中</span></span><br><span class="line">&lt;<span class="title class_">ComponentA</span> </span><br><span class="line">    &lt;h1&gt;内容&lt;/h1&gt;</span><br><span class="line">&lt;/<span class="title class_">ComponentA</span>&gt;</span><br><span class="line"><span class="comment">//子组件ComponentA中</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;props.children&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>在React构建的应用中，几乎没有用到继承这一属性的组件，每个组件都可能被高度自定义；</p><p>如果要复用非UI的功能而使用继承，建议将其提取为一个单独的 JavaScript 模块，如函数、对象或者类。组件可以直接引入（import）而无需通过 extend 继承它们。</p><p>Props 和组合为你提供了清晰而安全地定制组件外观和行为的灵活方式。注意：组件可以接受任意 props，包括基本数据类型，React 元素以及函数。</p><h1 id="React-构建艺术"><a href="#React-构建艺术" class="headerlink" title="React 构建艺术"></a>React 构建艺术</h1><p>React最大的优点就是让我们思考如何科学的、规范的构建一个应用</p><ol><li>我们先要得到设计师的数据稿件，或者服务器后台工作者提供的JSON数据，依此作为组件和状态的规划</li><li>将设计好的UI划分为组件层级，PS图层中的图层名可以被参考为组件名，从而保持美工与程序的一致性<ul><li>使用单一功能的原则来判断组件包括的范围，一个组件只负责一个功能，而不对其他组件产生依赖</li><li>对展示组件内不同类型的数据样式做出决定  </li></ul></li><li>使用React创建一个规划好的静态页面，不需要使用state和prop</li><li>确定UI 组件 的state最小的表示(初始化组件需要的最小状态)，以及state放置的位置<ul><li>遵循<strong>一次且仅一次</strong>的原则</li><li>检查JSON判断数据是否属于当前组件的state<ul><li>该数据是否是从父级通过props传递过来？如果是，则不属于state</li><li>该数据是否随着时间的推移产生变化？如果是，则属于state</li><li>该数据是否可以通过props和state中的值计算得出？如果不是，则属于state</li></ul></li></ul></li><li>添加反向数据流，向下层传递函数，向上层传递state数据以调用setState</li></ol><h1 id="React高级"><a href="#React高级" class="headerlink" title="React高级"></a>React高级</h1><h2 id="组件性能头优化"><a href="#组件性能头优化" class="headerlink" title="组件性能头优化"></a>组件性能头优化</h2><p>继承Component编写的的类组件存在一个问题：</p><ol><li>父组件在执行<code>render()</code>进行重渲染时候，当前组件也会执行<code>render()</code>，即使没有任何变化</li><li>当前组件设置更新state后若无任何变化，还是会调用<code>render()</code>重新渲染</li></ol><p>解决方法：</p><ol><li>在当前组件生命周期函数 <code>shouldComponentUpdate()</code> 中决定返回布尔值，<code>shouldComponentUpdate()</code> 默认会返回<code>true</code>，导致不必要的更新</li><li>使用PureComponent代替Component</li></ol><h2 id="React-lazy函数"><a href="#React-lazy函数" class="headerlink" title="React.lazy函数"></a>React.lazy函数</h2><p>使用React.lazy()函数动态引入一个外部组件</p><p>React.lazy()接收一个函数，这个函数要动态调用import()，而非这个函数返回的是Promise对象，该 Promise 需要 resolve 一个 <code>defalut</code> export 的 React 组件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">OtherComponent</span> = <span class="title class_">React</span>.<span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;./OtherComponent&#x27;</span>));</span><br></pre></td></tr></table></figure><h2 id="Context-与-跨层传递数据"><a href="#Context-与-跨层传递数据" class="headerlink" title="Context 与 跨层传递数据"></a>Context 与 跨层传递数据</h2><p>context的目的是共享作用整个组件树的全局数据，能让你将这些数据向组件树下所有的组件进行“广播”，所有的组件都能访问到这些数据，也能访问到后续的数据更新。</p><p>在一般情况下，从父组件传递到孙组件需要通过中间组件来逐层传递，使用context我们可以避免传递经过中间组件多次prop</p><ul><li><p>Context 对象</p><p>创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从在组件树中离自身最近的那个匹配的 <code>Provider</code> 中读取到当前的 context 值。</p></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(defaultValue);</span><br></pre></td></tr></table></figure><blockquote><p><strong>只有</strong>当组件所处的树中没有匹配到 Provider 时，其 <code>defaultValue</code> 参数才会生效</p></blockquote><ul><li><p>MyContext.Provider</p><p>使用根级别的Context广播提供者，对下层提供值为value的广播，下层组件需要使用contextType来指定Contex广播对象</p></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">MyContext</span>.<span class="property">Provider</span> value=&#123;<span class="comment">/* 某个值 */</span>&#125;&gt; 放置被广播的组件 &lt;<span class="title class_">MyContext</span>.<span class="property">Provider</span>/&gt;</span><br></pre></td></tr></table></figure><blockquote><p> 每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。</p><p> Provider 接收一个 <code>value</code> 属性，传递给消费组件。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据</p><p> 当 Provider 的 <code>value</code> 值发生变化时，它内部的所有消费组件都会重新渲染。Provider 及其内部 consumer 组件都不受制于 <code>shouldComponentUpdate</code> 函数，因此当 consumer 组件在其祖先组件退出更新的情况下也能更新。</p></blockquote><ul><li><p>Class.contextType</p><p>在类组件中，订阅一个Context 对象</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line"><span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">context</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">MyClass</span>.<span class="property">contextType</span> = <span class="title class_">MyContext</span>;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>将挂载在 class 上的 <code>contextType</code> 属性重新赋值一个Context对象，然后就可以使用this.context来访问最近的Context上的value值，而且可以在所有生命周期钩子和render()中访问它</p></blockquote><ul><li><p>Context.Consumer</p><p>在Context.Provider之下，返回使用value进行处理的react元素</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">MyContext</span>.<span class="property">Consumer</span>&gt;</span><br><span class="line">  &#123;<span class="function"><span class="params">value</span> =&gt;</span> <span class="comment">/* 返回基于 context 值进行渲染的React元素*/</span>&#125;</span><br><span class="line">&lt;/<span class="title class_">MyContext</span>.<span class="property">Consumer</span>&gt;</span><br><span class="line"><span class="comment">// context默认值为一个对象，携带函数</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;(&#123;theme, toggleTheme&#125;) =&gt; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">onClick</span>=<span class="string">&#123;toggleTheme&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">style</span>=<span class="string">&#123;&#123;backgroundColor:</span> <span class="attr">theme.background</span>&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">            Toggle Theme</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    )&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>这个函数接收当前的 context 值，返回一个 React 节点。传递给函数的 <code>value</code> 值等同于往上组件树离这个 context 最近的 Provider 提供的 <code>value</code> 值。如果没有对应的 Provider，<code>value</code> 参数等同于传递给 <code>createContext()</code> 的 <code>defaultValue</code>。</p></blockquote><p>使用方法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个React的context对象，参数为默认值</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Context</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(defaultData);</span><br><span class="line"><span class="comment">//在App根组件内使用&lt;ThemeContext.Provider /&gt; 标签包裹顶级作用组件，意思就是这个全局数据使用范围的上限</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 使用一个 Context.Provider 将当前的要传递的值 value 给以下的组件树。</span></span><br><span class="line">    <span class="comment">// 无论多深，任何组件都能读取这个值。</span></span><br><span class="line">    <span class="comment">// 在这个例子中，我们将 “dark” 作为当前的值传递下去。</span></span><br><span class="line">    <span class="comment">// 若将undefined 传入 value中，则不会使用defaultData作为默认值</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">Context.Provider</span> <span class="attr">value</span>=<span class="string">&quot;dark&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Toolbar</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Context.Provider</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在下级组件中，访问Context来使用这个全局数据</span></span><br><span class="line"><span class="keyword">static</span> contextType = <span class="title class_">Context</span>;</span><br><span class="line"><span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">context</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意在使用Context之前需要思考使用是否合理，否则会造成数据域的混乱</p><h3 id="不使用Context进行跨层传递数据"><a href="#不使用Context进行跨层传递数据" class="headerlink" title="不使用Context进行跨层传递数据"></a>不使用Context进行跨层传递数据</h3><p>在根组件处，将最终需要的下级组件本身通过放入一个变量的形式通过prop传递下去，</p><p>这种变化下，只有最顶部的 Page 组件需要知道 <code>Link</code> 和 <code>Avatar</code> 组件是如何使用 <code>user</code> 和 <code>avatarSize</code> 的。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Page根组件中，声明一个变量装入下级组件</span></span><br><span class="line"><span class="keyword">const</span> userLink = (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Avatar</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> <span class="attr">size</span>=<span class="string">&#123;props.avatarSize&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line"><span class="comment">//通过prop传递定义好的组件</span></span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">PageLayout</span> <span class="attr">userLink</span>=<span class="string">&#123;userLink&#125;</span> /&gt;</span></span>;</span><br></pre></td></tr></table></figure><h3 id="通过向prop传递组件来渲染"><a href="#通过向prop传递组件来渲染" class="headerlink" title="通过向prop传递组件来渲染"></a>通过向prop传递组件来渲染</h3><p>这种方式可以有效的解除下级组件与上级组件的耦合</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Page</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> user = props.<span class="property">user</span>;</span><br><span class="line">  <span class="comment">//将子组件进行封装成react元素，这些元素可以使用当前组件的props和state</span></span><br><span class="line">  <span class="keyword">const</span> content = <span class="language-xml"><span class="tag">&lt;<span class="name">Feed</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> /&gt;</span></span>;</span><br><span class="line">  <span class="keyword">const</span> topBar = (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">NavigationBar</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&#123;user.permalink&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Avatar</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> <span class="attr">size</span>=<span class="string">&#123;props.avatarSize&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">NavigationBar</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// 通过props传递组件</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">PageLayout</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">topBar</span>=<span class="string">&#123;topBar&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">content</span>=<span class="string">&#123;content&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    /&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">PageLayout</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">    &#123;props.<span class="property">topBar</span>&#125;</span><br><span class="line">        &#123;props.<span class="property">content</span>&#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="refs-和-DOM"><a href="#refs-和-DOM" class="headerlink" title="refs 和 DOM"></a>refs 和 DOM</h2><p>Refs 提供了一种方式，允许我们访问 DOM 节点或在 render 方法中创建的 React 元素。</p><p>由于不能直接得到原生DOM的对象 ，给标签加上 ref prop 并声明一个值可以使用””和{}，前者声明值，后者使用函数，在组件域中使用this.refs进行访问该DOM对象</p><h3 id="旧版本使用ref："><a href="#旧版本使用ref：" class="headerlink" title="旧版本使用ref："></a>旧版本使用ref：</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> input = <span class="variable language_">this</span>.<span class="property">refs</span>.<span class="property">input</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&quot;input&quot;</span> /&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;js表达式/函数&#125;</span> /&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="何时使用-Refs"><a href="#何时使用-Refs" class="headerlink" title="何时使用 Refs"></a>何时使用 Refs</h3><ul><li>管理焦点，文本选择或媒体播放。</li><li>触发强制动画。</li><li>集成第三方 DOM 库</li></ul><p>避免使用 refs 来做任何可以通过声明式实现来完成的事情。</p><h3 id="新版本使用refs："><a href="#新版本使用refs：" class="headerlink" title="新版本使用refs："></a>新版本使用refs：</h3><p>Refs 是使用 <code>React.createRef()</code> 创建的，并通过 <code>ref</code> 属性附加到 React 元素。</p><p>创建refs</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">prop</span>)&#123;</span><br><span class="line"><span class="variable language_">super</span>(prop)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">inputRef</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;this.inputRef&#125;</span> /&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问refs</p><ul><li><p>当 <code>ref</code> 属性用于 HTML 元素时，React.createRef()返回的对象中的current接收底层对应DOM元素的对象</p></li><li><p>当 <code>ref</code> 属性用于自定义 class 组件时，ref.current作为React组件实例对象</p></li><li><p>不能在函数组件的props中上使用ref，但是可以在函数组件内部使用ref</p></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">prop</span>)&#123;</span><br><span class="line"><span class="variable language_">super</span>(prop);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">inputRef</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">inputRef</span>.<span class="property">current</span>); <span class="comment">//&lt;input /&gt;</span></span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;this.inputRef&#125;</span> /&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React 会在组件挂载时给 <code>current</code> 属性传入 DOM 元素，并在组件卸载时传入 <code>null</code> 值。<code>ref</code> 会在 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 生命周期钩子触发前更新。</p><p>回调Refs</p><p>不使用<code>React.createRefs()</code>创建，将元素上的<code>ref</code>设置成一个回调函数，回调函数的内容是 <code>以React实例或者DOM元素</code>作为参数赋值给<code>constructor</code>中的变量，访问时，直接访问这个变量即可访问到对应DOM</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">prop</span>)&#123;</span><br><span class="line"><span class="variable language_">super</span>(prop)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">inputRef</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">setInputRef</span> = <span class="function"><span class="params">elem</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">inputRef</span> = elem</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">inputRef</span>);  <span class="comment">// &lt;input  /&gt;</span></span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;this.setInputRef&#125;</span> /&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input ref=&#123;<span class="function"><span class="params">elem</span> =&gt;</span><span class="variable language_">this</span>.<span class="property">inputRef</span> = elem&#125; /&gt;</span><br></pre></td></tr></table></figure><h2 id="render-prop"><a href="#render-prop" class="headerlink" title="render prop"></a>render prop</h2><p>术语 <code>render prop</code>是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术</p><p>具有 render prop 的组件接受一个回调函数，该函数返回一个 React 元素并调用它而不是实现自己的渲染逻辑，换句话说，具有render prop的React组件只渲染render内部回调函数的内容</p><p>使用场景</p><ul><li>当某一封装的组件的功能要被其他几个组件复用且不改变封装的时候</li></ul><p>使用方法</p><ul><li><p>在作为复用的组件封装中，将render内部使用<code>&#123;this.props.render(this.state)&#125;</code>将封装组件中的数据传递给组件本身render prop中回调函数的参数中，使用回调函数内容渲染另一个组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> mouse = <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">mouse</span>;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/cat.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">position:</span> &#x27;<span class="attr">absolute</span>&#x27;, <span class="attr">left:</span> <span class="attr">mouse.x</span>, <span class="attr">top:</span> <span class="attr">mouse.y</span> &#125;&#125; /&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mouse</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleMouseMove</span> = <span class="variable language_">this</span>.<span class="property">handleMouseMove</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleMouseMove</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">x</span>: event.<span class="property">clientX</span>,</span><br><span class="line">      <span class="attr">y</span>: event.<span class="property">clientY</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">height:</span> &#x27;<span class="attr">100vh</span>&#x27; &#125;&#125; <span class="attr">onMouseMove</span>=<span class="string">&#123;this.handleMouseMove&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;/*</span></span><br><span class="line"><span class="language-xml">          使用render方法进行动态传递数据，传递给回调函数的参数</span></span><br><span class="line"><span class="language-xml">        */&#125;</span></span><br><span class="line"><span class="language-xml">        &#123;this.props.render(this.state)&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MouseTracker</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>移动鼠标!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Mouse</span> <span class="attr">render</span>=<span class="string">&#123;mouse</span> =&gt;</span> ( // mouse就是封装组件传递过来的state，而这个mouse组件不会渲染自己的render，而是渲染Cat</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Cat</span> <span class="attr">mouse</span>=<span class="string">&#123;mouse&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        )&#125;/&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="不一定要使用render这个prop-名字"><a href="#不一定要使用render这个prop-名字" class="headerlink" title="不一定要使用render这个prop 名字"></a>不一定要使用render这个prop 名字</h3><p>render prop 是因为模式才被称为 <em>render</em> prop ，你不一定要用名为 <code>render</code> 的 prop 来使用这种模式。</p><p><em>任何</em>被用于告知组件需要渲染什么内容的函数 prop 在技术上都可以被称为 “render prop”，即返回内容为react元素的函数，这种函数不一定要反正元素的attributes 中 ，还可以直接放在复用元素的内部</p><h2 id="高阶组件设计模式"><a href="#高阶组件设计模式" class="headerlink" title="高阶组件设计模式"></a>高阶组件设计模式</h2><p>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。</p><p><strong>高阶组件是参数为组件，返回值为新组件的函数。</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">EnhancedComponent</span> = <span class="title function_">higherOrderComponent</span>(<span class="title class_">WrappedComponent</span>);</span><br></pre></td></tr></table></figure><p>组件是将 props 转换为 UI，而高阶组件是将组件转换为另一个组件。</p><p>当几个组件的更新数据模式都具有同样的行为时，使用 高阶组件 解决横切关注点问题</p><p>高阶函数组件接收2个参数，被包装的组件WrappedComponent，被包装的组件所需要的数据/处理方式selectData</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此函数接收一个组件... ，参数数量不限制</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">withSubscription</span>(<span class="params">WrappedComponent, selectData,...</span>) &#123;</span><br><span class="line">  <span class="comment">// 返回一个新组件</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">React</span>.<span class="property">Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">      <span class="variable language_">super</span>(props);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">          <span class="comment">//切面组件拿到数据</span></span><br><span class="line">        <span class="attr">data</span>: <span class="title function_">selectData</span>(<span class="title class_">DataSource</span>, props)</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//操作切面的事件，也是就是生成的组件的公共代码部分</span></span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// ...负责订阅相关的操作...</span></span><br><span class="line">      <span class="title class_">DataSource</span>.<span class="title function_">addChangeListener</span>(<span class="variable language_">this</span>.<span class="property">handleChange</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title class_">DataSource</span>.<span class="title function_">removeChangeListener</span>(<span class="variable language_">this</span>.<span class="property">handleChange</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//回调函数，监听数据变化，不同组件的数据源相同，但是可能传入的selectData进行更新data的操作不同</span></span><br><span class="line">    handleChange = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">        <span class="attr">data</span>: <span class="title function_">selectData</span>(<span class="title class_">DataSource</span>, <span class="variable language_">this</span>.<span class="property">props</span>)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// ... 并使用新数据渲染被包装的组件!</span></span><br><span class="line">      <span class="comment">// 请注意，我们可能还会传递其他属性</span></span><br><span class="line">      <span class="comment">//将公共方法处理的数据交给这个组件的data prop中，并传递其他prop</span></span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> <span class="attr">data</span>=<span class="string">&#123;this.state.data&#125;</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>高阶组件的最大用处在于，在几个组件需要请求公共数据的时候，把出现相同部分的操作以及对数据处理的不同的行为进行包装，只需要告知，不同操作的函数，类似工厂一样，生成一个新的组件</p><p>HOC 通过将组件<em>包装</em>在容器组件中来<em>组成</em>新组件。HOC 是纯函数，没有副作用。</p><p>被包装组件接收来自容器组件的所有 prop，同时也接收一个新的用于 render 的 <code>data</code> prop。HOC 不需要关心数据的使用方式或原因，而被包装组件也不需要关心数据是怎么来的。</p><h3 id="不要试图在-高阶组件模式-中修改组件原型（或以其他方式改变它）"><a href="#不要试图在-高阶组件模式-中修改组件原型（或以其他方式改变它）" class="headerlink" title="不要试图在 高阶组件模式 中修改组件原型（或以其他方式改变它）"></a>不要试图在 高阶组件模式 中修改组件原型（或以其他方式改变它）</h3><p>HOC 不应该修改传入组件，而应该使用组合的方式，通过将组件包装在容器组件中实现功能：</p><h2 id="深入JSX"><a href="#深入JSX" class="headerlink" title="深入JSX"></a>深入JSX</h2><p>prop的展开：</p><p>使用<code>...</code>形式展开的prop，可以由父级自定义通过props传入到组件内部标签的attributes中，且不受控制，不安全</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Button</span> = props =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; kind, ...other &#125; = props;  <span class="keyword">const</span> className = kind === <span class="string">&quot;primary&quot;</span> ? <span class="string">&quot;PrimaryButton&quot;</span> : <span class="string">&quot;SecondaryButton&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&#123;className&#125;</span> &#123;<span class="attr">...other</span>&#125; /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Button</span> <span class="attr">kind</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> console.log(&quot;clicked!&quot;)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        Hello World!</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="React生命周期-同步"><a href="#React生命周期-同步" class="headerlink" title="React生命周期(同步)"></a>React生命周期(同步)</h2><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/EricReeves/proxy/raw/master/img/react-component-life-cycle.png" alt="img"></p><h3 id="从挂载到卸载"><a href="#从挂载到卸载" class="headerlink" title="从挂载到卸载"></a>从挂载到卸载</h3><ul><li><p>constructor()</p><p>constructor(props)中完成了对<code>props</code>和<code>state</code>的初始化，props的初始化是使用<code>prop-type</code>进行的，而<code>state</code>是在构造器内部初始化</p><p>必须在<code>constructor</code>中调用<code>super(props)</code>，否则会导致内部this指向错误</p></li><li><p>componentWillMount()</p><p>在组件进行挂载之前调用的钩子，一般在服务器中使用，<code>componentWillMount()</code>方法在<code>render()</code>方法之前被调用</p></li><li><p>componentDidMount()</p><p>React 的最佳实践是在生命周期方法<code>componentDidMount()</code>中对服务器进行 API 调用或任何其他调用。</p><p>在组件第一次渲染之后调用，此时DOM节点以及生成，通常在此处发送ajax请求，然后使用setState()进行更新数据</p></li><li><p>componentWillUnmount</p><p>在组件销毁之前调用，用于清除定时器，以及事件监听</p></li></ul><h3 id="更新循环"><a href="#更新循环" class="headerlink" title="更新循环"></a>更新循环</h3><ul><li><p>props被修改</p><ul><li><p>componentWillReceiveProps(nextProps)</p><p>在<code>props</code>发生修改时后调用，此时新的<code>props</code>为参数<code>nextProps</code>，而旧的<code>props</code>为<code>this.props</code>，一般<code>props</code>改变会触发<code>state</code>的改变。</p></li></ul></li><li><p>state被修改</p><ul><li><p>shouldComponentUpdate(nextProps,nextState)</p><p>得到最新的props和最新的state后，调用此钩子，此函数返回一个布尔值，<code>true</code>则进行重绘流程，<code>false</code>则不触发重绘，回到<code>running</code>状态</p></li></ul></li><li><p>componentWillUpdate(nextProps,nextState)</p><p>进入更新流程，此时<code>props</code>，<code>state</code>已经迭代，在重新渲染之前调用，任然可以获得新的<code>nextProps</code>与<code>nextState</code>进行操作</p></li><li><p>render()  使用新状态与Diff算法对组件部分进行重绘</p></li><li><p>componentDidUpdate(prevProps,prevState)</p><p>重绘之后调用的钩子，可访问到 旧的<code>prevProps</code>和<code>prevstate</code> </p></li></ul><h2 id="使用-amp-amp-获得更简洁的条件"><a href="#使用-amp-amp-获得更简洁的条件" class="headerlink" title="使用 &amp;&amp; 获得更简洁的条件"></a>使用 &amp;&amp; 获得更简洁的条件</h2><p>if/else 语句在上一次挑战中是有效的，但是有一种更简洁的方法可以达到同样的结果。假设你正在跟踪组件中的几个条件，并且希望根据这些条件中的每一个来渲染不同的元素。如果你写了很多<code>else if</code>语句来返回稍微不同的 UI，你可能会写很多重复代码，这就留下了出错的空间。相反，你可以使用<code>&amp;&amp;</code>逻辑运算符以更简洁的方式执行条件逻辑。这是完全可行的，因为你希望检查条件是否为真，如果为真，则返回一些标记。这里有一个例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;condition &amp;&amp; <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>markup<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#125;</span><br><span class="line">&#123;display &amp;&amp; <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Displayed!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>&#125; </span><br></pre></td></tr></table></figure><p>如果<code>condition</code>为 true，则返回标记。如果 condition 为 false，操作将在判断<code>condition</code>后立即返回<code>false</code>，并且不返回任何内容。你可以将这些语句直接包含在 JSX 中，并通过在每个条件后面写<code>&amp;&amp;</code>来将多个条件串在一起。这允许你在<code>render()</code>方法中处理更复杂的条件逻辑，而无需重复大量代码。</p><h2 id="用-renderToString-在服务器上渲染-React"><a href="#用-renderToString-在服务器上渲染-React" class="headerlink" title="用 renderToString 在服务器上渲染 React"></a>用 renderToString 在服务器上渲染 React</h2><p>到目前为止，你已经能够在客户端上渲染 React 组件，一般来说我们都是这么做的。然而，在一些用例中，在服务器上渲染一个 React 组件是有意义的。由于 React 是一个 JavaScript 视图库，所以使用 Node 让 JavaScript 运行在服务器上是可行的。事实上，React 提供了一个可用于此目的的<code>renderToString()</code>方法。</p><p>有两个关键原因可以解释为什么服务器上的渲染可能会在真实世界的应用程序中使用。</p><ul><li><p>首先，如果不这样做，你的 React 应用程序将包含一个代码量很少的 HTML 文件和一大堆 JavaScript，当它最初加载到浏览器时。这对于搜索引擎来说可能不太理想，因为它们试图为你的网页内容生成索引，以便人们可以找到你。</p></li><li><p>如果在服务器上渲染初始 HTML 标记并将其发送到客户端，则初始页面加载的内容包含搜索引擎可以抓取的所有页面标记。</p></li><li><p>其次，这创造了更快的初始页面加载体验，因为渲染的 HTML 代码量要比整个应用程序的 JavaScript 代码小。React 仍然能够识别你的应用并在初始加载后进行管理。</p></li><li><pre><code class="jsx">class App extends React.Component &#123;  constructor(props) &#123;    super(props);  &#125;  render() &#123;    return &lt;div/&gt;  &#125;&#125;;// change code below this lineReactDOMServer.renderToString(&lt;App /&gt;)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## React Hook</span><br><span class="line"></span><br><span class="line">在没有`Hook`之前，函数组件与class(类)组件的区别：</span><br><span class="line"></span><br><span class="line">* 类组件有`this` ，而函数组件没有`this`</span><br><span class="line">* 类组件拥有`state` ，而函数组件没有 state</span><br><span class="line">* 类组件有完整的生命周期，在创建时需要将其实例化，而函数组件没有声明周期，在执行完毕后返回结果，不用创建实例一个，所以函数组件的性能比类组件的性能好一些，应尽量使用函数组件</span><br><span class="line">* 在类组件每一次重新渲染时，会执行一遍 `render()` 内的代码，在函数式组件每一次重新渲染时，会重新执行一遍函数组件内的所有代码</span><br><span class="line"></span><br><span class="line">Hook 可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性</span><br><span class="line"></span><br><span class="line">Hook在最新的 React中完全为可选，而且向后兼容</span><br><span class="line"></span><br><span class="line">```jsx</span><br><span class="line">import React, &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line">function Example() &#123;</span><br><span class="line">  // 声明一个新的叫做 “count” 的 state 变量,setCount类似于setState</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><h3 id="什么是Hook-？"><a href="#什么是Hook-？" class="headerlink" title="什么是Hook ？"></a>什么是Hook ？</h3><p>Hook是一些可以让你在函数组件中 钩入 React state和生命周期等类组件特性的函数，且Hook不能在类组件中使用,Hook 使用了 JavaScript 的闭包机制</p><h3 id="State-Hook"><a href="#State-Hook" class="headerlink" title="State Hook"></a>State Hook</h3><p>引入<code>&#123;useState&#125;</code>后，可以在函数组件中使用<code>const</code>声明一组<code>state</code>变量 <code>count</code> 和 <code>setCount </code> </p><p><code>useState()</code>会返回一个数组，使用这个2个变量进行数组解构赋值，<code>useState()</code>内部的参数为这个<code>state</code>变量的<em>初始值</em></p><p>React 会在重复渲染时保留这个 <code>state</code> ,但是它不会把新的 <code>state</code> 和旧的 <code>state</code> 进行合并。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数组件中</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [count,setCount] = <span class="title function_">useState</span>(<span class="number">0</span>); <span class="comment">//useState的内部参数为count的初始值</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可见，在一个组件中多次使用<code>State Hook</code>可以声明多个<code>state</code>变量</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数组件中</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [name,setName] = <span class="title function_">useState</span>(<span class="string">&#x27;React&#x27;</span>); </span><br><span class="line">    <span class="keyword">const</span> [age,setAge] = <span class="title function_">userState</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Effect-Hook"><a href="#Effect-Hook" class="headerlink" title="Effect Hook"></a>Effect Hook</h3><p>在React组件一般在生命周期钩子中执行：</p><ul><li>数据获取(发送ajax请求)</li><li>订阅消息(使用第三方库进行状态更新)</li><li>手动修改DOM对象(使用refs修改获得的DOM)</li></ul><p>这些操作被统一成为副作用操作</p><p>useEffect 就是一个 Effect Hook ，为函数组件增加了 <strong>进行副作用操作</strong> 的能力，它跟 class 组件中的 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 3个生命周期钩子具有相同的用途，但是被合成到了一个useEffect()中，参数为一个函数，React 保证了每次运行 effect 的同时，DOM 都已经更新完毕。</p><p><code>useEffect(()=&gt;&#123;..&#125;)</code>的回调函数可访问组件的 props state，在函数组件挂载之后，props state更新之后，函数组件卸载之前，都会调用useEffect()，执行传入的函数</p><h4 id="无需清除的Effect"><a href="#无需清除的Effect" class="headerlink" title="无需清除的Effect"></a>无需清除的Effect</h4><p>我们只想<strong>在 React 更新 DOM 之后运行一些额外的代码。</strong>比如发送网络请求，手动变更 DOM，记录日志，这些都是常见的无需清除的操作。在class组件中，我们需要在挂载后和更新后的钩子中写相同的代码，而Hook只书写一次</p><p><code>useEffect</code> 调度的 effect 不会阻塞浏览器更新屏幕</p><h4 id="需要清除的-Effect"><a href="#需要清除的-Effect" class="headerlink" title="需要清除的 Effect"></a>需要清除的 Effect</h4><p>在<code>Effect</code>中订阅数据只需要一次，这可以防止内存泄露，在class组件中，我们能使用3个生命周期钩子很好的进行订阅、更新和取消订阅</p><p>在<code>Effect</code>中，在回调函数中进行返回一个<strong>清除函数</strong>，对应class组件中的<code>componentWillUnmount()</code> </p><p><strong>React 会等待浏览器完成画面渲染之后才会延迟调用 <code>useEffect</code></strong></p><p><strong>React 会在组件卸载的时候执行清除函数</strong></p><p>函数组件每次更新时，都会先卸载，然后再挂载，意味着每次更新都会调用一次setEffect中的内容然后进行state变量更新，从而循环监听，如果不将上次的订阅取消，那么每次的监听都会被保留在内存中，造成内存泄露，所以必须在每次卸载之前，将上一次的订阅取消</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">FriendStatus</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [isOnline, setIsOnline] = <span class="title function_">useState</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">handleStatusChange</span>(<span class="params">status</span>) &#123;</span><br><span class="line">      <span class="comment">//这个函数一直在被调用，如果没有变动则没次set的值都相同</span></span><br><span class="line">      <span class="title function_">setIsOnline</span>(status.<span class="property">isOnline</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个订阅会在每次更新时都进行一次订阅，相当于监听</span></span><br><span class="line">    <span class="title class_">ChatAPI</span>.<span class="title function_">subscribeToFriendStatus</span>(props.<span class="property">friend</span>.<span class="property">id</span>, handleStatusChange);</span><br><span class="line">    <span class="comment">// 清除上一次的订阅</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">cleanup</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title class_">ChatAPI</span>.<span class="title function_">unsubscribeFromFriendStatus</span>(props.<span class="property">friend</span>.<span class="property">id</span>, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isOnline === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Loading...&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isOnline ? <span class="string">&#x27;Online&#x27;</span> : <span class="string">&#x27;Offline&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Hook 允许我们按照代码的用途分离他们，</strong> 而不是像生命周期函数那样。React 将按照 effect 声明的顺序依次调用组件中的<em>每一个</em> effect</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">FriendStatusWithCounter</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;    <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [isOnline, setIsOnline] = <span class="title function_">useState</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;<span class="keyword">function</span> <span class="title function_">handleStatusChange</span>(<span class="params">status</span>) &#123;</span><br><span class="line">      <span class="title function_">setIsOnline</span>(status.<span class="property">isOnline</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">ChatAPI</span>.<span class="title function_">subscribeToFriendStatus</span>(props.<span class="property">friend</span>.<span class="property">id</span>, handleStatusChange);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title class_">ChatAPI</span>.<span class="title function_">unsubscribeFromFriendStatus</span>(props.<span class="property">friend</span>.<span class="property">id</span>, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="那么为什么要使用函数组件在每次更新后运行useEffect的回调呢？"><a href="#那么为什么要使用函数组件在每次更新后运行useEffect的回调呢？" class="headerlink" title="那么为什么要使用函数组件在每次更新后运行useEffect的回调呢？"></a>那么为什么要使用函数组件在每次更新后运行useEffect的回调呢？</h4><p>如果在class组件中，在组件被挂载之后的<code>componentDidMount()</code>中进行<strong>数据订阅</strong>操作，这个时候组件本身的一个prop作为一个订阅的参数，进行订阅。</p><ul><li>在不使用 <code>componentDidUpdate()</code>的情况下，当这个作为参数的prop被更新时，此时数据订阅的参数没有被更新，导致还是以原来的参数在进行订阅，</li><li>在使用<code>componentDidUpdate()</code>情况下，还要在最开始取消上一次的更新，后再次进行一次相同代码的订阅，导致代码重复2次</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">ChatAPI</span>.<span class="title function_">subscribeToFriendStatus</span>(</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">friend</span>.<span class="property">id</span>,   <span class="comment">//当组件props更新时，这个参数没有被更新</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleStatusChange</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"> <span class="title function_">componentDidUpdate</span>(<span class="params">prevProps</span>) &#123;</span><br><span class="line">    <span class="comment">// 取消订阅之前的 friend.id</span></span><br><span class="line">    <span class="title class_">ChatAPI</span>.<span class="title function_">unsubscribeFromFriendStatus</span>(</span><br><span class="line">      prevProps.<span class="property">friend</span>.<span class="property">id</span>,</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">handleStatusChange</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//当组件props更新时，只能通过componentDidUpdate()来重复调用订阅，这样造成了代码重复</span></span><br><span class="line">    <span class="title class_">ChatAPI</span>.<span class="title function_">subscribeToFriendStatus</span>(</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">friend</span>.<span class="property">id</span>,   </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleStatusChange</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">ChatAPI</span>.<span class="title function_">unsubscribeFromFriendStatus</span>(</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">friend</span>.<span class="property">id</span>,</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleStatusChange</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而使用Effect Hook，不同，在挂载的时候，就会调用一次订阅，并且随着数据的更新，他会不断的通过卸载时清除effect和挂载时重新调用订阅，保证数据以规定的节奏处于最新状态，但是这会造成一个性能问题：<strong>即使数据没有改变，也会不断的进行监听以及进行挂载和卸载</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">FriendStatus</span>(<span class="params">props</span>) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="title class_">ChatAPI</span>.<span class="title function_">subscribeToFriendStatus</span>(props.<span class="property">friend</span>.<span class="property">id</span>, handleStatusChange);</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title class_">ChatAPI</span>.<span class="title function_">unsubscribeFromFriendStatus</span>(props.<span class="property">friend</span>.<span class="property">id</span>, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="对Effect-进行性能优化，解决Effect性能问题"><a href="#对Effect-进行性能优化，解决Effect性能问题" class="headerlink" title="对Effect 进行性能优化，解决Effect性能问题"></a>对Effect 进行性能优化，解决Effect性能问题</h3><p>在class组件中，<code>componentDidUpdate()</code>可以使用<code>prevProps</code>和<code>prevState</code>与新的状态进行比较，来决定是否要进行<strong>取消之前的订阅</strong>和<strong>调用新的订阅</strong></p><p>在使用Effect Hook中，只要在<code>useState()</code>中传递一个数组作为第二个参数（数组中的元素则为进行差异对比的state变量），则可以在两次渲染都没有差别的时候，跳过对effect的回调函数的调用，目前第二个参数<strong>必须</strong>要手动添加</p><ul><li><p>以传入[count]为例：</p><p>如果<code>count</code>当前的值是<code>5</code>，当<code>count</code>接收到一个新值的时候，这个函数组件会启动重新渲染(卸载后挂载)，此时的渲染的<code>count</code>会与上一次渲染的<code>count</code>进行对比，如果这个2个数组 (前面提到的传入的数组) 中的所有元素都相同，即<code>[5 === 5]</code>，则React会跳过执行useEffect()的回调函数，实现了性能优化</p></li><li><p>值得注意的是：</p><ul><li>使用Effect的优化，必须确保数组中包含了所有外部作用域中的变量，这些变量必须是在<code>useEffect()</code>回调中直接、间接影响内部的state变量的变量，否则你的代码会引用到先前渲染中的旧state变量</li></ul></li><li><p>如果指向执行一次effect，可以向第二个参数传递一个空数组<code>[]</code>，告诉React不依赖于任何props和state，永远不需要重复执行</p></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">FriendStatusWithCounter</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;    <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">  &#125;,[count]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [isOnline, setIsOnline] = <span class="title function_">useState</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;<span class="keyword">function</span> <span class="title function_">handleStatusChange</span>(<span class="params">status</span>) &#123;</span><br><span class="line">      <span class="title function_">setIsOnline</span>(status.<span class="property">isOnline</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//这个订阅会在每次更新时都进行一次订阅，相当于监听</span></span><br><span class="line">    <span class="title class_">ChatAPI</span>.<span class="title function_">subscribeToFriendStatus</span>(props.<span class="property">friend</span>.<span class="property">id</span>, handleStatusChange);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 清除上一次的订阅</span></span><br><span class="line">      <span class="title class_">ChatAPI</span>.<span class="title function_">unsubscribeFromFriendStatus</span>(props.<span class="property">friend</span>.<span class="property">id</span>, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,[props.<span class="property">friend</span>.<span class="property">id</span>]);<span class="comment">//对比新旧props.friend.id，在props.friend.id没有发生改变的时候，跳过执行回调函数</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Hook-使用规则"><a href="#Hook-使用规则" class="headerlink" title="Hook 使用规则"></a>Hook 使用规则</h4><h4 id="Effect-Hook总结"><a href="#Effect-Hook总结" class="headerlink" title="Effect Hook总结"></a>Effect Hook总结</h4><p>effect hook 引入 函数组件 ，使得函数组件拥有了类似于class的生命周期钩子，只不过是将挂载后，更新后，卸载前的钩子进行了一个集中处理，简单的来说，effect hook 处理了这么一个流程：</p><ul><li><code>useEffect()</code>的回调函数在被渲染好后，挂载时，触发了一次回调函数</li><li>当遇到状态更新时，在使用新、旧两个数据渲染后进行差异对比，决定是否跳过<code>useEffect()</code>的回调函数，从而决定是否重新渲染</li><li>在进行重新渲染时，在当前组件卸载之前，对回调内的监听、订阅等影响后续数据的操作进行清除</li></ul><h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><h2 id="Redux：创建一个-Redux-Store"><a href="#Redux：创建一个-Redux-Store" class="headerlink" title="Redux：创建一个 Redux Store"></a>Redux：创建一个 Redux Store</h2><p>Redux 是一个状态管理框架，可以与包括 React 在内的许多不同的 Web 技术一起使用。</p><p>在 Redux 中，有一个状态对象负责应用程序的整个状态，这意味着如果你有一个包含十个组件且每个组件都有自己的本地状态的 React 项目，那么这个项目的整个状态将通过 Redux<code>store</code>被定义为单个状态对象，这是学习 Redux 时要理解的第一个重要原则：Redux store 是应用程序状态的唯一真实来源。</p><p>这也意味着，如果你的应用程序想要更新状态，只能通过 Redux store 执行，单向数据流可以更轻松地对应用程序中的状态进行监测管理。</p><p>Redux <code>store</code>是一个保存和管理应用程序状态的<code>state</code>，你可以使用 Redux 对象中的<code>createStore()</code>来创建一个 redux<code>store</code>，此方法将<code>reducer</code>函数作为必需参数，<code>reducer</code>函数将在后面的挑战中介绍。该函数已在代码编辑器中为你定义，它只需将<code>state</code>作为参数并返回一个<code>state</code>即可。</p><h2 id="Redux：从-Redux-Store-获取状态"><a href="#Redux：从-Redux-Store-获取状态" class="headerlink" title="Redux：从 Redux Store 获取状态"></a>Redux：从 Redux Store 获取状态</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="title class_">Redux</span>.<span class="title function_">createStore</span>(</span><br><span class="line">  <span class="function">(<span class="params">state = <span class="number">5</span></span>) =&gt;</span> state</span><br><span class="line">);</span><br><span class="line"><span class="keyword">let</span> currentState = store.<span class="title function_">getState</span>()</span><br></pre></td></tr></table></figure><h2 id="定义一个-Redux-Action"><a href="#定义一个-Redux-Action" class="headerlink" title="定义一个 Redux Action"></a>定义一个 Redux Action</h2><p>由于 Redux 是一个状态管理框架，因此更新状态是其核心任务之一。在 Redux 中，所有状态更新都由 dispatch action 触发，action 只是一个 JavaScript 对象，其中包含有关已发生的 action 事件的信息。Redux store 接收这些 action 对象，然后更新相应的状态。有时，Redux action 也会携带一些数据。例如，在用户登录后携带用户名，虽然数据是可选的，但 action 必须带有<code>type</code>属性，该属性表示此 action 的类型。</p><p>我们可以将 Redux action 视为信使，将有关应用程序中发生的事件信息提供给 Redux store，然后 store 根据发生的 action 进行状态的更新。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> action = &#123;</span><br><span class="line">  <span class="attr">type</span>:<span class="string">&#x27;LOGIN&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义一个-Action-Creator"><a href="#定义一个-Action-Creator" class="headerlink" title="定义一个 Action Creator"></a>定义一个 Action Creator</h2><p>创建 action 后要将 action 发送到 Redux store，以便它可以更新其状态。在 Redux 中，你可以定义动作创建器来完成此任务，action creator 只是一个返回动作的 JavaScript 函数，换句话说，action creator 创建表示动作事件的对象。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> action = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;LOGIN&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">actionCreator</span> ()  &#123;</span><br><span class="line">    <span class="keyword">return</span> action</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分发-Action-Event"><a href="#分发-Action-Event" class="headerlink" title="分发 Action Event"></a>分发 Action Event</h2><p><code>dispatch</code>方法用于将 action 分派给 Redux store，调用<code>store.dispatch()</code>将从 action creator 返回的值发送回 store。</p><p>action creator 返回一个具有 type 属性的对象，该属性指定已发生的 action，然后，该方法将 action 对象 dispatch 到 Redux store</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="title class_">Redux</span>.<span class="title function_">createStore</span>(</span><br><span class="line">  <span class="function">(<span class="params">state = &#123;login: <span class="literal">false</span>&#125;</span>) =&gt;</span> state</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">loginAction</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;LOGIN&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">store.<span class="title function_">dispatch</span>(<span class="title function_">loginAction</span>())</span><br></pre></td></tr></table></figure><h2 id="Redux：在-Store-里处理-Action"><a href="#Redux：在-Store-里处理-Action" class="headerlink" title="Redux：在 Store 里处理 Action"></a>Redux：在 Store 里处理 Action</h2><p>在一个 action 被创建并 dispatch 之后，Redux store 需要知道如何响应该操作。这就是<code>reducer</code>函数存在的意义。</p><ul><li>Redux 中的 Reducers 负责响应 action 然后进行状态的修改。<code>reducer</code>将<code>state</code>和<code>action</code>作为参数，并且它总是返回一个新的<code>state</code>。</li><li>我们要知道这是 reducer 的<strong>唯一</strong>的作用。它不应有任何其他的作用：比如它不应调用 API 接口，也不应存在任何潜在的副作用。</li><li>reducer 只是一个接受状态和动作，然后返回新状态的纯函数。</li><li>Redux 的另一个关键原则是<code>state</code>是只读的。换句话说，<code>reducer</code>函数必须<strong>始终</strong>返回一个新的<code>state</code>，并且永远不会直接修改状态。Redux 不强制改变状态，但是你需要在你的 reducer 函数的代码中强制执行它，</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">  <span class="attr">login</span>: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reducer</span> = (<span class="params">state = defaultState, action</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&quot;LOGIN&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">login</span>:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title class_">Redux</span>.<span class="title function_">createStore</span>(reducer);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">loginAction</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;LOGIN&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Redux：使用-Switch-语句处理多个-Actions"><a href="#Redux：使用-Switch-语句处理多个-Actions" class="headerlink" title="Redux：使用 Switch 语句处理多个 Actions"></a>Redux：使用 Switch 语句处理多个 Actions</h2><p>你可以定义 Redux store 如何处理多种 action 类型。比如你正在 Redux store 中进行用户身份验证，如果你希望用户在登录和注销时具有状态的响应，你可以使用具有<code>authenticated</code>属性的单个的 state 对象。你还需要使用 action creators 创建与用户登录和用户注销相对应的 action，以及 action 对象本身。</p><p>代码编辑器为你创建了 store、actions、action creators。通过编写<code>reducer</code>函数来处理多个身份验证操作。可以在<code>reducer</code>通过使用 JavaScript 的<code>switch</code>来响应不同的 action 事件。这是编写 Redux reducer 时的标准模式，switch 语句选择<code>action.type</code>中的一个值并返回相应的身份验证状态。</p><p><strong>注意：</strong> 此时，不要担心 state 的不变性，因为在这个示例中它很小而且很简单。所以对于每个操作你都可以返回一个新对象，比如<code>&#123;authenticated:true&#125;</code>。另外，不要忘记在 switch 语句中写一个<code>default</code>case，返回当前的<code>state</code>。这是很重要的，因为一旦你的程序有多个 reducer，当一个 action 被 dispatch 时它们都会运行，即使 action 与该 reducer 无关。在这种情况下，你要确保返回当前的<code>state</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">  <span class="attr">authenticated</span>: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">authReducer</span> = (<span class="params">state = defaultState, action</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;LOGIN&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">authenticated</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;LOGOUT&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">authenticated</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">authenticated</span>: state.<span class="property">authenticated</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> store = <span class="title class_">Redux</span>.<span class="title function_">createStore</span>(authReducer);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">loginUser</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;LOGIN&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">logoutUser</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;LOGOUT&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="使用-const-声明-Action-Types"><a href="#使用-const-声明-Action-Types" class="headerlink" title="使用 const 声明 Action Types"></a>使用 const 声明 Action Types</h2><p>在使用 Redux 时的一个常见做法是将操作类型指定为只读，然后在任何使用它们的地方引用这些常量。你可以通过将 action types 使用<code>const</code>声明重构你正在使用的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">LOGIN</span> = <span class="string">&#x27;LOGIN&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">LOGOUT</span> = <span class="string">&#x27;LOGOUT&#x27;</span></span><br><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">  <span class="attr">authenticated</span>: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">authReducer</span> = (<span class="params">state = defaultState, action</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">LOGIN</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">authenticated</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">LOGOUT</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">authenticated</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> store = <span class="title class_">Redux</span>.<span class="title function_">createStore</span>(authReducer);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">loginUser</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="variable constant_">LOGIN</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">logoutUser</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="variable constant_">LOGOUT</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Redux：注册-Store-监听器"><a href="#Redux：注册-Store-监听器" class="headerlink" title="Redux：注册 Store 监听器"></a>Redux：注册 Store 监听器</h2><p>在 Redux <code>store</code>对象上访问数据的另一种方法是<code>store.subscribe()</code>。这允许你将监听器函数订阅到 store，只要一个 action 被 dispatch 就会调用它们。这个方法的一个简单用途是为你的 store 订阅一个函数，它只是在每次收到一个 action 并且更新 store 时记录一条消息。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">ADD</span> = <span class="string">&#x27;ADD&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reducer</span> = (<span class="params">state = <span class="number">0</span>, action</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span>(action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">ADD</span>:</span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> store = <span class="title class_">Redux</span>.<span class="title function_">createStore</span>(&#123;reducer&#125;);</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">store.<span class="title function_">subscribe</span>(<span class="function">()=&gt;</span>&#123;   <span class="comment">// dispatch被调用，就会触发一次subscribe内的回调函数</span></span><br><span class="line">  count ++</span><br><span class="line">&#125;)</span><br><span class="line">store.<span class="title function_">dispatch</span>(&#123;<span class="attr">type</span>: <span class="variable constant_">ADD</span>&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">store.<span class="title function_">dispatch</span>(&#123;<span class="attr">type</span>: <span class="variable constant_">ADD</span>&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">store.<span class="title function_">dispatch</span>(&#123;<span class="attr">type</span>: <span class="variable constant_">ADD</span>&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br></pre></td></tr></table></figure><h2 id="Redux：组合多个-Reduces"><a href="#Redux：组合多个-Reduces" class="headerlink" title="Redux：组合多个 Reduces"></a>Redux：组合多个 Reduces</h2><p>应用程序的状态开始变得越来越复杂时，将状态划分为多个部分可能是个更好的选择。Redux 的第一个原则：所有应用程序状态都保存在 store 中的一个简单的 state 对象中。因此，Redux 提供 reducer 组合作为复杂状态模型的解决方案。定义多个 reducer 来处理应用程序状态的不同部分，然后将这些 reducer 组合成一个 root reducer。然后将 root reducer 传递给 Redux <code>createStore()</code>方法。</p><p>Redux 提供了<code>combineReducers()</code>方法。该方法接受一个对象作为参数，在该参数中定义一个将键与特定 reducer 函数关联的属性。Redux 将使用你给的键值作为关联状态的名称。</p><p>通常情况下，当它们在某种程度上是独一无二的，最好为每个 state 创建一个<code>reducer</code>例如，在一个带有用户身份验证的reactApp，一个 reducer 可以处理身份验证而另一个处理用户提交的文本和注释。对于这样的应用程序，我们可能会编写<code>combineReducers()</code>方法，如下所示：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rootReducer = <span class="title class_">Redux</span>.<span class="title function_">combineReducers</span>(&#123;</span><br><span class="line"> <span class="attr">auth</span>: authenticationReducer,</span><br><span class="line"> <span class="attr">notes</span>: notesReducer</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">INCREMENT</span> = <span class="string">&#x27;INCREMENT&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">DECREMENT</span> = <span class="string">&#x27;DECREMENT&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">counterReducer</span> = (<span class="params">state = <span class="number">0</span>, action</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span>(action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">INCREMENT</span>:</span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">DECREMENT</span>:</span><br><span class="line">      <span class="keyword">return</span> state - <span class="number">1</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">LOGIN</span> = <span class="string">&#x27;LOGIN&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">LOGOUT</span> = <span class="string">&#x27;LOGOUT&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">authReducer</span> = (<span class="params">state = &#123;authenticated: <span class="literal">false</span>&#125;, action</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span>(action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">LOGIN</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">authenticated</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">LOGOUT</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">authenticated</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> rootReducer = <span class="title class_">Redux</span>.<span class="title function_">combineReducers</span>(&#123;</span><br><span class="line">  <span class="attr">count</span>: counterReducer,</span><br><span class="line">  <span class="attr">auth</span>: authReducer</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> store = <span class="title class_">Redux</span>.<span class="title function_">createStore</span>(rootReducer);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="发送-Action-Data-给-Store"><a href="#发送-Action-Data-给-Store" class="headerlink" title="发送 Action Data 给 Store"></a>发送 Action Data 给 Store</h2><p>到目前为止，你已经学会了如何将 action dispatch 给 Redux store，但到目前为止，这些 action 并未包含除 <code>type</code>之外的任何信息。你还可以发送特定数据和 action 一起。事实上，这是非常常见的，因为 action 通常源于一些用户交互，并且往往会携带一些数据，Redux store 经常需要知道这些数据。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">ADD_NOTE</span> = <span class="string">&#x27;ADD_NOTE&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">notesReducer</span> = (<span class="params">state = <span class="string">&#x27;Initial State&#x27;</span>, action</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span>(action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">ADD_NOTE</span>:</span><br><span class="line">      <span class="keyword">return</span> action.<span class="property">text</span></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">addNoteText</span> = (<span class="params">note</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="variable constant_">ADD_NOTE</span>,</span><br><span class="line">    <span class="attr">text</span>: note</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> store = <span class="title class_">Redux</span>.<span class="title function_">createStore</span>(notesReducer);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(store.<span class="title function_">getState</span>());</span><br><span class="line">store.<span class="title function_">dispatch</span>(<span class="title function_">addNoteText</span>(<span class="string">&#x27;Hello!&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(store.<span class="title function_">getState</span>());</span><br></pre></td></tr></table></figure><h2 id="Redux：使用中间件处理异步操作"><a href="#Redux：使用中间件处理异步操作" class="headerlink" title="Redux：使用中间件处理异步操作"></a>Redux：使用中间件处理异步操作</h2><p>Redux Thunk 中间件，专门处理异步操作，例如发送ajax请求，这将会编写一个异步action，其返回一个参数为dispatch的函数，在异步action中调用同步action，进行状态更新，目前推荐使用ES8新增的 async函数配合await等待Promise 来作为异步action返回的函数</p><p>如果要使用 Redux Thunk 中间件，请将其作为参数传递给<code>Redux.applyMiddleware()</code>。然后将此函数作为第二个可选参数提供给<code>createStore()</code>函数，看一下编辑器底部的代码，然后，要创建一个异步的 action，你需要在 action creator 中返回一个以<code>dispatch</code>为参数的函数。在这个函数中，你可以 dispatch action 并执行异步请求。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">REQUESTING_DATA</span> = <span class="string">&#x27;REQUESTING_DATA&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">RECEIVED_DATA</span> = <span class="string">&#x27;RECEIVED_DATA&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">requestingData</span> = (<span class="params"></span>) =&gt; &#123; <span class="keyword">return</span> &#123;<span class="attr">type</span>: <span class="variable constant_">REQUESTING_DATA</span>&#125; &#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">receivedData</span> = (<span class="params">data</span>) =&gt; &#123; <span class="keyword">return</span> &#123;<span class="attr">type</span>: <span class="variable constant_">RECEIVED_DATA</span>, <span class="attr">users</span>: data.<span class="property">users</span>&#125; &#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleAsync</span> = (<span class="params"></span>) =&gt; &#123;<span class="comment">// 异步操作</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">dispatch</span>) &#123;</span><br><span class="line">    <span class="comment">// 在这里 dispatch 请求的 action</span></span><br><span class="line">    <span class="title function_">dispatch</span>(<span class="title function_">requestingData</span>())</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> data = &#123;</span><br><span class="line">        <span class="attr">users</span>: [<span class="string">&#x27;Jeff&#x27;</span>, <span class="string">&#x27;William&#x27;</span>, <span class="string">&#x27;Alice&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 在这里 dispatch 接收到的数据 action</span></span><br><span class="line">    <span class="title function_">dispatch</span>(<span class="title function_">receivedData</span>(data))  </span><br><span class="line">    &#125;, <span class="number">2500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">  <span class="attr">fetching</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">users</span>: []</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">asyncDataReducer</span> = (<span class="params">state = defaultState, action</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span>(action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">REQUESTING_DATA</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">fetching</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">users</span>: []</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">RECEIVED_DATA</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">fetching</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">users</span>: action.<span class="property">users</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> store = <span class="title class_">Redux</span>.<span class="title function_">createStore</span>(</span><br><span class="line">  asyncDataReducer,</span><br><span class="line">  <span class="title class_">Redux</span>.<span class="title function_">applyMiddleware</span>(<span class="title class_">ReduxThunk</span>.<span class="property">default</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="Redux：用-Redux-写一个计数器"><a href="#Redux：用-Redux-写一个计数器" class="headerlink" title="Redux：用 Redux 写一个计数器"></a>Redux：用 Redux 写一个计数器</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">INCREMENT</span> = <span class="string">&#x27;INCREMENT&#x27;</span>; <span class="comment">// 为增量 action 类型定义一个常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">DECREMENT</span> = <span class="string">&#x27;DECREMENT&#x27;</span>; <span class="comment">// 为减量 action 类型定义一个常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">counterReducer</span> = (<span class="params">state = <span class="number">0</span>, action</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span>(action.<span class="property">type</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">INCREMENT</span>:</span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="attr">DECREMENT</span>:</span><br><span class="line">      <span class="keyword">return</span> state - <span class="number">1</span></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125; </span><br><span class="line">&#125;; <span class="comment">// 定义计数器，它将根据收到的action增加或减少状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">incAction</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>:<span class="variable constant_">INCREMENT</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;; <span class="comment">// 定义一个用于递增的 action creator</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">decAction</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>:<span class="variable constant_">DECREMENT</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">// 定义一个用于递减的 action creator</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title class_">Redux</span>.<span class="title function_">createStore</span>(counterReducer); <span class="comment">// 在这里定义一个 Redux store，传递你的 reducer</span></span><br></pre></td></tr></table></figure><h2 id="Redux：永不改变状态"><a href="#Redux：永不改变状态" class="headerlink" title="Redux：永不改变状态"></a>Redux：永不改变状态</h2><p>Redux不可变状态意味着你永远不会直接修改状态，而是返回一个新的状态的副本，其底层原理是React会使用Diff算法比较新旧状态之间的差异，因此更新不能丢失旧的状态</p><p>利用数组或者对象的特征，直接返回基于上一次的state的一个副本，而不是重新将state赋予一个新的地址</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">ADD_TO_DO</span> = <span class="string">&#x27;ADD_TO_DO&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todos = [</span><br><span class="line">  <span class="string">&#x27;Go to the store&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;Clean the house&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;Cook dinner&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;Learn to code&#x27;</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">immutableReducer</span> = (<span class="params">state = todos, action</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span>(action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">ADD_TO_DO</span>:</span><br><span class="line">      <span class="keyword">return</span> state.<span class="title function_">concat</span>(action.<span class="property">todo</span>) <span class="comment">// 返回一个测试副本</span></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">addToDo</span> = (<span class="params">todo</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="variable constant_">ADD_TO_DO</span>,</span><br><span class="line">    todo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> store = <span class="title class_">Redux</span>.<span class="title function_">createStore</span>(immutableReducer);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Redux：从数组中删除项目"><a href="#Redux：从数组中删除项目" class="headerlink" title="Redux：从数组中删除项目"></a>Redux：从数组中删除项目</h2><p>是时候练习从数组中删除项目了。扩展运算符也可以在这里使用。其他有用的JavaScript方法包括<code>slice()</code>和<code>concat()</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">immutableReducer</span> = (<span class="params">state = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], action</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span>(action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;REMOVE_ITEM&#x27;</span>:</span><br><span class="line">      <span class="comment">// 此处不能使用splice，因为会改变原数组</span></span><br><span class="line">      <span class="keyword">return</span> [...state].<span class="title function_">slice</span>(<span class="number">0</span>,action.<span class="property">index</span>).<span class="title function_">concat</span>([...state].<span class="title function_">slice</span>(action.<span class="property">index</span> +<span class="number">1</span>))</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">removeItem</span> = (<span class="params">index</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;REMOVE_ITEM&#x27;</span>,</span><br><span class="line">    index</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title class_">Redux</span>.<span class="title function_">createStore</span>(immutableReducer);</span><br></pre></td></tr></table></figure><h2 id="Redux：使用-Object-assign-合并对象"><a href="#Redux：使用-Object-assign-合并对象" class="headerlink" title="Redux：使用 Object.assign 合并对象"></a>Redux：使用 Object.assign 合并对象</h2><p>最后几个挑战适用于数组，但是当状态是<code>object</code>时，有一些方法可以帮助强制执行状态不变性。处理对象的一个方法是<code>Object.assign()</code>。<code>Object.assign()</code>获取目标对象和源对象，并将源对象中的属性映射到目标对象。任何匹配的属性都会被源对象中的属性覆盖。通常用于通过传递一个空对象作为第一个参数，然后是要用复制的对象来制作对象的浅表副本。这是一个例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newObject = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj1, obj2);</span><br></pre></td></tr></table></figure><p>这会创建<code>newObject</code>作为新的<code>object</code>，其中包含<code>obj1</code>和<code>obj2</code>中当前存在的属性。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">  <span class="attr">user</span>: <span class="string">&#x27;CamperBot&#x27;</span>,</span><br><span class="line">  <span class="attr">status</span>: <span class="string">&#x27;offline&#x27;</span>,</span><br><span class="line">  <span class="attr">friends</span>: <span class="string">&#x27;732,982&#x27;</span>,</span><br><span class="line">  <span class="attr">community</span>: <span class="string">&#x27;freeCodeCamp&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">immutableReducer</span> = (<span class="params">state = defaultState, action</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span>(action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;ONLINE&#x27;</span>:</span><br><span class="line">      <span class="comment">// 使用Object.assign 从最后一个参数到第二个参数来合并一个对象，并生成一个新的浅拷贝对象</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;,state,&#123;<span class="attr">status</span>: <span class="string">&#x27;online&#x27;</span>&#125;)</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">wakeUp</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;ONLINE&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title class_">Redux</span>.<span class="title function_">createStore</span>(immutableReducer);</span><br></pre></td></tr></table></figure><h2 id="React-和-Redux：首先在本地管理状态"><a href="#React-和-Redux：首先在本地管理状态" class="headerlink" title="React 和 Redux：首先在本地管理状态"></a>React 和 Redux：首先在本地管理状态</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DisplayMessages</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">input</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      <span class="attr">messages</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleChange</span> = <span class="variable language_">this</span>.<span class="property">handleChange</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">submitMessage</span> = <span class="variable language_">this</span>.<span class="property">submitMessage</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">handleChange</span>(<span class="params">event</span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">        <span class="attr">input</span>:event.<span class="property">target</span>.<span class="property">value</span></span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">submitMessage</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">        <span class="attr">input</span>:<span class="string">&#x27;&#x27;</span>, </span><br><span class="line">        <span class="attr">messages</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">messages</span>.<span class="title function_">concat</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">input</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;input, messages&#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">    <span class="keyword">const</span> msg = messages.<span class="title function_">map</span>(<span class="function">(<span class="params">item,idx</span>) =&gt;</span> ( <span class="comment">// 注意添加key</span></span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;idx&#125;</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">    ))</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>键入新 Message<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span> <span class="attr">value</span>=<span class="string">&#123;input&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.submitMessage&#125;</span>&gt;</span>Add message<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;msg&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="React-和-Redux：提取状态逻辑给-Redux"><a href="#React-和-Redux：提取状态逻辑给-Redux" class="headerlink" title="React 和 Redux：提取状态逻辑给 Redux"></a>React 和 Redux：提取状态逻辑给 Redux</h2><p>完成 React 组件后，我们需要把在本地<code>状态</code>执行的逻辑移到 Redux 中，这是为小规模 React 应用添加 Redux 的第一步。该应用的唯一功能是把用户的新消息添加到无序列表中。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">ADD</span> = <span class="string">&#x27;ADD&#x27;</span></span><br><span class="line"><span class="keyword">const</span> messages = []</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">messageReducer</span> = (<span class="params">state = messages,action</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="variable constant_">ADD</span> :</span><br><span class="line">      <span class="keyword">return</span> [</span><br><span class="line">        ...state,</span><br><span class="line">        action.<span class="property">message</span></span><br><span class="line">      ];</span><br><span class="line">    <span class="keyword">default</span> :</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">addMessage</span> = (<span class="params">message</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span>&#123;</span><br><span class="line">    <span class="attr">type</span>:<span class="variable constant_">ADD</span>,</span><br><span class="line">    message</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title class_">Redux</span>.<span class="title function_">createStore</span>(messageReducer)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="React-和-Redux：使用-Provider-连接-Redux-和-React"><a href="#React-和-Redux：使用-Provider-连接-Redux-和-React" class="headerlink" title="React 和 Redux：使用 Provider 连接 Redux 和 React"></a>React 和 Redux：使用 Provider 连接 Redux 和 React</h2><p>在上一挑战中，你创建了 Redux store 和 action，分别用于处理消息数组和添加新消息。下一步要为 React 提供访问 Redux store 及发起更新所需的 actions。<code>react-redux</code>包可帮助我们完成这些任务。</p><p>React Redux 提供的 API 有两个关键的功能：<code>Provider</code>和<code>connect</code>，<code>Provider</code>是 React Redux 包装 React 应用的 wrapper 组件，它允许你访问整个组件树中的 Redux<code>store</code>及<code>dispatch（分发）</code>方法。<code>Provider</code>需要两个 props：Redux store 和 APP 应用的子组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Provider</span> store=&#123;store&#125;&gt;</span><br><span class="line"> <span class="language-xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Provider</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Redux 代码：</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">ADD</span> = <span class="string">&#x27;ADD&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">addMessage</span> = (<span class="params">message</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="variable constant_">ADD</span>,</span><br><span class="line">    message</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">messageReducer</span> = (<span class="params">state = [], action</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">ADD</span>:</span><br><span class="line">      <span class="keyword">return</span> [</span><br><span class="line">        ...state,</span><br><span class="line">        action.<span class="property">message</span></span><br><span class="line">      ];</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title class_">Redux</span>.<span class="title function_">createStore</span>(messageReducer);</span><br><span class="line"><span class="comment">// React 代码：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DisplayMessages</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">input</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      <span class="attr">messages</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleChange</span> = <span class="variable language_">this</span>.<span class="property">handleChange</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">submitMessage</span> = <span class="variable language_">this</span>.<span class="property">submitMessage</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">handleChange</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">input</span>: event.<span class="property">target</span>.<span class="property">value</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">submitMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> currentMessage = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">input</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">input</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      <span class="attr">messages</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">messages</span>.<span class="title function_">concat</span>(currentMessage)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Type in a new Message:<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">value</span>=<span class="string">&#123;this.state.input&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;/</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.submitMessage&#125;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;this.state.messages.map( (message, idx) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">              return (</span></span><br><span class="line"><span class="language-xml">                 <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;idx&#125;</span>&gt;</span>&#123;message&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              )</span></span><br><span class="line"><span class="language-xml">            &#125;)</span></span><br><span class="line"><span class="language-xml">          &#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Provider</span> = <span class="title class_">ReactRedux</span>.<span class="property">Provider</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AppWrapper</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="comment">// 在此渲染 Provider</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">DisplayMessages</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 请在本行以上添加你的代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="React-和-Redux：映射-State-到-Props"><a href="#React-和-Redux：映射-State-到-Props" class="headerlink" title="React 和 Redux：映射 State 到 Props"></a>React 和 Redux：映射 State 到 Props</h2><p><code>Provider</code>可向 React 组件提供<code>state</code>和<code>dispatch</code>，但你必须确切地指定所需要的 state 和 actions，以确保每个组件只能访问所需的 state。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写getter函数，将state以对象的值的形式返回给Provider组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">mapStateToProps</span> = (<span class="params">state</span>) =&gt; ()</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">messages</span>:state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="React-和-Redux：映射-Dispatch-到-Props"><a href="#React-和-Redux：映射-Dispatch-到-Props" class="headerlink" title="React 和 Redux：映射 Dispatch 到 Props"></a>React 和 Redux：映射 Dispatch 到 Props</h2><p><code>mapDispatchToProps()</code>函数可为 React 组件提供特定的创建 action 的函数，以便组件可 dispatch actions，从而更改 Redux store 中的数据。它返回一个对象，把 dispatch actions 映射到属性名上，该属性名成为<code>props</code>。然而，每个属性都返回一个用 action creator 及与 action 相关的所有数据调用<code>dispatch</code>的函数，而不是返回<code>state</code>的一部分。你可以访问<code>dispatch</code>，因为在定义函数时，我们以参数形式把它传入<code>mapDispatchToProps()</code>了，这跟<code>state</code>传入<code>mapDispatchToProps()</code>是一样的。在幕后，React Redux 用 Redux 的<code>store.dispatch()</code>来管理这些含<code>mapDispatchToProps()</code>的dispatches，这跟它使用<code>store.subscribe()</code>来订阅映射到<code>state</code>的组件的方式类似。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">addMessage</span> = (<span class="params">message</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;ADD&#x27;</span>,</span><br><span class="line">    <span class="attr">message</span>: message</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将return中的函数映射到组件的props中，在组件的props中就可以访问这些函数，来调用相应的dispatch</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">mapDispatchToProps</span> = (<span class="params">dispatch</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">submitNewMessage</span>: <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">dispatch</span>(<span class="title function_">addMessage</span>(message))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="React-和-Redux：连接-Redux-和-React"><a href="#React-和-Redux：连接-Redux-和-React" class="headerlink" title="React 和 Redux：连接 Redux 和 React"></a>React 和 Redux：连接 Redux 和 React</h2><p>既然写了<code>mapStateToProps()</code>、<code>mapDispatchToProps()</code>两个函数，现在你可以用它们来把<code>state</code>和<code>dispatch</code>映射到 React 组件的<code>props</code>了。React Redux 的<code>connect</code>方法可以完成这个任务。此方法有<code>mapStateToProps()</code>、<code>mapDispatchToProps()</code>两个可选参数，它们是可选的，原因是你的组件可能仅需要访问<code>状态</code>但不需要分发任何 actions，反之亦然。</p><p>为了使用此方法，需要传入函数参数并在调用时传入组件。这种语法有些不寻常，如下所示：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// connect返回一个新常量，这个常量就是已经连接Redux的Component组件副本</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ConnectedComponent</span> = <span class="title function_">connect</span>(mapStateToProps, mapDispatchToProps)(<span class="title class_">Component</span>)</span><br><span class="line"><span class="comment">// 或者在组件中直接暴露一个连接后的组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">connect</span>(</span><br><span class="line">  <span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">user</span>: state.<span class="property">user</span>,</span><br><span class="line">    <span class="attr">chat</span>: state.<span class="property">chat</span></span><br><span class="line">  &#125;),</span><br><span class="line">  &#123; sendMessage, hasReadMessage &#125;</span><br><span class="line">)(<span class="title class_">Chat</span>)</span><br></pre></td></tr></table></figure><h2 id="React-和-Redux：将局部状态提取到-Redux-中"><a href="#React-和-Redux：将局部状态提取到-Redux-中" class="headerlink" title="React 和 Redux：将局部状态提取到 Redux 中"></a>React 和 Redux：将局部状态提取到 Redux 中</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Redux:</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">ADD</span> = <span class="string">&#x27;ADD&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">addMessage</span> = (<span class="params">message</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="variable constant_">ADD</span>,</span><br><span class="line">    <span class="attr">message</span>: message</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">messageReducer</span> = (<span class="params">state = [], action</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">ADD</span>:</span><br><span class="line">      <span class="keyword">return</span> [</span><br><span class="line">        ...state,</span><br><span class="line">        action.<span class="property">message</span></span><br><span class="line">      ];</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title class_">Redux</span>.<span class="title function_">createStore</span>(messageReducer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// React:</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Provider</span> = <span class="title class_">ReactRedux</span>.<span class="property">Provider</span>;</span><br><span class="line"><span class="keyword">const</span> connect = <span class="title class_">ReactRedux</span>.<span class="property">connect</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请在本行以下添加你的代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Presentational</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">input</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleChange</span> = <span class="variable language_">this</span>.<span class="property">handleChange</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">submitMessage</span> = <span class="variable language_">this</span>.<span class="property">submitMessage</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">handleChange</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">input</span>: event.<span class="property">target</span>.<span class="property">value</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">submitMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">submitNewMessage</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">input</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">input</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> messages = <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">messages</span>.<span class="title function_">map</span>( <span class="function">(<span class="params">item, idx</span>) =&gt;</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;idx&#125;</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>)&#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Type in a new Message:<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">value</span>=<span class="string">&#123;this.state.input&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;/</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.submitMessage&#125;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;messages&#125;</span></span><br><span class="line"><span class="language-xml">          &#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">mapStateToProps</span> = (<span class="params">state</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">messages</span>: state&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">mapDispatchToProps</span> = (<span class="params">dispatch</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">submitNewMessage</span>: <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">dispatch</span>(<span class="title function_">addMessage</span>(message))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Container</span> = <span class="title function_">connect</span>(mapStateToProps, mapDispatchToProps)(<span class="title class_">Presentational</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AppWrapper</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Container</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="实现一个Redux"><a href="#实现一个Redux" class="headerlink" title="实现一个Redux"></a>实现一个Redux</h1><p>更新中…..</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> React </tag>
            
            <tag> 前端框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了解MongoDB与mongoose</title>
      <link href="/2023/07/24/mongoDB/"/>
      <url>/2023/07/24/mongoDB/</url>
      
        <content type="html"><![CDATA[<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><ul><li>数据库：存放集合，可以有多个，不需要手动创建</li><li>集合：类似于数组，存放文档，不需要手动创建</li><li>文档：数据的最小单位</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/EricReevess/proxy/master/img/image-20200810170644701.png" alt="image-20200810170644701"></p><p>常用命令</p><ul><li><p>查看数据库占用空间</p><blockquote><p>show dbs</p></blockquote></li><li><p>进入到指定数据库</p><blockquote><p>use 数据库名</p></blockquote></li><li><p>显示当前所在的数据库</p><blockquote><p>db</p></blockquote></li><li><p>显示数据库中所有的集合</p><blockquote><p>show collections</p></blockquote></li><li><p>插入数据到某集合中</p><blockquote><p>db.集合名.insert(js对象类型的键值对)</p></blockquote></li><li><p>查找集合下的所有文档</p><blockquote><p>db.集合名.find() </p></blockquote></li></ul><h2 id="Mongoose"><a href="#Mongoose" class="headerlink" title="Mongoose"></a>Mongoose</h2><p>mongoose 是一个对象-文档模型，他对NodeJS原生的MongoDB模块进行了进一步的封装，提供了更多的功能，大多数亲情况下，他被用来把结构化的模式应用到一个集合中</p><ul><li>并且提供数据验证和类型转换的功能</li><li>为文档创建一个约束使得数据结构合法</li><li>使用中间件</li><li>更容易驱动</li></ul><p>核心对象：</p><ul><li>Schema（模式对象），约束了集合中的文档结构</li><li>Model 将集合作为对象来表示，包含在内的所有文档</li><li>Document 表示集合中的一个具体文档对象，每个文档在创建时，都会自动生成一个<code>_id</code>的属性</li></ul><p>代码示例，来源于真实项目：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接数据库</span></span><br><span class="line">mongoose.<span class="title function_">connect</span>(<span class="string">&#x27;mongodb://localhost:27017/test&#x27;</span>,</span><br><span class="line">  &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span>, <span class="attr">useUnifiedTopology</span>: <span class="literal">true</span> &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 获得数据库对象</span></span><br><span class="line"><span class="keyword">const</span> mongooseConnection = mongoose.<span class="property">connection</span></span><br><span class="line"><span class="comment">// 监听连接状态</span></span><br><span class="line">mongooseConnection.<span class="title function_">on</span>(<span class="string">&#x27;connected&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Mongo数据库连接成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 定义数据约束，与SQL中的表类似</span></span><br><span class="line"><span class="keyword">const</span> userSchema = mongoose.<span class="title class_">Schema</span>(&#123;</span><br><span class="line">  <span class="attr">username</span>: &#123; <span class="attr">type</span>: <span class="title class_">String</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  <span class="attr">password</span>: &#123; <span class="attr">type</span>: <span class="title class_">String</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  <span class="attr">userType</span>: &#123; <span class="attr">type</span>: <span class="title class_">String</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  <span class="attr">name</span>: &#123; <span class="attr">type</span>: <span class="title class_">String</span> &#125;,</span><br><span class="line">  <span class="attr">avatar</span>: &#123; <span class="attr">type</span>: <span class="title class_">String</span> &#125;,</span><br><span class="line">  <span class="attr">position</span>: &#123; <span class="attr">type</span>: <span class="title class_">String</span> &#125;, <span class="comment">// 职位信息</span></span><br><span class="line">  <span class="attr">personalInfo</span>: &#123; <span class="attr">type</span>: <span class="title class_">String</span> &#125;, <span class="comment">// 个人信息、职位要求</span></span><br><span class="line">  <span class="attr">companyInfo</span>: &#123; <span class="attr">type</span>: <span class="title class_">String</span> &#125;,</span><br><span class="line">  <span class="attr">salary</span>: &#123; <span class="attr">type</span>: <span class="title class_">String</span> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> chatSchema = mongoose.<span class="title class_">Schema</span>(&#123;</span><br><span class="line">  <span class="attr">from_id</span>: &#123; <span class="attr">type</span>: <span class="title class_">String</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;, <span class="comment">// 消息的发起者的用户id</span></span><br><span class="line">  <span class="attr">to_id</span>: &#123; <span class="attr">type</span>: <span class="title class_">String</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;, <span class="comment">// 消息的接受者的用户id</span></span><br><span class="line">  <span class="attr">chat_id</span>: &#123; <span class="attr">type</span>: <span class="title class_">String</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;, <span class="comment">// 消息的聊天室id</span></span><br><span class="line">  <span class="attr">content</span>: &#123; <span class="attr">type</span>: <span class="title class_">String</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  <span class="attr">hasRead</span>: &#123; <span class="attr">type</span>: <span class="title class_">Boolean</span>, <span class="attr">default</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">  <span class="attr">create_time</span>: &#123; <span class="attr">type</span>: <span class="title class_">String</span> &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">saveTest</span> () &#123;</span><br><span class="line">  <span class="keyword">const</span> userModel = <span class="keyword">new</span> <span class="title class_">UserModel</span>(&#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">    <span class="attr">password</span>: <span class="title function_">md5</span>(<span class="string">&#x27;654321&#x27;</span>),</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;jobSeeker&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  userModel.<span class="title function_">save</span>(<span class="function">(<span class="params">err, userDoc</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(userDoc)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">saveTest</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试查询数据，一个或多个</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findTest</span> () &#123;</span><br><span class="line">  <span class="title class_">UserModel</span>.<span class="title function_">find</span>(<span class="function">(<span class="params">err, usersDocArr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(usersDocArr)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="title class_">UserModel</span>.<span class="title function_">findOne</span>(&#123; <span class="attr">_id</span>: <span class="string">&#x27;5f32912c5a24d012779cf1ea&#x27;</span> &#125;,</span><br><span class="line">    <span class="function">(<span class="params">err, userDoc</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(userDoc)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">findTest</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateTest</span> () &#123;</span><br><span class="line">  <span class="title class_">UserModel</span>.<span class="title function_">findByIdAndUpdate</span>(</span><br><span class="line">    &#123;<span class="attr">_id</span>: <span class="string">&#x27;5f329d9fb913dd12e4d67a0a&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">username</span>: <span class="string">&#x27;test-update&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">useFindAndModify</span>:<span class="literal">false</span>&#125;,</span><br><span class="line">    <span class="function">(<span class="params">err,oldUserDoc</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(oldUserDoc)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">updateTest</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deleteTest</span> () &#123;</span><br><span class="line">  <span class="title class_">UserModel</span>.<span class="title function_">deleteOne</span>( <span class="comment">// 这里官方建议使用deleteOne() 和 deleteMany()</span></span><br><span class="line">    &#123;<span class="attr">_id</span>: <span class="string">&#x27;5f329d9fb913dd12e4d67a0a&#x27;</span>&#125;,</span><br><span class="line">    <span class="function">(<span class="params">err,delInfo</span>) =&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(delInfo)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">deleteTest</span>()</span><br><span class="line"><span class="comment">// 在删除之后返回的对象格式为&#123; n: 1, ok: 1, deletedCount: 0 &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> MongoDB </tag>
            
            <tag> mongoose </tag>
            
            <tag> NodeJs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用jQuery简单实现网页图片懒加载</title>
      <link href="/2023/07/24/img-lazy-loading/"/>
      <url>/2023/07/24/img-lazy-loading/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间看到过一个面试题：</p><blockquote><p>一个页面上有大量的图片（大型电商网站），加载很慢  ，你有哪些方法优化这些图片的加载，给用户更好的体验？</p></blockquote><p>第一个想到的就是用图片懒加载，但学了这么久JS，在之前做项目时，许多库与插件都自带图片懒加载，就比如说Hexo框架搭建的博客，</p><p>但具体实现，经过一番思考，其实很简单</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这里我们使用H5的自定义属性：data-xxx 存储图片url</p><p>将所有图片的url存储在自定义属性中，使用JS监听滚动条事件，并判断每一个图片与浏览器窗口以及滚动条卷去的距离，当<code>&lt;img&gt;</code>标签符合出现在视口的条件时，将存储在自定义属性中的url赋给其<code>src</code>属性（为了简单起见，就不做节流处理了）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//  需要将所有图片的url放在其data-img-url自定义属性中，</span></span><br><span class="line">    <span class="comment">//  在页面打开的时候变量所有img，并判断他们是否在视口当中，有，则将url放入src中</span></span><br><span class="line">    $(<span class="string">&#x27;img&#x27;</span>).<span class="title function_">each</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isShow</span>($(<span class="variable language_">this</span>)) &amp;&amp; !<span class="title function_">isLoaded</span>($(<span class="variable language_">this</span>))) &#123;</span><br><span class="line">        <span class="comment">//加载当前img</span></span><br><span class="line">        <span class="title function_">loadImg</span>($(<span class="variable language_">this</span>))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    $(<span class="variable language_">window</span>).<span class="title function_">on</span>(<span class="string">&#x27;scroll&#x27;</span>,<span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="comment">//滚动的触发事件</span></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).<span class="title function_">each</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="comment">//遍历img标签</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isShow</span>($(<span class="variable language_">this</span>)) &amp;&amp; !<span class="title function_">isLoaded</span>($(<span class="variable language_">this</span>)) )&#123;</span><br><span class="line">          <span class="title function_">loadImg</span>($(<span class="variable language_">this</span>));<span class="comment">//加载当前img</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">checkShow</span>(<span class="params">$img</span>) &#123; <span class="comment">// 传入img对象</span></span><br><span class="line">      <span class="keyword">const</span> scrollTop = $(<span class="variable language_">window</span>).<span class="title function_">scrollTop</span>()  <span class="comment">// 获取卷去的距离</span></span><br><span class="line">      <span class="keyword">const</span> windowHeight = $(<span class="variable language_">window</span>).<span class="title function_">height</span>() <span class="comment">// 获取浏览器自身的高度</span></span><br><span class="line">      <span class="keyword">const</span> offsetTop = $img.<span class="title function_">offset</span>().<span class="property">top</span>  <span class="comment">//目标标签img相对于document顶部的位置</span></span><br><span class="line">      <span class="comment">// 如果图片的头部出现在了视口底部或者图片的完整地出现在了视口顶部</span></span><br><span class="line">      <span class="keyword">return</span> offsetTop &lt; (scrollTop + windowHeight) &amp;&amp; offsetTop &gt; scrollTop</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果data-img-url和src相同那么就是已经加载了图片</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">isLoaded</span> ($img) &#123;</span><br><span class="line">      <span class="keyword">return</span> $img.<span class="title function_">attr</span>(<span class="string">&#x27;data-img-url&#x27;</span>) === $img.<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把自定义属性中存放的真实的src地址赋给src属性</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">loadImg</span> ($img) &#123;</span><br><span class="line">      $img.<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>,$img.<span class="title function_">attr</span>(<span class="string">&#x27;data-img-url&#x27;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> jQuery </tag>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了解Git的简单使用</title>
      <link href="/2023/07/24/git/"/>
      <url>/2023/07/24/git/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Git 是Linux之父 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 GitHub 作为全球最知名的代码管理平台  使用 git 分布式版本控制系统，为代码的托管提供了非常便捷的服务</p></blockquote><p>在使用Git之前，需要了解Git系统的相关机制</p><h2 id="3个容器"><a href="#3个容器" class="headerlink" title="3个容器"></a>3个容器</h2><ul><li>工作区 ：<ul><li>当前项目目录 文件分为两种状态： 已跟踪 、 未跟踪</li><li>已跟踪的文件为以及被纳入Git版本库中的文件，具有快照记录，</li><li>已跟踪的文件在一段时候后有 3种 状态： 已提交 、 已修改 、 已暂存</li></ul></li><li>暂存区：<ul><li>当生成Git对象后，从Git版本库中放入Git对象所对应的文件的占存容器</li></ul></li><li>Git版本库：<ul><li>Git对象的直接存储容器</li></ul></li></ul><h2 id="3个对象"><a href="#3个对象" class="headerlink" title="3个对象"></a>3个对象</h2><ul><li><p>Git对象(blob)</p><p>将目标文件一git对象的方式存储于Git版本库的objects中，使用hash算法生成一个唯一的SHA-1值来标识当前文件的Git对象.        </p></li><li><p>树对象(tree)</p><p>将多个Git对象（一个项目版本的多个文件）对应的SHA-1索引生成一个树对象，记录文件的层次结构</p></li><li><p>提交对象(commit)</p><p>将一个树对象以及上一个commit对象使用注释打包(标明当前提交信息：时间、地点、人物)，</p></li></ul><h2 id="Git-基本操作流程"><a href="#Git-基本操作流程" class="headerlink" title="Git 基本操作流程"></a>Git 基本操作流程</h2><ul><li>初始化git： </li></ul><blockquote><p>git init</p></blockquote><ul><li>选择文件生成Git对象：</li></ul><blockquote><p>git add ./</p></blockquote><ul><li>将对应文件生成Git对象，并保存到Git版本库(只要工作区中的文件被修改过，就会生成新的Git对象)：</li></ul><blockquote><p>git hash-object -w 文件名   </p></blockquote><ul><li>将更新后的Git对象(多个)放入暂存区：</li></ul><blockquote><p>git update-index </p></blockquote><ul><li>生成一个树对象，并生成一个commit对象并提交：</li></ul><blockquote><p>git commit -m “注释内容”</p></blockquote><ul><li><p>上面的命令执行与下面两句命令执行等效：</p><ol><li>生成快照： 根据暂存区(index)中的文件SHA-1索引生成树对象，返回生成树对象的SHA-1值，<pre><code>只要文件有改动就会生成新的树对象</code></pre></li></ol><blockquote><p>git write-tree </p></blockquote><ol><li>生成commit对象：</li></ol><blockquote><p>git commit-tree &lt;树对象SHA-1&gt; -p &lt;上一个commit对象SHA-1&gt;</p></blockquote></li></ul><h2 id="Git-高层命令-CRUD"><a href="#Git-高层命令-CRUD" class="headerlink" title="Git 高层命令(CRUD)"></a>Git 高层命令(CRUD)</h2><ul><li>初始化</li></ul><blockquote><p>git init </p></blockquote><ul><li>查看git状态</li></ul><blockquote><p>git statue </p></blockquote><ul><li>查看那些更新还没有被暂存</li></ul><blockquote><p>git diff –cached </p></blockquote><ul><li>查看那些修改 以及 被暂存了未被提交的部分</li></ul><blockquote><p>git diff –staged </p></blockquote><ul><li>将对象提交到暂存区</li></ul><blockquote><p>git add ./ </p></blockquote><ul><li>将暂存区提交到版本库</li></ul><blockquote><p>git commit -m “注释”</p></blockquote><ul><li>直接将工作区中的文件提交到版本库，跳过暂存区</li></ul><blockquote><p>git commit -a  </p></blockquote><ul><li>查看暂存区内容</li></ul><blockquote><p>git ls-files -s </p></blockquote><ul><li>打开提交日志</li></ul><blockquote><p>git log </p></blockquote><ul><li>将文件从工作目录中删除并提交删除状态到暂存区</li></ul><blockquote><p>git rm &lt;文件名&gt;  </p></blockquote><ul><li>将文件从工作目录中 移动 或者 重命名 并提交修改状态到暂存区</li></ul><blockquote><p>git mv &lt;文件名&gt;   </p></blockquote><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>改变指向最新提交对象的指针</p><ul><li>不加参数，得到分支列表</li></ul><blockquote><p>git branch </p></blockquote><ul><li>分支名 ： 在当前的提交对象上，创建一个可移动的新指针，创建后不会自动切换到新指针上</li></ul><blockquote><p>git branch </p></blockquote><ul><li>新建一个分支并指向指定的提交对象</li></ul><blockquote><p>git branch &lt;分支名&gt; &lt;commit对象SHA-1&gt; ： </p></blockquote><ul><li>查看每个分支的最后一次提交</li></ul><blockquote><p>git branch -v </p></blockquote><ul><li>将HEAD指针切换到新分支上</li></ul><blockquote><p>git checkout &lt;分支名&gt; ： </p></blockquote><ul><li>新建一个分支，并切换到这个分支</li></ul><blockquote><p>git checkout -b &lt;分支名&gt;</p></blockquote><ul><li>强制删除分支，不能直接删除当前所在的分支，需要切换到其他分支</li></ul><blockquote><p>git branch -D &lt;分支名&gt; ： </p></blockquote><ul><li><p>合并分支:</p><ul><li><p>快进合并：</p><blockquote><p>git merge 分支名 </p></blockquote></li></ul></li></ul><blockquote><p> 如果当前分支和将要合并的分支处于同一分支线上(父子或祖孙关系)，则启用快速合并<br> 将master指向合并的分支上需要切回需要合并的分支，再执行合并.<br> 执行后主分支(master)会和新分支指向同一个commit 且 之前主分支指向的commit会得以保留</p></blockquote><ul><li><p>典型合并：</p><ul><li>如果当前分支和将要合并的分支没有处于同一分支线上，则启用典型合并，Git需要做额外工作</li></ul></li></ul><blockquote><p> 注意:<br> 切换分区所改变的 对象： HEAD 指针 、  暂存区 、 工作目录<br> 切换分支会改变当前工作目录中的内容，所以每次在切换分支之前最好提交当前分支<br> 在切换分支时，如果当前分支有未跟踪的文件，则分支可以切换成功<br> 未跟踪或未提交的文件在切换分支后得以保留，但可能会污染分支<br> 文件被改动后未提交 ，则切换分支不会成功  </p></blockquote><h2 id="Git-存储"><a href="#Git-存储" class="headerlink" title="Git 存储"></a>Git 存储</h2><p>如果不想当前工作仅仅做了一半而提交，然后切换分支的话，Git存储命令会帮助储存当前未提交的文件(被改动的)</p><ul><li><p>将未提交的修改保存到一个栈上</p><blockquote><p>git stash </p></blockquote></li><li><p>查看栈中存储的文件</p><blockquote><p>git stash list </p></blockquote></li><li><p>从栈中指定位置恢复文件，如果不指定位置默认为栈顶，而且不会删除栈中文件</p><blockquote><p> git stash apply &lt;栈号(可选)&gt;</p></blockquote></li><li><p>立即弹出栈顶的文件到工作区，并且将那个文件从栈中删除</p><blockquote><p>git stash pop</p></blockquote></li><li><p>删除栈中指定的位置的文件</p><blockquote><p>git stash drop &lt;栈号&gt; </p></blockquote></li></ul><h2 id="Git-撤回提交"><a href="#Git-撤回提交" class="headerlink" title="Git 撤回提交"></a>Git 撤回提交</h2><ul><li><p>工作区：</p><ul><li><p>撤回工作目录中的刚刚保存的文件</p><blockquote><p>git checkout -&lt;要撤回修改的文件名&gt;</p></blockquote></li></ul></li><li><p>暂存区：</p><ul><li><p>撤回暂存区中刚刚放入的文件</p><blockquote><p>git reset HEAD &lt;暂存区中要撤回的文件名&gt;</p></blockquote></li></ul></li><li><p>版本库：</p><ul><li><p>撤销提交了的commit对象(因为提交内容有误，注释写错等)</p><blockquote><p>git commit –amend  </p></blockquote><ul><li>撤销上一次提交，回到写入注释的地方，重新提交当前暂存区的内容，<br>可使用:q! 退出注释，然后重新进行提交</li></ul></li></ul></li></ul><h2 id="Git-撤回分支"><a href="#Git-撤回分支" class="headerlink" title="Git 撤回分支"></a>Git 撤回分支</h2><ul><li><p>携带撤回到某一个分支</p><blockquote><p>git reset –soft &lt;提交对象SHA-1&gt;  </p></blockquote><ul><li>移动HEAD指向的提交对象 ,会携带分支一起移动，</li><li>本质上是撤销了上一次的commit命令,但是重新提交后，错误的提交对象不会被删除，</li><li>这个命令只更改HEAD以及分支指向的commit对象,不会修改工作区和暂存区的内容  </li></ul></li><li><p>携带暂存区，撤回到某一个分支</p><blockquote><p>git reset –mixed &lt;提交对象SHA-1&gt; :  </p></blockquote><ul><li>和上个命令相似 ，不仅更改HEAD以及分支指向的commit对象，而且会将暂存区修改为当前HEAD指向的commit </li></ul></li><li><p>携带工作目录、暂存区，撤回到某一个分支</p><blockquote><p>git reset –hard  &lt;提交对象SHA-1&gt;</p></blockquote><ul><li>撤销最后的提交，并将 暂存区和工作区 修改为当前HEAD指向的commit对象(不推荐)</li></ul></li></ul><h2 id="使用Github远程仓库"><a href="#使用Github远程仓库" class="headerlink" title="使用Github远程仓库"></a>使用Github远程仓库</h2><blockquote><p> 远程仓库是指托管在因特网或其他网络中的你的项目的版本库。你可以有好几个远程仓库，<br> 通常有些仓库对你只读，有些则可以读写。</p></blockquote><h2 id="多人远程协作基本流程"><a href="#多人远程协作基本流程" class="headerlink" title="多人远程协作基本流程"></a>多人远程协作基本流程</h2><ul><li><p>项目经理操作</p><ol><li><p>使用命令创建本地仓库</p></li><li><p>为远程仓库配置别名 和 用户信息</p><ul><li><p>添加一个新的远程Git仓库，将次仓库设置一个别名：</p><blockquote><p>git remote add &lt;仓库别名&gt; url</p></blockquote></li><li><p>查看 远程仓库别名 对应的URL：</p><blockquote><p>git remote –v</p></blockquote></li><li><p>查看某一个远程仓库的更多信息：</p><blockquote><p>git remote show &lt;仓库别名&gt;</p></blockquote></li><li><p>重命名仓库别名：</p><blockquote><p>git remote rename &lt;仓库别名&gt; &lt;新别名&gt;</p></blockquote></li><li><p>应为某种原因，要移除一个远程仓库：</p><blockquote><p>git remote rm &lt;仓库别名&gt;</p></blockquote></li></ul></li><li><p>推送本地项目到远程仓库</p><ul><li><p>推送分支到远程仓库：</p><blockquote><p>git push &lt;仓库别名&gt; &lt;分支名&gt;</p></blockquote><p>在推送分支到远程仓库后，本地仓库默认会生成 红色标注 的远程跟踪分支</p></li></ul></li><li><p>获取成员提交的新内容到本地</p><ul><li>同步新数据到本地：<blockquote><p>git fetch &lt;仓库别名&gt;</p></blockquote></li></ul></li><li><p>获取成员提交的新内容到本地</p><ul><li><p>同步新数据到本地：</p><blockquote><p>git fetch &lt;仓库别名&gt;</p></blockquote></li></ul></li></ol></li><li><p>项目成员操作</p><ol><li><p>成员在工作目录中使用git配置自己的用户信息</p><ul><li><p>配置当前 工作目录 下的 用户名(name)以及邮箱(Email):</p><blockquote><p>git config user.name &lt;用户名&gt;<br>git config user.email &lt;邮箱&gt;</p></blockquote></li><li><p>删除配置的默认用户信息：</p><blockquote><p>git config –global –unset user.name<br>git config –global –unset user.email</p></blockquote></li></ul></li><li><p>成员克隆远程仓库到本地</p><ul><li><p>克隆远程仓库(将远程仓库同步到本地),不需要初始化git<br>克隆到本地的仓库别名默认为Origin</p><blockquote><p>git clone url</p></blockquote></li><li><p>修改默认远程仓库名： </p><blockquote><p>git clone -o &lt;自定义仓库名&gt;      </p></blockquote></li></ul></li><li><p>成员推送提交到远程仓库：</p><ul><li><p>推送分支到远程仓库（需要成员在Github上拥有远程仓库的写入权限，并且当前分支没有被推送过）</p><blockquote><p>git push &lt;仓库别名&gt; &lt;本地分支名&gt;  </p></blockquote></li></ul></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 版本控制系统 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端常见面试题汇总</title>
      <link href="/2023/07/24/interview/"/>
      <url>/2023/07/24/interview/</url>
      
        <content type="html"><![CDATA[<blockquote><p>简单总结前端热门面试题要点</p></blockquote><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>HTML5 技术栈</p><ul><li>语义化标签类</li><li>音视频处理</li><li>Canvas 、 webGL</li><li>history API</li><li>requestAnimationFrame</li><li>地理位置</li><li>webSocket(直播)</li></ul><p>CSS3 </p><ul><li>常规</li><li>动画</li><li>盒子模型</li><li>响应式布局</li></ul><p>JavaScript</p><ul><li>ES 6-11</li><li>DOM</li><li>BOM</li><li>设计模式</li><li>底层原理<ul><li>堆栈内存</li><li>闭包作用域 AO/VO/GO/EC/ECSTACK</li><li>面向对象</li><li>this</li><li>事件循环</li><li>浏览器渲染原理</li><li>回流重绘</li></ul></li></ul><p>网络通信</p><ul><li>AJAX / Fetch / axios</li><li>HTTP协议 1.0 、 2.0</li><li>TCP</li><li>跨域处理方案</li><li>性能优化</li></ul><p>Hybrid 或者 APP 和 小程序</p><ul><li>Hybrid</li><li>uni-app (Vue)</li><li>React Native</li><li>Weex</li><li>PWA</li></ul><p>前端工程化</p><ul><li>webpack</li><li>git</li><li>linux </li><li>nginx</li></ul><p>React</p><ul><li>基础知识</li><li>核心原理</li><li>react-router-dom</li><li>redux</li><li>react-redux</li><li>dva</li><li>umi</li><li>antd</li><li>SSR</li><li>优化</li><li>…..</li></ul><p>全栈</p><ul><li>NodeJs</li></ul><h1 id="H5-CSS面试题"><a href="#H5-CSS面试题" class="headerlink" title="H5 /CSS面试题"></a>H5 /CSS面试题</h1><h2 id="什么是标签语义化？"><a href="#什么是标签语义化？" class="headerlink" title="什么是标签语义化？"></a>什么是标签语义化？</h2><p>   简单的来说，H5标签语义化就是将标签名与其功能联系在一起，例如header负责显示网页头部  footer负责显示网页尾部 等，让合适的标签干合适的事情</p><h2 id="总结H5标签"><a href="#总结H5标签" class="headerlink" title="总结H5标签"></a>总结H5标签</h2><p>   H5标签分为3类，</p><p>   可以使用 display: block/inline-block/inline/none/table/flex 进行转换</p><ul><li><p>块级标签</p><ul><li><code>div p h1-h6 ol ul dl li form table hr pre</code>(格式预处理标签)</li><li>H5 新增 <code>header footer main</code>(网页主体) <code>article</code>(文章内容) <code>section</code> <code>figure</code>(图片相关信息的容器) figcaption(图片描述) nav</li><li>独占一行，</li><li>元素的宽度和高度，行高可设置</li><li>支持所有css样式</li></ul></li><li><p>行内标签</p><ul><li><code>span a br i em strong</code> <code>sub</code>(上标) <code>sup</code>(下标) <code>lable</code> <code>code</code>(代码块)</li><li>不会独占一行</li><li>宽高与内外边距不可设置，内容决定宽高</li><li>设置为行内块元素则可以设置宽高</li></ul></li><li><p>行内块元素</p><ul><li><code>img</code> <code>input</code> </li><li>不独占一行，且宽高边距均可设置</li></ul><p>标签之间的嵌套规则</p></li><li><p>行内标签不能嵌套行内标签</p></li><li><p>行内标签不能嵌套块级标签</p></li><li><p>ol ul 的直接子级一定是li</p></li></ul><h2 id="总结有哪些隐藏元素的方法"><a href="#总结有哪些隐藏元素的方法" class="headerlink" title="总结有哪些隐藏元素的方法"></a>总结有哪些隐藏元素的方法</h2><ul><li><code>display : none</code></li><li><code>visibility : hidden</code></li><li><code>height : 0 </code> </li></ul><h2 id="css如何实现水平垂直居中-5种"><a href="#css如何实现水平垂直居中-5种" class="headerlink" title="css如何实现水平垂直居中(5种)"></a>css如何实现水平垂直居中(5种)</h2>   <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">position</span>:absolute;</span><br><span class="line"><span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line"><span class="attribute">left</span>:<span class="number">50</span>;</span><br><span class="line"><span class="attribute">margin-left</span>:-<span class="number">50%</span>;</span><br><span class="line"><span class="attribute">margin-top</span>:-<span class="number">50%</span></span><br></pre></td></tr></table></figure>   <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">position</span>:absolute;</span><br><span class="line"><span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line"><span class="attribute">left</span>:<span class="number">50</span>;</span><br><span class="line"><span class="attribute">transform</span>:<span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br></pre></td></tr></table></figure>   <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*元素必须拥有宽高*/</span> </span><br><span class="line"><span class="attribute">position</span>:absolute;</span><br><span class="line"><span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line"><span class="attribute">right</span>:<span class="number">0</span>;</span><br><span class="line"><span class="attribute">bottom</span>:<span class="number">0</span>;</span><br><span class="line"><span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line"><span class="attribute">margin</span>:auto;</span><br></pre></td></tr></table></figure>   <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*父级设置*/</span></span><br><span class="line"><span class="attribute">display</span>:flex;</span><br><span class="line"><span class="attribute">justify-content</span>:center;</span><br><span class="line">align-item:center;</span><br></pre></td></tr></table></figure>   <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*父级设置*/</span></span><br><span class="line"><span class="attribute">display</span>: table-cell;</span><br><span class="line"><span class="attribute">text-align</span>:center;</span><br><span class="line"><span class="attribute">vertical-align</span>:middle</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="position-对应的效果和用法"><a href="#position-对应的效果和用法" class="headerlink" title="position 对应的效果和用法"></a>position 对应的效果和用法</h2><ul><li><p><code>static</code>  默认定位属性，按照常规文档流布局，此时 <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> 和 <code>z-index </code>属性无效。</p></li><li><p><code>relative</code>  定位在当前所在位置，且以当前位置为原点进行移动</p></li><li><p><code>absolute</code>  元素被移出正常文档流，相对于最近的非static定位的祖先进行定位</p></li><li><p><code>fixed</code> 元素被移出正常文档流，且元素相对于视口进行定位，会创建新的<strong>层叠上下文</strong></p></li><li><p><code>sticky/-webkit-sticky</code> 将元素固定在一个具有滚动属性的祖先上创建一个新的<strong>层叠上下文</strong></p><p>如果<code>top</code>和<code>bottom</code>都被指定，那么<code>top</code>优先，如果<code>left</code>和<code>right</code>都被指定，如果文字方向从左到右，<code>left</code>优先，反之亦然</p></li></ul><h2 id="css-选择器优先级"><a href="#css-选择器优先级" class="headerlink" title="css 选择器优先级"></a>css 选择器优先级</h2><p>   优先级就是分配给指定的 CSS 声明的一个权重，它由 匹配的选择器中的 <strong>每一种选择器类型的</strong> 数值 决定。</p><p>   而当优先级与多个 CSS 声明中任意一个声明的优先级相等的时候，CSS 中最后的那个声明将会被应用到元素上。</p><p>   所以当同一个元素有多个声明的时候，优先级才会有意义。</p><ul><li><p>通配选择器、关系选择器、否定选择器 0000，即对优先级无影响</p></li><li><p>元素(标签)选择器 0001</p></li><li><p>类选择器 0010</p></li><li><p>ID选择器 0100</p></li><li><p>内联样式 1000 ，最高优先级</p><p>尽少使用<code>!important</code> ，因为它与优先级不相关，与最终结果有关，使用<code>!important</code> 破坏了样式表级联规则，当2条 不同优先级的样式均带有<code>!important</code> 时，优先级大的任然被采用</p><blockquote><p><strong>一些经验法则：</strong></p><ul><li><strong>一定</strong>要优化考虑使用样式规则的优先级来解决问题而不是 <code>!important</code></li><li><strong>只有</strong>在需要覆盖全站或外部 CSS 的特定页面中使用 <code>!important</code></li><li><strong>永远不要</strong>在你的插件中使用 <code>!important</code></li><li><strong>永远不要</strong>在全站范围的 CSS 代码中使用 <code>!important</code></li></ul></blockquote></li></ul><h2 id="盒子模型有哪些"><a href="#盒子模型有哪些" class="headerlink" title="盒子模型有哪些"></a>盒子模型有哪些</h2><ul><li><p>标准盒模型 content-box : </p><p>盒子的总体宽高是由 border+padding+设置的content 宽和高决定的，这样的盒模型在布局时，例如居中或者对齐，可能需要精确计算内容、边框、padding的大小，使得开发效率并不是很高</p></li><li><p>怪异盒模型 border-box ：</p><p>​    这种设置这种盒模型的块级元素的宽和高一般不受内边距影响，border+padding+content宽高始终等于设置的宽高值，大多数布局框架中基本以怪异盒模型为标准</p></li><li><p>弹性盒模型 flex：</p><p><img src= "/img/loading.gif" data-lazy-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png" alt="img"></p><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。</p><ul><li><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p></li><li><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code></p></li><li><p><code>align-content</code>属性定义了多根 <strong>主轴线</strong> 在<strong>交叉轴</strong> 上的对齐方式，需要开启换行<code>flex-wrap:wrap</code>如果项目只有一根轴线，该属性不起作用。</p></li><li><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的内容大小。</p></li><li><p><code>flex</code>声明在项目上 ， <code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选，通常使用<code>flex: 1</code>，它等同于：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">flex-grow</span>: <span class="number">1</span>;  元素增长比例为<span class="number">1</span></span><br><span class="line"><span class="attribute">flex-shrink</span>: <span class="number">1</span>; 元素缩小比例为<span class="number">1</span></span><br><span class="line"><span class="attribute">flex-basis</span>: <span class="number">0%</span>; 元素没有定宽，的宽度将填充并均分剩余空间，当宽度不够时最小可以被压缩到<span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li><p>第一个参数表示: <strong>flex-grow 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大</strong></p></li><li><p>第二个参数表示: <strong>flex-shrink 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小</strong></p></li><li><p>第三个参数表示: <strong>flex-basis</strong></p><ul><li><code>auto</code>：首先检索该子元素的主尺寸，如果主尺寸不为 <code>auto</code>，则使用值采取主尺寸之值；如果也是 <code>auto</code>，则使用值为 <code>content</code>。</li><li>百分比：根据其包含块（即伸缩父容器）的主尺寸计算。如果包含块的主尺寸未定义（即父容器的主尺寸取决于子元素），则计算结果和设为 <code>auto</code> 一样。<strong>百分比定义了当前的元素占用主轴空间的百分比，此时元素的width/height不起作用，所有值均由 flex-basis计算</strong></li></ul></li></ul></li><li><p>align-self 属性 设置在项目上，覆盖父级的align-items，独立管理交叉轴对齐方式</p></li></ul></li></ul><h2 id="经典布局类型有哪些"><a href="#经典布局类型有哪些" class="headerlink" title="经典布局类型有哪些"></a>经典布局类型有哪些</h2><ol><li>圣杯布局：从上到下，分为header main footer 三部分，其中main分为left center right 从左向右，三部分</li><li>双飞翼布局：从左向右，分为left center right 三部分，其中left和right可有可无，不会影响center部分</li></ol><h2 id="移动端响应式布局方案"><a href="#移动端响应式布局方案" class="headerlink" title="移动端响应式布局方案"></a>移动端响应式布局方案</h2><ol><li>media 媒介查询</li><li>rem单位</li><li>flex</li><li>vh / vw 视窗高度、宽度</li></ol><h2 id="z-index的工作原理"><a href="#z-index的工作原理" class="headerlink" title="z-index的工作原理"></a>z-index的工作原理</h2><p>   默认值auto，值越大，层级越高，谁后渲染，谁谁层级越高</p><ol><li><p>建立新的文档流</p></li><li><p>只对具有定位(r a f sticky)的元素有作用 </p></li><li><p>内联元素会覆盖浮动元素</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/EricReevess/proxy/master/img/image-20200711113458770.png" alt="z-index"></p></li></ol><h2 id="脱离文档流的方式："><a href="#脱离文档流的方式：" class="headerlink" title="脱离文档流的方式："></a>脱离文档流的方式：</h2><ol><li>浮动</li><li>定位</li><li>transform</li></ol><h2 id="CSS读取机制"><a href="#CSS读取机制" class="headerlink" title="CSS读取机制:"></a>CSS读取机制:</h2><p>选择器从右向左读取</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 先查找所有的a标签 ，再查找所有在.box下的a标签 */</span></span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-tag">a</span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><ul><li><p>BFC(Block formatting context), 块级别格式化上下文，一个独立的渲染区域，只有块级的元素参与，内部规定其如何布局，而且这个区域不影响外部区域,</p></li><li><p>BFC是CSS中元素的一个隐含的属性，可以为一个元素开启BFC</p></li><li><p>BFC布局规则</p><ul><li>开启BFC的元素不会被float元素所覆盖,且可以包裹float元素</li><li>开启BFC的父元素的外边距不会与子元素重叠(不会因为子元素的外边距改变父元素位置)</li><li>BFC就是页面上一个隔离的独立容器，容器子元素不会影响容器外部的其他元素</li><li>内部的Box会在垂直方向，一个接一个排布</li><li>BFC的区域不会与float的元素的margin重叠</li><li>内部box的垂直方向间距由margin 确定，且相邻的margin 会发生重叠</li><li>计算BFC高度时，浮动box参与计算</li></ul></li><li><p>BFC特性</p><ul><li>一个开启BFC的块级元素的<strong>下边距</strong>会与另一个开启BFC的块级元素的<strong>上边距</strong>重叠，最终间距为最大的上/下边距的值</li><li>解决子元素浮动后，父级元素高度塌陷问题 ，开启BFC可让 父元素内部子元素进行浮动排列，并且撑开父级元素的高度</li></ul></li><li><p>如何BFC的开启</p><ul><li><p>根元素是默认开启BFC的</p></li><li><p>开启浮动float(失去指定宽度)</p></li><li><p>clear:left / right / both  (开启后浏览器默认为元素添加外边距) </p></li><li><p>position 为绝对定位：absolute 或 fixed</p></li><li><p>overflow 不为 visible时 ：auto 、hidden (常用方式)</p></li><li><p>display 为 inline-block , table-cell , table-caption , flex , inline-flex</p></li><li><p>使用::after伪类(完美方案)</p><ul><li><pre><code class="css">.box::after &#123;    content: &quot;&quot;;      使其最后元素内容为空    display: block;   默认为行内元素，不独占一行，所以使其独占一行    clear: both;        清除浮动，完成效果&#125;  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 或者将其::after 和 ::before 生成一个类.clearfix ,同时解决：高度塌陷和外边距重叠</span><br><span class="line"></span><br><span class="line">```css</span><br><span class="line">.clearfix::after,.clearfix::before&#123;</span><br><span class="line">    content: &quot;&quot;;</span><br><span class="line">    display: table;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li></ul><h1 id="JavaScript面试题"><a href="#JavaScript面试题" class="headerlink" title="JavaScript面试题"></a>JavaScript面试题</h1><h2 id="三大模块"><a href="#三大模块" class="headerlink" title="三大模块"></a>三大模块</h2><ul><li>堆栈内存以及闭包作用域</li><li>面向对象和this处理</li><li>DOM / BOM / 事件处理机制</li></ul><h2 id="堆栈内存以及闭包作用域"><a href="#堆栈内存以及闭包作用域" class="headerlink" title="堆栈内存以及闭包作用域"></a>堆栈内存以及闭包作用域</h2><ol><li>JS的有那些数据类型，分别是？ 有基本数据类型和引用数据类型<ul><li>基本数据类型<ol><li>Number</li><li>String</li><li>Boolean</li><li>undefined</li><li>null</li><li>Symbol(ES6)</li></ol></li><li>引用数据类型<ol><li>Object</li><li>Function</li></ol></li></ul></li><li>栈中的变量是存储的是对象在堆内存中的地址</li></ol><h3 id="JS全局对象与活动对象"><a href="#JS全局对象与活动对象" class="headerlink" title="JS全局对象与活动对象"></a>JS全局对象与活动对象</h3><ul><li>JavaScript 预解析AO 、GO<ul><li>AO(Activation Object)，活动对象、执行期上下文、也叫函数的局部作用域<ul><li>在JS函数预解析时，先创建对象AO{} ,</li><li>先将形参与内部声明的变量加入到AO对象属性中，并赋值，再寻找函数声明，例如函数中的<code>let const var</code> 声明的变量</li></ul></li><li>GO(Global Object)，全局对象，GO对象就等于window对象<ul><li>在window下预解析的时候，创建GO{}，</li><li>先解析变量，再解析函数  </li></ul></li></ul></li></ul><h3 id="js引擎解析代码流程"><a href="#js引擎解析代码流程" class="headerlink" title="js引擎解析代码流程"></a>js引擎解析代码流程</h3><ul><li>进入执行环境（栈），这里我们将js的整个文件当做一个函数</li><li>创建变量对象：<ul><li>变量</li><li>函数以及参数</li><li>全局对象：浏览器中则是window</li><li>局部变量：被当做字符串，以抽象形式存在</li></ul></li><li>确认全局this指向<ul><li>全局的this 指向 <code>window</code></li><li>局部 this 指向 被调用的对象</li></ul></li><li>创建作用域链<ul><li>父级作用域链 + 当前的活动对象</li></ul></li></ul><ol><li><p>基本数据类型存放在栈中，存放实际数值，引用数据类型的数据结构存放在堆中，栈中存放其在堆中的地址</p></li><li><p>对于对象来说，所有对象的键<code>key</code>均为String类型（undefined除外）</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj =&#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">name</span>:<span class="string">&quot;123&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> b = &#123;<span class="attr">haha</span>:<span class="string">&quot;456&quot;</span>&#125;;</span><br><span class="line">obj[a] = <span class="number">100</span>;</span><br><span class="line">obj[b] = <span class="number">200</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj[b]) <span class="comment">// 输出 ？ 200</span></span><br></pre></td></tr></table></figure><ul><li>当均为引用类型的a和b 被当做键<code>key</code>时，JS引擎默认将a和b进行一次字符串转换：<code>a.toString() b.toString()</code>均得到<code>[object  Object] </code> 这一相同的字符串</li><li>alert()弹出的内容均会被转换成字符串</li></ul></li><li><p>Execution Context Stack 执行上下文栈：当函数执行时，创建一个执EC Stack</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;      </span><br><span class="line">b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params">a</span>)&#123;</span><br><span class="line">    A = <span class="keyword">function</span>(<span class="params">b</span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(a + b++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">alert</span>(a++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">A</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title function_">A</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><ul><li>首先声明2个全局变量 a b 均为 0 </li><li>函数A 的内容被放入堆中，内容形式为字符串，栈中A变量为堆中地址</li><li>执行<code>A(1)</code>，此时函数在堆中的代码被放入执行上下文栈<code>ECS</code>中执行，将其中的a形参与A变量进行赋值<ul><li>在ECS中，a获得<code>A(1)</code>的参数值a =1 </li><li>在ECS中执行到A的赋值语句时候，发现当前作用域无A变量，向上域寻找，最终到达window的作用域，将函数A的引用修改为内部的函数，此时A引用了一个新的地址，而这个地址是在<code>ECS</code>中被创建的，此时的<code>ECS</code>不会被销毁因为其中更新了全局变量A的引用，<code>a=1</code> 也得以保留</li><li>再向下执行到<code>alert( a++ )</code>，输出 ‘1’ ，a的值更新为2</li></ul></li><li>执行A(2)的时候，此时A的内的引用地址已经被上次执行修改成为内部的函数</li><li>此时执行新指向的函数，开启新的ESC，其中b = 2 ，alert(a+b++)<code>此此时找到上级ECS作用域的a输出 </code>‘4’` , b在ECS更新为3，然后这个ECS被销毁</li></ul></li></ol><h2 id="深克隆、浅克隆"><a href="#深克隆、浅克隆" class="headerlink" title="深克隆、浅克隆"></a>深克隆、浅克隆</h2><ol><li><p>使用<code>JSON.parse(JSON.stringify(obj))</code>，但只支持克隆<code>number</code> <code>string</code> <code>boolean</code> <code>null</code>数据类型，其余类型均会被转换成{}空对象</p></li><li><p>使用被克隆对象的构造器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!obj) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(obj);</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> <span class="title class_">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(obj);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> newObj = <span class="keyword">new</span> obj.<span class="property">constructor</span>; <span class="comment">//保持与被克隆的obj类型一致，例如保持相同的原型方法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj.<span class="title function_">hasOwnProperty</span>(key))&#123;</span><br><span class="line">            newObj[key] = <span class="title function_">deepClone</span>(obj[key])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="变量提升与构造函数"><a href="#变量提升与构造函数" class="headerlink" title="变量提升与构造函数"></a>变量提升与构造函数</h2><ul><li><p><code>var</code>具有变量提升：意思就是说，在<code>var</code> 声明的变量名与<code>function</code>声明的函数的函数名 相同时，<code>var</code>的变量会替代function</p></li><li><p>在js引擎对代码进行预解析时，<code>var</code>声明的变量会提前被解析，且将其赋值为<code>undefined</code></p></li><li><p>当有多个<code>var</code>的变量名称相同且在声明时赋值时，最后声明并赋值的作为最终值,例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span> ()&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fun a&#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//输出 20 </span></span><br></pre></td></tr></table></figure></li><li><p>如果使用<code>let</code>声明的变量与其他<code>let/var</code> 声明的任何类型的变量名重复，则浏览器抛出异常</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fun a&#x27;</span>)</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    getName = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line">functuion <span class="title function_">getName</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">getName</span>(); <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">getName</span>();<span class="comment">// 4</span></span><br><span class="line"><span class="title class_">Foo</span>().<span class="title function_">getName</span>(); <span class="comment">// 1 执行了Foo，改变了全局的getName</span></span><br><span class="line"><span class="title function_">getName</span>();<span class="comment">// 1 </span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Foo</span>.<span class="title function_">getName</span>(); <span class="comment">// 2 括号比new优先级高，先调用再new</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Foo</span>().<span class="title function_">getName</span>(); <span class="comment">// 3 先执行 new Foo()创建一个实例，再访问实例的getName()，通过原型链查找</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> <span class="title class_">Foo</span>().<span class="title function_">getName</span>(); <span class="comment">// 3 与上调语句相同</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><ul><li>无构造函数</li><li>无原型链</li><li>不能使用<code>new</code>，无法构造对象</li><li>继承父域this且不能被改变</li></ul><h2 id="事件队列、异步的微任务与宏任务"><a href="#事件队列、异步的微任务与宏任务" class="headerlink" title="事件队列、异步的微任务与宏任务"></a>事件队列、异步的微任务与宏任务</h2><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200618180003244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoYW95b3VpcW5n,size_16,color_FFFFFF,t_70" alt="事件队列"></p><ul><li><p>事件循环主线程的执行队列的读取是自动的，在这里异步任务会在Event Table中注册相应的回调函数。当指定的步骤完成了，Event Table会将注册了的回调函数推送到Event Queue，在Event Queue这里进行等待上场。当主线程内的任务执行完毕为空之后，就会到Event Queue读取相应的函数，进入主线程执行。这个过程不断重复构成Event Loop。</p></li><li><p><code>new Promise(()=&gt;&#123;&#125;)</code>为同步函数</p></li><li><p>宏任务：</p><ul><li>宏任务是主流，当开始被执行js文件或者<code>sctipt</code>标签内的代码时，就是开启一个宏任务，在宏任务中执行一条一条的指令</li><li>宏任务可以同时有多个，但会按顺序一个一个执行</li><li>调用<code>setTimeout()</code>、<code>setInterval()</code> 与 Node中的<code>I/O</code>函数 、发送异步请求时，都会创建一个新的宏任务</li></ul></li><li><p>微任务：<code>Promise.then()</code>传入的回调函数、 <code>process.nextTick</code></p></li><li><p>案例1：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;同步-0.1&#x27;</span>)</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;P-1.1&#x27;</span>)</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 新加行</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;P-2.1&#x27;</span>) <span class="comment">// 新加行</span></span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 新加行</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;P-3.1&#x27;</span>) <span class="comment">// 新加行</span></span><br><span class="line">    &#125;) <span class="comment">// 新加行</span></span><br><span class="line">  &#125;) <span class="comment">// 新加行</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;S-1.1&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;P-1.2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;S-1.2&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;同步-0.2&#x27;</span>)</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">同步-0.1</span></span><br><span class="line"><span class="comment">同步-0.2</span></span><br><span class="line"><span class="comment">P-1.1</span></span><br><span class="line"><span class="comment">P-1.2</span></span><br><span class="line"><span class="comment">P-2.1</span></span><br><span class="line"><span class="comment">P-3.1</span></span><br><span class="line"><span class="comment">S-1.1</span></span><br><span class="line"><span class="comment">S-1.2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>案例2：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;同步-0.1&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;S-1.1&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">reslove, reject</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;new Primose&#x27;</span>);</span><br><span class="line">    <span class="title function_">reslove</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;P-1.1&#x27;</span>)</span><br><span class="line">    &#125;)  </span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;P-1.2&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;S-1.2&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;同步-0.2&#x27;</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">new Primose</span></span><br><span class="line"><span class="comment">S-1.1</span></span><br><span class="line"><span class="comment">S-1.2</span></span><br><span class="line"><span class="comment">P-1.1</span></span><br><span class="line"><span class="comment">P-1.2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ol><li><p>先将代码中所有同步任务和异步任务进行扫描</p></li><li><p>将同步任务放入主线程执行</p></li><li><p>将异步任务分为宏任务和微任务进行扫描：微任务进入微任务队列，宏任务进入宏任务队列，扫描完毕后分为以下两个队列：</p><ul><li>宏任务：<code>console.log(&#39;S-1.1&#39;)</code> <code>console.log(&#39;S-1.2&#39;)</code></li><li>微任务：<code>setTimeout(() =&gt; &#123;console.log(&#39;P-1.1&#39;)&#125;)</code>   <code>setTimeout(() =&gt; &#123;console.log(&#39;P-1.1&#39;)&#125;)</code></li></ul></li><li><p>执行当前宏任务中的2个微任务中发现宏任务，将2个宏任务添加到宏任务队列中，</p></li><li><p>此时当前的宏任务中的微任务执行完毕，目前的宏任务队列状态为：</p><ul><li><code>console.log(&#39;S-1.1&#39;)</code> <code>console.log(&#39;S-1.2&#39;)</code> <code>console.log(&#39;P-1.1&#39;)</code> <code>console.log(&#39;P-1.2&#39;)</code></li></ul></li><li><p>执行宏任务队列，得到结果</p></li></ol></li><li><p>DOM操作的同步和异步</p></li><li><p>js里面的Dom操作代码，是同步执行，浏览器进行的Dom渲染，是异步操作。</p><ul><li>浏览器渲染Dom和执行js，同时只能二选一，渲染一次Dom的时机是，当前宏任务和产生的微任务队列</li></ul></li><li><p>案例3：计时器延迟</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;<span class="comment">//在被执行后的20ms，回调进入宏任务队列中</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;,<span class="number">20</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;     <span class="comment">//在被执行后的10ms，回调进入宏任务队列中</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;,<span class="number">10</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&#x27;AA&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;<span class="number">90000000</span> ; i++) &#123; <span class="comment">//在执行完毕后，上面的2个计时器已经结束已经以延迟时间先后顺序进入宏任务队列中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&#x27;AA&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>)</span><br><span class="line">&#125;,<span class="number">8</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">7</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">8</span>)</span><br><span class="line">&#125;,<span class="number">15</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">9</span>)</span><br><span class="line"><span class="comment">// 2 4 AA 5 7 9 3 1 6 8</span></span><br></pre></td></tr></table></figure></li><li><p>案例4：async 函数 与 微任务：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 start&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">async2</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 end&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">script start</span></span><br><span class="line"><span class="comment">async1 start</span></span><br><span class="line"><span class="comment">async2</span></span><br><span class="line"><span class="comment">promise1</span></span><br><span class="line"><span class="comment">script end</span></span><br><span class="line"><span class="comment">async1 end</span></span><br><span class="line"><span class="comment">promise2</span></span><br><span class="line"><span class="comment">setTimeout</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>案例5：立即执行函数的this指向：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> y=&#123;</span><br><span class="line">    <span class="attr">x</span>:<span class="number">3</span>,</span><br><span class="line">    <span class="attr">z</span>:(<span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">x</span>*=x</span><br><span class="line">        x+=<span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">x</span>*=n</span><br><span class="line">            x+=<span class="number">3</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(x)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> m = y.<span class="property">z</span>; <span class="comment">//在访问z时，返回一个匿名函数，其中立即执行函数的this指向的是window，同时m保存函数地址，产生闭包</span></span><br><span class="line"><span class="title function_">m</span>(<span class="number">4</span>) <span class="comment">//此时返回的函数被window调用，内部this指向的仍然是window，其中的x为闭包函数中的被形参赋值的变量x</span></span><br><span class="line">y.<span class="title function_">z</span>(<span class="number">5</span>) <span class="comment">//属性z与m指向的同一地址，但是调用者不同，</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x,y.<span class="property">x</span>)</span><br></pre></td></tr></table></figure><ul><li>执行<code>var m = y.z;</code> 在访问z时，返回一个匿名函数，其中立即执行函数的this指向的是window，同时m保存函数地址，因为使用到了参数x变量而产生闭包</li><li>执行<code>m(4)</code> ，此时m指向的函数被window调用，内部this指向的仍然是window，其中的x为闭包函数中的被形参赋值的变量x</li><li>执行<code>y.z(5)</code> 属性y的z与m指向的同一地址，但是调用者不同，前者为对象y调用z指向的函数，后者为window调用m指向的函数，所以this指向也不同</li></ul></li></ul><h2 id="JS类型转换"><a href="#JS类型转换" class="headerlink" title="JS类型转换"></a>JS类型转换</h2><blockquote><p>在 JS 中，只有 0，-0，NaN，””，null，undefined 这六个值转布尔值时，结果为 false</p></blockquote><ul><li><p>弱等于</p><ul><li><p><code>Object === 字符串</code> 时对象类型会调用<code>Object.toString()</code>后与字符串比较</p><ul><li>为当前<code>Object</code>重写<code>toString()</code>可得到定制结果</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = ? <span class="comment">//如何编写a使得下面判断语句成立</span></span><br><span class="line"><span class="keyword">if</span>(a === <span class="number">1</span> &amp;&amp; a === <span class="number">2</span> &amp;&amp; a === <span class="number">3</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>改写对象a 的 toString()</p></li><li><p>使用数据劫持<code>Object.defineProperty(window,&#39;a&#39;,&#123;get()&#123;return ...&#125;&#125;)</code></p></li><li><p><code>var a = [1,2,3]; a.toString = a.shift;</code></p></li></ol></li></ul></li><li><p><code>null == undefined</code> 结果为<code>true</code></p></li><li><p><code>NaN == NaN</code> 结果始终为 <code>false</code></p></li><li><p>其他类型比较都转换为数字（数字，数组，布尔值等）</p></li></ul><h2 id="防抖-debounce-与节流-throttle-，闭包经典应用场景"><a href="#防抖-debounce-与节流-throttle-，闭包经典应用场景" class="headerlink" title="防抖(debounce)与节流(throttle)，闭包经典应用场景"></a>防抖(debounce)与节流(throttle)，闭包经典应用场景</h2><ul><li><p><strong>防抖</strong>主要用于防止回调函数在事件连续触发过程中不断调用的问题，浏览器性能有限，让对应高频触发的事件延迟到事件触发结束后的一段时间后执行，即有效得到了最新的结果，又防止了回调函数连续的调用</p></li><li><p>例如：HTML页面滚轮事件，当滚轮滚动页面时，每滚动一个像素就会触发一次页面滚动事件scroll，当有大量计算内容时，可能产生卡顿问题，使用监听防抖模式的回调可以有效解决这个问题：在滚动结束200ms后触发事件回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">debounce</span> = (<span class="params">fn, delay</span>) =&gt; &#123; <span class="comment">// 传入原始回调以及定义的延迟时间，</span></span><br><span class="line">    <span class="comment">// 初始化timer变量  </span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>  </span><br><span class="line">    <span class="comment">// 返回一个函数，制造闭包</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 如果timer变量在下一次触发的时候不为null，那就清除上一次的定时器，并重新进行定时调用</span></span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>) <span class="comment">// 将this指向为外部的this</span></span><br><span class="line">    &#125;,delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onscroll</span> = <span class="title function_">debounce</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span>) <span class="comment">// 输出滚动的距离</span></span><br><span class="line">&#125;,<span class="number">200</span>) <span class="comment">//在滚动结束的0.2秒后调用原回调函数</span></span><br></pre></td></tr></table></figure></li><li><p><strong>节流</strong>的主要功能与防抖类似，但是功能有所区别，节流的目的在于降低回调函数的执行评率，防止事件回调函数执行过快而造成的性能问题</p></li><li><p>例如：当我们在拖动一个HTML元素的时候，想让控制台每隔500ms输出一次元素的偏移量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">throttle</span> = (<span class="params">fn, interval</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 设置一个可用标志位valid，标识可用状态</span></span><br><span class="line">    <span class="keyword">let</span> valid = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 返回一个函数，产生闭包</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 当函数被调用时，如果valid为false说明函数不可用，直接返回null，不执行fn</span></span><br><span class="line">        <span class="keyword">if</span>(!valid)&#123;</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 立即将下次的valid设置为false，即下次调用无效</span></span><br><span class="line">        valid = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// 一旦函数变为可用状态，设置定时器定时调用原回调函数，并同时在一段时间后使valid为true，即函数有效</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">            valid = <span class="literal">true</span> </span><br><span class="line">        &#125;, interval)</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><p>用于将接收多个参数的函数，转变为接收一个参数返回个函数的形式，便于保存上次状态以继续调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> arg = [...<span class="variable language_">arguments</span>]</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">      arg.<span class="title function_">push</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">      <span class="keyword">return</span> fn</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">      fn.<span class="property">toString</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arg.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> prev+cur )</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> fn</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建柯里化函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span> (fn) &#123;</span><br><span class="line">    <span class="keyword">const</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> innerArgs = [...<span class="variable language_">arguments</span>]</span><br><span class="line">        <span class="keyword">const</span> finalArgs = [...args,...innerArgs]</span><br><span class="line">        <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="literal">null</span>, finalArgs)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模拟new操作"><a href="#模拟new操作" class="headerlink" title="模拟new操作"></a>模拟new操作</h2><p>分为3步：</p><ol><li>使用构造函数的原型创建一个新对象newObj</li><li>执行构造函数，并将this指向这个新对象newObj，传入参数</li><li>如果构造函数没有返回新对象result，则返回第一次创建的对象newObj<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_new</span>(<span class="params">_constructor, ...args </span>) &#123;</span><br><span class="line">  <span class="comment">// 如果第一个参数不是函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> _constructor !== <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 以构造函数的原型创建一个空对象</span></span><br><span class="line">  <span class="keyword">const</span> newObj = <span class="title class_">Object</span>.<span class="title function_">create</span>(_constructor.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">  <span class="keyword">const</span> result = _constructor.<span class="title function_">apply</span>(newObj, args)</span><br><span class="line">  <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? result : newObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="实现函数的call、apply、bind方法"><a href="#实现函数的call、apply、bind方法" class="headerlink" title="实现函数的call、apply、bind方法"></a>实现函数的call、apply、bind方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">call</span> = <span class="keyword">function</span> (<span class="params">context = <span class="variable language_">window</span>, ...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Type Error&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">const</span> fn = <span class="title class_">Symbol</span>(<span class="string">&#x27;fn&#x27;</span>)</span><br><span class="line">   context[fn] = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">const</span> result = context[fn](...args)</span><br><span class="line">    <span class="keyword">delete</span> context[fn]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">apply</span> = <span class="keyword">function</span> (<span class="params">context = <span class="variable language_">window</span>, args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Type Error&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">const</span> fn = <span class="title class_">Symbol</span>(<span class="string">&#x27;fn&#x27;</span>)</span><br><span class="line">   context[fn] = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">const</span> result = context[fn](...args)</span><br><span class="line">    <span class="keyword">delete</span> context[fn]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span> = <span class="keyword">function</span> (<span class="params">context = <span class="variable language_">window</span>, ...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Type Error&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">const</span> _this = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">// 如果绑定后的函数用来做构造函数</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Fn</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">_this</span>(...args,...<span class="variable language_">arguments</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> _this.<span class="title function_">apply</span>(context, [...args, ...<span class="variable language_">arguments</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跨域问题的解决方案和实现原理"><a href="#跨域问题的解决方案和实现原理" class="headerlink" title="跨域问题的解决方案和实现原理"></a>跨域问题的解决方案和实现原理</h2><ul><li><p>什么是跨域？</p><ul><li><p>跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是<strong>浏览器施加的</strong>安全限制。</p></li><li><p>当一个<strong>AJAX</strong>请求url的<strong>协议、域名、端口</strong>三者之间任意一个与当前页面url不同即为跨域</p></li></ul></li><li><p>为什么会出现跨域问题?</p><ul><li>浏览器本身特点：<ul><li>当浏览器基于<strong>AJAX</strong>发送请求的时候， 请求url为其他域的域名时，浏览器会报错</li><li>在13年以前，前后端没有分离的时代，数据处理与视图页面是捆绑在前一起的，不存在跨域问题。在13年开始的的前后端分离之后，前后端分为<strong>数据接口服务器</strong>与<strong>Web资源服务器</strong> ，这两个服务器还是在同一域名之下</li><li>随着前后端分离的发展，存储各种资源的服务器分别在不同的子域名之下，或者分布在完全不同的域名之下，随即产生跨域问题，目前大型web项目几乎都使用非同源策略，来提高被访问性能</li></ul></li><li>出于浏览器的同源策略限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）</li></ul></li><li><p><strong>如何解决跨域？</strong></p><ol><li><p>在发送<strong>AJAX</strong>请求时使用<code>JSONP</code>数据类型</p><ul><li><p>在HTML中，link标签，script标签 在使用链接请求文件时，不存在域的限制</p></li><li><p>在<code>AJAX</code>中使用<code>JSONP</code>数据类型，原理就是动态创建了一个script标签，其请求类型只能是<code>Get</code>，其中<code>src</code>为请求url，并且给请求url传递一个带参数的函数，函数的细节在客户端<code>js</code>中：<code>?callback=fun(data)</code></p></li><li><p>当服务器接收到请求后，将数据转换成字符串拼接到这个作为参数的函数的参数中：<code>&#39;fun(&#123;....数据&#125;)&#39;</code>，并且返回这个字符串</p></li><li><p>浏览器接收到字符串后，将执行这个字符串的语句，相当于传入参数并调用了函数<code>fun(data)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 使用数据</span></span><br><span class="line">&#125;</span><br><span class="line">script.<span class="property">src</span> = <span class="string">&#x27;http://xxx.xxx.xxx.xxx:xxxx?callback=getData&#x27;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script)</span><br></pre></td></tr></table></figure></li><li><p><code>JSONP</code>存在的问题：</p><ul><li><p>信息传递不安全，信息可能被伪造和修改</p></li><li><p>有缓存：浏览器会对script标签接收到的数据进行缓存</p></li><li><p>url存在长度限制</p></li><li><p>需要服务器支持拼接数据</p></li><li><p>基于<strong>iframe</strong>的跨域解决方案 </p></li></ul></li></ul></li><li><p>iframe可以忽略域的影响，不存在域的限制</p></li><li><p>CORS跨域资源共享</p><ul><li>跨域产生的错误一般来自于接口服务器的拒绝，需要在服务器端开启CORS跨域资源共享</li><li>在前端框架中，使用<code>axios</code>进行封装一个模块，设置请求拦截器，携带接口服务器送回的<code>token</code>进行跨域请求，接口服务器通过校验<code>token</code>来判断请求是否合法，设置响应拦截器进行进一步操作</li><li>浏览器ajax在跨域请求时候，浏览器会默认先以<code>OPTION</code>请求类型发送一个试探请求，试探目标服务器是否支持跨域</li></ul></li><li><p>基于http proxy实现跨域请求（开发时使用，因为请求地址会被打包固定）</p></li><li><p>Nginx反向代理，部署的时候使用</p></li></ol></li></ul><h1 id="框架核心内容概述"><a href="#框架核心内容概述" class="headerlink" title="框架核心内容概述"></a>框架核心内容概述</h1><h2 id="VUE核心内容"><a href="#VUE核心内容" class="headerlink" title="VUE核心内容"></a>VUE核心内容</h2><ol><li>vue2.0/3.0 双向数据绑定实现原理：ES5</li><li>vue-cli 3.0 脚手架<ul><li>配置</li><li>优化</li></ul></li><li>vue基础<ul><li>双向数据绑定</li><li>template模板渲染语法和原理：vue-loader 虚拟DOM</li><li>指令和自定义指令</li><li>method computed watch filters</li><li>class / style</li><li>条件和列表渲染</li><li>事件处理</li><li>表单处理</li><li>组件的prop</li><li>ref</li><li>生命周期</li><li>slot</li><li>transition</li><li>渲染函数和jsx</li><li>插件编写</li><li>mixin</li><li>devtools</li></ul></li><li>vue-router<ul><li>基础</li><li>动态路由</li><li>编程式导航</li><li>命名路由和命名容器</li><li>导航守卫</li><li>hash和浏览器路由</li><li>路由原理</li></ul></li><li>vuex 状态管理<ul><li>state</li><li>getter</li><li>mutation</li><li>action</li><li>module</li><li>mapXxx</li><li>实现原理</li></ul></li><li>单元测试</li><li>SSR服务器渲染</li><li>UI组件库</li></ol><h2 id="React核心"><a href="#React核心" class="headerlink" title="React核心"></a>React核心</h2><ol><li>create-react-app脚手架<ul><li>配置</li><li>优化</li></ul></li><li>react基础<ul><li>JSX语法，虚拟DOM</li><li>状态State</li><li>属性Props</li><li>ref</li><li>组件</li><li>生命周期</li><li>PureComponent/Component</li><li>Hooks</li></ul></li><li>react-rooter-dom</li><li>redux<ul><li>redux</li><li>react-redux</li><li>中间件 thurnk</li></ul></li><li>TypeScript</li><li>UI组件</li><li>SSR服务器渲染</li></ol><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><ol><li><p>Vue的双向数据绑定原理：</p><ul><li><p>使用<strong>深克隆</strong>将obj拷贝到newObj中，分别存储数据的当前值和更新的值</p></li><li><p>使用ES5的<code>Object.defineProperty</code>对obj的属性的设置和获取进行拦截，将更新的值优先使用<code>set()</code>函数优先设置到newObj当中，再将newObj中的值渲染到DOM中</p></li><li><pre><code class="js">let obj = &#123;    name:&#39;&#39;&#125;let newObj = JSON.parse(JSON.stringify(obj)) //使用...obj只能拷贝一层数据，更深层次仍然是引用数据Object.defineProperty(obj,&#39;name&#39;,&#123;    get()&#123;        return newObj.name    &#125;,    set(newVal)&#123; //在设置obj的时候同时改变newObj的name，触发修改dom视图更新        if(newVal === newObj.name) return        newObj.name = newVal        observer()    &#125;&#125;)function observer()&#123;    span.innerHtml = newObj.name    inputName.value = obj.name&#125;inputName.oninput = function()&#123;    obj.name = this.value&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">对原始数据克隆</span><br><span class="line"></span><br><span class="line">* 需要分别给对象中每个属性设置监听，中途加入的属性无法被监听到，解决方案：ES6 Proxy对象代理</span><br><span class="line"></span><br><span class="line">  ```js</span><br><span class="line">  let obj=&#123;&#125;</span><br><span class="line">  obj = new Proxy(obj,&#123;     //不需要担心中途加入的prop</span><br><span class="line">      get(target,prop)&#123;</span><br><span class="line">      return target[prop]</span><br><span class="line">      &#125;,</span><br><span class="line">      set(target,prop,value)&#123;</span><br><span class="line">          if(target[prop] === value) return;</span><br><span class="line">      target[prop] = value；</span><br><span class="line">          observer();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  function observer()&#123;</span><br><span class="line">      span.innerHtml = newObj.name</span><br><span class="line">      inputName.value = obj.name</span><br><span class="line">  &#125;</span><br><span class="line">  inputName.oninput = function()&#123;</span><br><span class="line">      obj.name = this.value</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>MVC(React)和MVVM(Vue)的区别</p><ol><li>MVVM模式的特点主要是数据的双向绑定，数据更改，视图变化，视图更改(监听)，数据变化</li><li>MVC模式的特点是<strong>模型数据</strong>单向通知<strong>视图</strong>更改，而视图原则上不能更新模型数据</li><li>React底层不支持双向绑定，但是可以以MVVM模式来进行手动设置监听器来实现数据双向绑定。</li><li>Vue底层自带数据双向绑定<code>v-modle</code></li></ol></li><li><p>Vue基础面试讨论点：</p><ul><li>组件通信<ul><li>属性传递</li><li>发布订阅，事件总线 ，$on / $ emit</li><li>Provide / inject</li><li>slot</li><li>$parent $children</li><li>本地存储（解决所有组件之间的通信）<ul><li>vuex</li><li>LocalStorage 持久化存储 4MB</li><li>Cookies 4KB</li><li>Session Storage：<ul><li>服务器设置<code>session</code> 在客户端请求后返回给客户端信息</li><li>在响应头中，携带<code>set-cookie = &#39;connect sid&#39;</code>，客户会把信息种植到本地<code>Cookie</code>中，且为只读</li><li>客户端再次向服务器发送请求的时候，将默认在请求头中放置<code>Cookie</code>，将<code>connect sid</code>发送给数据</li></ul></li></ul></li></ul></li></ul></li></ol><ul><li><ul><li>借助使用C语言编写的<code>libuv</code>库实现</li></ul></li><li>浏览器访问网页流程：<ul><li>输入url按下回车后<ol><li>DNS解析<ul><li>浏览器DNS缓存</li><li>系统DNS缓存</li><li>向DNS服务器发送DNS解析报文</li></ul></li><li>获取到了IP，浏览器网络模块开始发送TCP三次握手的第一次报文</li><li>第三次报文携带HTTP请求报文</li><li>浏览器接收到响应报文</li><li>渲染页面<ol><li>HTML解析器通过解析HTML标签构建DOM树</li><li></li></ol></li></ol></li></ul></li></ul><h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><ol><li><p>React面试讨论点：</p><ul><li>组件通信<ul><li>属性Props 携带 回调函数</li><li>发布订阅</li><li>redux</li><li>React.createContext 解决祖先和后代组件</li></ul></li></ul></li></ol><ul><li>redux / react-redux </li></ul><h1 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h1><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><ul><li><p>使用ES6 Set：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">RemoveDuplicate</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)] <span class="comment">// Array.from(new Set(arr))</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用原生算法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">RemoveDuplicate2</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arrCopy = <span class="title class_">DeepClone</span>(arr)<span class="comment">//深拷贝函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = arrCopy.<span class="property">length</span> - <span class="number">1</span>; i &gt; <span class="number">0</span> ; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i ; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arrCopy[i] === arr[j])&#123;</span><br><span class="line">                arrCopy.<span class="title function_">splice</span>(i,<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrCopy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>先排序，再进行相邻比较</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">RemoveDuplicate3</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arrCopy = <span class="title class_">DeepClone</span>(arr);</span><br><span class="line">    arrCopy.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span> a-b)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = arrCopy.<span class="property">length</span> - <span class="number">1</span>; i &gt; <span class="number">0</span> ; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arrCopy[i] === arrCopy[i-<span class="number">1</span>])&#123;</span><br><span class="line">            arrCopy.<span class="title function_">splice</span>(i-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrCopy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用正则</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">RemoveDuplicateReg</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arrCopy = <span class="title class_">DeepClone</span>(arr);</span><br><span class="line">    arrCopy.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span> a-b)</span><br><span class="line">    arrCopy = arrCopy.<span class="title function_">join</span>(<span class="string">&#x27;@&#x27;</span>) + <span class="string">&#x27;@&#x27;</span></span><br><span class="line">    <span class="keyword">let</span> reg = <span class="regexp">/(\d+@)\1*/g</span>;</span><br><span class="line">    arrCopy = arrCopy.<span class="title function_">replace</span>(reg,<span class="function">(<span class="params">group,subgroup</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;group&quot;</span>+group,<span class="string">&quot;subgroup&quot;</span> + subgroup)</span><br><span class="line">        <span class="keyword">return</span> subgroup</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> arrCopy.<span class="title function_">slice</span>(<span class="number">0</span>,-<span class="number">1</span>).<span class="title function_">split</span>(<span class="string">&#x27;@&#x27;</span>).<span class="title function_">map</span>(<span class="function"><span class="params">elem</span> =&gt;</span> <span class="title class_">Number</span>(elem));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><ul><li><p>冒泡排序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> completeFlag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;arr.<span class="property">length</span> ; i++) &#123;</span><br><span class="line">        completeFlag = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;arr.<span class="property">length</span> -<span class="number">1</span> -i ; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                completeFlag = <span class="literal">false</span>;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">                <span class="comment">//使用ES6结构赋值进行值交换</span></span><br><span class="line">                <span class="comment">//[arr[j],arr[j+1]] = [arr[j+1],arr[j]]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(completeFlag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>插入排序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insertSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> i,j,temp</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;arr.<span class="property">length</span> ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i-<span class="number">1</span>] &gt; arr[i])&#123;</span><br><span class="line">            temp = arr[i];<span class="comment">//被插入的元素</span></span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;=<span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j--) &#123;  </span><br><span class="line">                    arr[j + <span class="number">1</span>] = arr[j]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 已经跳出的循环的j，需要回到上一个位置进行插入</span></span><br><span class="line">            arr[j + <span class="number">1</span>] = temp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li><p>实现数组扁平化</p><ul><li><p>使用ES6<code>Array.prototype.flat(Infinity)</code>扁平化任何维度的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>, [<span class="number">7</span>, <span class="number">8</span>, [<span class="number">9</span>, <span class="number">10</span>]]]],<span class="number">11</span>];</span><br><span class="line"><span class="keyword">let</span> result = arr.<span class="title function_">flat</span>(infinity)</span><br></pre></td></tr></table></figure></li><li><p>使用<code>Array.prototype.toString()</code>方法，然后使用<code>split(&#39;,&#39;)</code>转换为字符串，此时每一项都为字符串类型，再使用map对每一项进行转换为数字类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>, [<span class="number">7</span>, <span class="number">8</span>, [<span class="number">9</span>, <span class="number">10</span>]]]],<span class="number">11</span>];</span><br><span class="line"><span class="keyword">let</span> result = arr.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>).<span class="title function_">map</span>(<span class="function"><span class="params">elem</span> =&gt;</span> <span class="title class_">Number</span>(elem));</span><br></pre></td></tr></table></figure></li><li><p>使用正则表达式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>, [<span class="number">7</span>, <span class="number">8</span>, [<span class="number">9</span>, <span class="number">10</span>]]]],<span class="number">11</span>];</span><br><span class="line"><span class="keyword">let</span> result =<span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="string">&quot;[&quot;</span>+<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arr2).<span class="title function_">replace</span>(<span class="regexp">/(\[|\])/g</span>,<span class="string">&#x27;&#x27;</span>)+<span class="string">&quot;]&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>使用数组的<code>some()</code>方法对数组内元素进行反复测试，判断是否为数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flatArray</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (arr.<span class="title function_">some</span>(<span class="function"><span class="params">elem</span> =&gt;</span> <span class="title class_">Array</span>.<span class="title function_">isArray</span>(elem)))&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用递归类型判断</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">streamrollArray</span>(<span class="params">array</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> newArray = []</span><br><span class="line">    array.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(item <span class="keyword">instanceof</span> <span class="title class_">Array</span>)&#123;</span><br><span class="line">            newArray.<span class="title function_">push</span>(...<span class="title function_">streamrollArray</span>(item))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newArray.<span class="title function_">push</span>(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li><p>实现斐波拉契数列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归，n不能超过75025</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">FibonacciArray</span>(<span class="params">n,a1=<span class="number">1</span>,a2=<span class="number">1</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;=<span class="number">1</span>) <span class="keyword">return</span> a2;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">FibonacciArray</span>(n-<span class="number">1</span>,a2,a1+a2 );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非递归</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fibonacci</span> (n,f1=<span class="number">1</span>,f2=<span class="number">1</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> f = <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> (n&lt;=<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;=n ; i++) &#123;</span><br><span class="line">    f = f1 + f2</span><br><span class="line">    f1 = f2</span><br><span class="line">    f2 = f</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输入一个数，求一组连续的数字的和等于这个数字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">GetContinuousSumArray</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> middle = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(n);</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> tempArr = [];</span><br><span class="line">    <span class="keyword">let</span> tempSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;middle ; i++) &#123; <span class="comment">//主循环，从1开始试探</span></span><br><span class="line">        tempSum = <span class="number">0</span>;</span><br><span class="line">        tempArr=[];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt;middle ; j++) &#123; </span><br><span class="line">            <span class="comment">//子循环，从变化的开始位置向后累加</span></span><br><span class="line">         <span class="keyword">if</span> (tempSum &lt; n)&#123;</span><br><span class="line">                tempSum += j;</span><br><span class="line">                tempArr.<span class="title function_">push</span>(j)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果累加到等于n 立即跳出当前子循环</span></span><br><span class="line">            <span class="keyword">if</span> (tempSum === n)&#123;</span><br><span class="line">                result.<span class="title function_">push</span>(tempArr)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="求斐波那契数组中的奇数之和"><a href="#求斐波那契数组中的奇数之和" class="headerlink" title="求斐波那契数组中的奇数之和"></a>求斐波那契数组中的奇数之和</h2><p>在这道题目中，我们需要写一个函数，参数为一个正整数<code>num</code>。它的作用是计算斐波那契数列中，小于或等于<code>num</code>的奇数之和。</p><p>斐波那契数列中，第一和第二个数字都是 1，后面的每个数字由之前两数相加得出。斐波那契数列的前六个数字分别为：1、1、2、3、5、8。</p><p>比如，<code>sumFibs(10)</code>应该返回<code>10</code>。因为斐波那契数列中，比<code>10</code>小的数字只有 1、1、3、5。</p><ul><li><p><code>sumFibs(1)</code>应该返回一个数字。</p></li><li><p><code>sumFibs(1000)</code>应该返回 1785。</p></li><li><p><code>sumFibs(4000000)</code>应该返回 4613732。</p></li><li><p><code>sumFibs(4)</code>应该返回 5。</p></li><li><p><code>sumFibs(75024)</code>应该返回 60696。</p></li><li><p><code>sumFibs(75025)</code>应该返回 135721。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sumFibs</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> prevNumber = <span class="number">0</span>; <span class="comment">// 前一号位</span></span><br><span class="line">  <span class="keyword">var</span> currNumber = <span class="number">1</span>; <span class="comment">// 当前位数字</span></span><br><span class="line">  <span class="keyword">var</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (currNumber &lt;= num) &#123; <span class="comment">//当前位的数字小于num的时候，才进行循环</span></span><br><span class="line">    <span class="keyword">if</span> (currNumber % <span class="number">2</span> !== <span class="number">0</span>) &#123; <span class="comment">// 如果是奇数，累加</span></span><br><span class="line">      result += currNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    currNumber += prevNumber; <span class="comment">// 后一个位的值为 当前位的值加上前一位的值</span></span><br><span class="line">    prevNumber = currNumber - prevNumber; <span class="comment">// 前一位的值为 新的当前位减去自身，得到新的前一位</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>对所有素数求和</p><p>在这道题目中，我们需要写一个函数，它接收一个数字参数<code>num</code>，返回值为不大于这个数字的所有质数之和。</p><p>质数是大于 1 且仅可以被 1 和自己整除的数。比如，2 就是一个质数，因为它只可以被 1 和 2（它本身）整除。</p><p>注意，传入函数的<code>num</code>不一定是质数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sumPrimes</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> currentNum = <span class="number">2</span>; currentNum &lt;= num ; currentNum++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span> ; i&lt;currentNum;i++ )&#123;</span><br><span class="line">      <span class="keyword">if</span>(currentNum % i === <span class="number">0</span>)&#123;</span><br><span class="line">        flag = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">      sum+=currentNum</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(currentNum)</span><br><span class="line">    &#125;</span><br><span class="line">    flag = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sumPrimes</span>(<span class="number">10</span>)) ;</span><br></pre></td></tr></table></figure></li></ul><h2 id="判断是否符合-USD-格式"><a href="#判断是否符合-USD-格式" class="headerlink" title="判断是否符合 USD 格式"></a>判断是否符合 USD 格式</h2><p>题目描述</p><p>给定字符串 string，检查其是否符合美元书写格式<br>1、以 $ 开始<br>2、整数部分，从个位起，满 3 个数字用 , 分隔<br>3、如果为小数，则小数部分长度为 2<br>4、正确的格式如：$1,023,032.03 或者 $2.03，错误的格式如：$3,432,12.12 或者 $34,344.3</p><p>输入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;$20,933,209.93&#x27;</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>解决方案：</p><p>先编写正则表达式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/^\$\d&#123;<span class="number">1</span>,<span class="number">3</span>&#125;(\,\d&#123;<span class="number">3</span>&#125;)*(\.\d&#123;<span class="number">2</span>&#125;)?$/</span><br><span class="line"><span class="comment">// ^\$\d&#123;1,3&#125; 匹配以$开始，后跟1到3位的数字开头 \$为$的转义</span></span><br><span class="line"><span class="comment">// ()内的内容为匹配一个规定的模板字符串，</span></span><br><span class="line"><span class="comment">// (\,\d&#123;3&#125;)* 匹配  ,xxx 类型的 一组字符串0次或者多次 x必须为3个数字  \,为,的转意</span></span><br><span class="line"><span class="comment">// (\.\d&#123;2&#125;)? 匹配  .xx 类型的一组字符串 0次或者1次   \.为.的转意</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isUSD</span>(<span class="params">str</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^\$\d&#123;1,3&#125;(\,\d&#123;3&#125;)*(\.\d&#123;2&#125;)?/</span>;</span><br><span class="line">    <span class="keyword">return</span> reg.<span class="title function_">test</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="横杠命名转换为驼峰命名"><a href="#横杠命名转换为驼峰命名" class="headerlink" title="横杠命名转换为驼峰命名"></a>横杠命名转换为驼峰命名</h2><p>首先将横杠命名的字符串使用split(“-“)进行分割成字符串数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ConvertToCamelCase</span>(<span class="params">string</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">HyphenLowerToUpper</span>(<span class="params">match</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> match.<span class="title function_">toUpperCase</span>().<span class="title function_">replace</span>(<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">        <span class="comment">//或者 return match.toUpperCase()..substring(1);</span></span><br><span class="line">        <span class="comment">//或者 return match.toUpperCase()..substr(1);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> string.<span class="title function_">replace</span>(<span class="regexp">/-[a-z]/g</span>, <span class="title class_">HyphenLowerToUpper</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>substring（str0，str1）表示从字符串的第几个截取到第几个，如果第一个参数写了，第二个参数没有写的话，那么代表着从第一个参数的索引开始截取到字符串的末尾。 参数值可以是正值，也可以是负值。但是和slice不同的是，slice中参数是负值，那么倒着开始数，而substring参数是负值的话，代表着往前数几位，它是不能倒着开始数的。最后返回的是一个截取的新数组。</li><li>substr （开始的索引，长度），表示从第几个开始，一直往后截取第二个参数的大小的长度。如果参数二是arr.length（数组的长度）的话，那么代表着从第一个参数的索引开始，一直截取到数组的最后一位。</li></ul><p>使用replace()的回调函数处理匹配项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">convert1</span> (string) &#123;</span><br><span class="line">  <span class="keyword">return</span> string.<span class="title function_">replace</span>(<span class="regexp">/-[a-z]/ig</span>,<span class="function"><span class="params">item</span> =&gt;</span> (item[<span class="number">1</span>].<span class="title function_">toUpperCase</span>()))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">convert1</span>(<span class="string">&#x27;up-to-date&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">convert2</span> (string) &#123;</span><br><span class="line">  <span class="keyword">return</span> string.<span class="title function_">replace</span>(<span class="regexp">/[A-Z]/g</span>,<span class="function">(<span class="params">item,idx</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (idx === <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> item.<span class="title function_">toLowerCase</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span>  <span class="string">&#x27;-&#x27;</span>+ item.<span class="title function_">toLowerCase</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).<span class="title function_">replace</span>(<span class="regexp">/-?/</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">convert2</span>(<span class="string">&#x27;UpToDate&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="函数作为参数的this"><a href="#函数作为参数的this" class="headerlink" title="函数作为参数的this"></a>函数作为参数的this</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">number</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">number</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">show</span>: <span class="keyword">function</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">number</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="title function_">fn</span>();</span><br><span class="line">    <span class="variable language_">arguments</span>[<span class="number">0</span>]();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">show</span>(fn);</span><br></pre></td></tr></table></figure><p>第一个函数<code>fn</code>被调用的时候，这里的<code>fn</code>中的this指向的window</p><p>第二个<code>arguments[0]</code>被调用的时候，相当于<code>arguments.0</code>，相当于调用数组的第0个元素，而且<code>arguments</code>为一个伪数组，且为对象数组</p><h2 id="输出打印结果"><a href="#输出打印结果" class="headerlink" title="输出打印结果"></a>输出打印结果</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;global&#x27;</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;local&#x27;</span>, </span><br><span class="line">    <span class="attr">foo</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">    &#125;.<span class="title function_">bind</span>(<span class="variable language_">window</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> obj.<span class="title function_">foo</span>()  <span class="comment">//实际上执行的是 new function()&#123;&#125;.bind(window),而new比bind优先级高，所以，bind是在构造函数执行之后，即使用new和foo内的函数产生新对象之后，才对foo内的function执行bind方法</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">name</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="property">name</span>)</span><br><span class="line"><span class="keyword">var</span> bar3 = bar2 = bar</span><br><span class="line">bar2.<span class="property">name</span> = <span class="string">&#x27;foo2&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar3.<span class="property">name</span>)</span><br></pre></td></tr></table></figure><h2 id="ES6转换为ES5"><a href="#ES6转换为ES5" class="headerlink" title="ES6转换为ES5"></a>ES6转换为ES5</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span> (name) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">    greet () &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    greetDelay (time) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">        &#125;, time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">greet</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi, my name is&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">greetDelay</span> = <span class="keyword">function</span> (<span class="params">time</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="variable language_">this</span></span><br><span class="line">    <span class="built_in">setTimeout</span>( <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi, my name is &#x27;</span>+ <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;,time)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 并行异步队列的实现</title>
      <link href="/2023/07/24/javascript-quque/"/>
      <url>/2023/07/24/javascript-quque/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript-并行异步队列的实现"><a href="#JavaScript-并行异步队列的实现" class="headerlink" title="JavaScript 并行异步队列的实现"></a>JavaScript 并行异步队列的实现</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>队列，这玩意几乎计算机相关的大学生都学过，用简单的描述来说，就是一个排队处理调度机制，先来先出去嘛，队列的算法操作与数据结构也相对比较简单，一个装东西的容器，一个从头出队列的操作，一个从尾部进的操作。当然可能还有其他的操作。</p><p>最近团队的前端项目中有一个很常见的需求：上传文件。平常我们遇到最多的场景就是网盘，但是文件上传就只有把文件推上去那么简单吗？不，文件大小是个问题。</p><p>小文件在上传中几乎是秒级的速度，但大文件不一样，需要切片。</p><p>文件切片可以说是很常规的文件操作了，其实就是把文件的二进制数据按照大小一节一节的砍下来，传输完成后再按照相应的位置拼上去，这里我们不讨论如何保证传输中不出错，我们讨论如何优雅的传输这大量的文件“碎片”</p><h2 id="为什么需要队列"><a href="#为什么需要队列" class="headerlink" title="为什么需要队列"></a>为什么需要队列</h2><p>可以想象一下这样的一个问题，我们的文件大小有 100MB，我需要将它切为20份，每一份5MB，那么我们该如何传输这 20 份文件切片呢？将他们都创建一个上传任务吗？这样做可以，你可以同时发送20个请求来发送字节流。</p><p>要是文件再大一点呢？1GB 或者更大，那文件的切片的规模就会非常大，同时传输你的浏览器已经把内存给爆了，完全不可行。为了解决这个问题，那么我们可以使用队列，使用并行队列。</p><p>那么并行队列是什么样子呢？就像食堂排队打饭，但是有多个打饭窗口，每次可以打 4 个人饭，但当 3 个人都打完了，第 4 个人还在打，那么这3个人就应该出队列，然后后面补上，保证窗口的任何时刻都是满载状态，我们在分块上传中，也是需要这种效果</p><h2 id="实现队列"><a href="#实现队列" class="headerlink" title="实现队列"></a>实现队列</h2><p>我们直接上 ts 代码，来看看这个队列如何实现</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createQueue</span>(<span class="params"></span></span><br><span class="line"><span class="params">  tasks: (() =&gt; <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt;)[],</span></span><br><span class="line"><span class="params">  maxNumOfWorkers = <span class="number">1</span>,</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> numOfWorkers = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> taskIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">done, failed</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> getNextTask = (): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (numOfWorkers &lt; maxNumOfWorkers &amp;&amp; taskIndex &lt; tasks.<span class="property">length</span>) &#123;</span><br><span class="line">        tasks[taskIndex]()</span><br><span class="line">          .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            numOfWorkers -= <span class="number">1</span>;</span><br><span class="line">            <span class="title function_">getNextTask</span>();</span><br><span class="line">          &#125;)</span><br><span class="line">          .<span class="title function_">catch</span>(<span class="function">(<span class="params">error: <span class="built_in">Error</span></span>)=&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">failed</span>(error);</span><br><span class="line">          &#125;);</span><br><span class="line">        taskIndex += <span class="number">1</span>;</span><br><span class="line">        numOfWorkers += <span class="number">1</span>;</span><br><span class="line">        <span class="title function_">getNextTask</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numOfWorkers === <span class="number">0</span> &amp;&amp; taskIndex === tasks.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="title function_">done</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_">getNextTask</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们需要使用 Promise ，Promise 的具体相关可以查阅 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">MDN文档</a></p><p>我们创建了一个函数名为<code>createQueue</code>，意为创建队列，这个函数需要两个参数<code>tasks</code>和<code>maxNumOfWorkers</code>。</p><p><code>tasks</code>参数的类型为元素类型为函数的数组，其中的函数的返回值是一个 返回值为空的<code>Promise</code>对象</p><p><code>maxNumOfWorkers</code>为<code>number</code>类型，决定最多有多少个任务同时进行处理</p><p>先看整体函数结构：<code>createQueue</code>返回一个<code>Promise</code>对象，当这个return的<code>Promise</code>改变状态时，也就表明队列中所有任务都结束了</p><p>细看函数体：我们需要初始化两个变量，<code>numOfWorkers</code> 和<code>taskIndex</code></p><p><code>numOfWorkers</code>：记录的是当前正在处理的队列任务的数量</p><p><code>taskIndex</code>：记录整体任务的处理进度</p><p>先说说该队列实现的思想，该队列主要利用递归调用和闭包机制，简单的来说就是套娃，但不是简单的套娃。因为每个结束的任务都可以开启下一个任务，以此类推。我们来看看返回的这个<code>new Promise()</code>干了啥</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">done, failed</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> getNextTask = (): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (numOfWorkers &lt; maxNumOfWorkers &amp;&amp; taskIndex &lt; tasks.<span class="property">length</span>) &#123;</span><br><span class="line">        tasks[taskIndex]()</span><br><span class="line">          .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            numOfWorkers -= <span class="number">1</span>;</span><br><span class="line">            <span class="title function_">getNextTask</span>();</span><br><span class="line">          &#125;)</span><br><span class="line">          .<span class="title function_">catch</span>(<span class="function">(<span class="params">error: <span class="built_in">Error</span></span>)=&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">failed</span>(error);</span><br><span class="line">          &#125;);</span><br><span class="line">        taskIndex += <span class="number">1</span>;</span><br><span class="line">        numOfWorkers += <span class="number">1</span>;</span><br><span class="line">        <span class="title function_">getNextTask</span>();</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">if</span> (numOfWorkers === <span class="number">0</span> &amp;&amp; taskIndex === tasks.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="title function_">done</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_">getNextTask</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Promise</code>上的<code>done</code>、<code>failed </code>分别对应队列任务全部完成、失败，失败的结果是：只要有一个任务失败，则后续任务全部终止</p><p>任务能按预期处理的实现则是在<code>getNextTask</code>这个函数中</p><p>在函数<code>getNextTask</code>外部代码中，我们先调用<code>getNextTask</code> 使得<code>getNextTask</code>递归到整个处理池满载的状态，即<code>numOfWorkers = maxNumOfWorkers</code></p><p>每个<code>getNextTask</code>任务中，符合条件的情况下，将任务队列中的函数进行执行，也就是<code>tasks[taskIndex]()</code>，等待任务结束，即调用<code>then()</code>或者<code>catch()</code></p><p>任务结束，调用<code>then()</code>将处理池中的数量-1，然后在开始下一个任务，以此递归，这样，即使有任务提前完成，也会让队列处于满载状态，提高处理效率</p><p>任务结束条件<code>numOfWorkers === 0 &amp;&amp; taskIndex === tasks.length</code>，当正在任务处理的数量为<code>0</code> 并且 任务指针已经指向末尾+1的位置，表明最后一个队列任务已经完成，这个时候调用<code>done()</code>，即可让<code>new Promise</code>产生一个<code>fulfilled</code>状态，让外部调用队列的<code>Promise</code>对任务的结束进行处理，队列异常终止处理也是如此</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在做大文件上传之前，一直觉得队列这个数据结构用处不多，其原因是我们大多时候都是用的同步的思维编写代码和思考问题。<br>上文的队列仅仅是一个简单的解决方案，使用递归的方式来实现队列，其实是不太好的，因为当数据量过于庞大和复杂，会导致内存占用过大，并且不好处理在失败的任务重启这个问题。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> TypeScript </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封装AJAX以及Axios的使用</title>
      <link href="/2023/07/24/axios/"/>
      <url>/2023/07/24/axios/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP请求与XMLHttpRequest"><a href="#HTTP请求与XMLHttpRequest" class="headerlink" title="HTTP请求与XMLHttpRequest"></a>HTTP请求与XMLHttpRequest</h1><h2 id="API分类"><a href="#API分类" class="headerlink" title="API分类"></a>API分类</h2><ul><li>REST API，restful<ul><li>使用到请求方式的语义决定服务器进行CRUD的其中一种，例如GET为查询，POST为修改，PUT为增加，DELETE为删除</li><li>同一个路径可以进行多个操作</li></ul></li><li>非REST API ，restless<ul><li>请求方式不觉得服务器的操作</li><li>一个路径只对应一个操作</li><li>一般只有GET/POST </li></ul></li></ul><h2 id="XMLHttpRequest对象"><a href="#XMLHttpRequest对象" class="headerlink" title="XMLHttpRequest对象"></a>XMLHttpRequest对象</h2><ul><li>status        http状态码</li><li>statusText  状态码对应的文本</li><li>readyState 标识当前xhr发送请求的状态的只读属性，不是http状态码</li><li>onreadystatechange 当xhr的请求状态发送改变的时候<ul><li>0 初始化</li><li>1 即将发送请求</li><li>2 已经发送了秦秋</li><li>3  请求中</li><li>4 请求完成，收到响应</li></ul></li><li>responseType 设置主动解析的数据类型</li><li>response 通过数据类型解析好的数据对象</li><li>timeout 设置超时时间</li><li>ontimeout 绑定超时监听回调函数</li><li>error</li><li>open() 初始化一个请求，填写参数以及请求方式</li><li>send() 发送请求</li><li>abort() 终端send()</li><li>getResponseHead(name)</li><li>getAllResponseHeads() 获得所有响应头字段</li><li>setRequestHeader(name,value) 设置请求头字段</li></ul><h2 id="请求响应报文"><a href="#请求响应报文" class="headerlink" title="请求响应报文"></a>请求响应报文</h2><p>  请求报文(客户端[request]-&gt;服务端)  </p><blockquote><p> GET(请求的方式) /newcoder/hello.html(请求的目标资源) HTTP/1.1(请求采用的协议和版本号)<br>   Accept: <em>/</em>(客户端能接收的资源类型)<br>   Accept-Language: en-us(客户端接收的语言类型)<br>   Connection: Keep-Alive(维护客户端和服务端的连接关系)<br>   Host: localhost:8080(连接的目标主机和端口号)<br>   Referer: <a href="http://localhost/links.asp">http://localhost/links.asp</a> (告诉服务器我来自于哪里)<br>   User-Agent: Mozilla/4.0(客户端版本号的名字)<br>   Accept-Encoding: gzip, deflate(客户端能接收的压缩数据的类型)<br>   If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT(缓存时间)<br>   Cookie(客户端暂存服务端的信息)<br>   Date: Tue, 11 Jul 2000 18:23:51 GMT(客户端请求服务端的时间)  </p></blockquote><p>  响应报文(服务端[response]-&gt;客户端)  </p><blockquote><p> HTTP/1.1(响应采用的协议和版本号) 200(状态码) OK(描述信息)<br>   Location: <a href="http://www.baidu.com(服务端需要客户端访问的页面路径)/">http://www.baidu.com(服务端需要客户端访问的页面路径)</a><br>   Server:apache tomcat(服务端的Web服务端名)<br>   Content-Encoding: gzip(服务端能够发送压缩编码类型)<br>   Content-Length: 80(服务端发送的压缩数据的长度)<br>   Content-Language: zh-cn(服务端发送的语言类型)<br>   Content-Type: text/html; charset=GB2312(服务端发送的类型及采用的编码方式)<br>   Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT(服务端对该资源最后修改的时间)<br>   Refresh: 1;url=<a href="http://www.it315.org(服务端要求客户端1秒钟后,刷新,然后访问指定的页面路径)/">http://www.it315.org(服务端要求客户端1秒钟后，刷新，然后访问指定的页面路径)</a><br>   Content-Disposition: attachment; filename=aaa.zip(服务端要求客户端以下载文件的方式打开该文件)<br>   Transfer-Encoding: chunked(分块传递数据到客户端）<br>   Set-Cookie:SS=Q0=5Lb_nQ; path=/search(服务端发送到客户端的暂存数据)<br>   Expires: 服务端禁止客户端缓存页面数据<br>   Cache-Control: no-(服务端禁止客户端缓存页面数据)<br>   Pragma: no-(服务端禁止客户端缓存页面数据)<br>   Connection: close(1.0)/(1.1)Keep-Alive(维护客户端和服务端的连接关系)<br>   Date: Tue, 11 Jul 2000 18:23:51 GMT(服务端响应客户端的时间)  </p></blockquote><p><strong>在服务器响应客户端的时候，带上Access-Control-Allow-Origin头信息，是解决跨域的一种方法。</strong></p><h2 id="实现一个简单的-ajax封装"><a href="#实现一个简单的-ajax封装" class="headerlink" title="实现一个简单的 ajax封装"></a>实现一个简单的 ajax封装</h2><p>在了解Axios之前，首先我们要知道的是，Axios 是一个基于 promise 的 HTTP 库 ，使用了promise异步执行回调的特性来携带数据，我们可以通过xhr与promise封装一个简单的ajax模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">axios</span> (&#123; url, method = <span class="string">&#x27;GET&#x27;</span>, param = &#123;&#125;, data = &#123;&#125; &#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">    <span class="keyword">if</span> (method === <span class="string">&#x27;GET&#x27;</span> || method === <span class="string">&#x27;DELETE&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 处理query参数param</span></span><br><span class="line">      <span class="keyword">const</span> queryTempArr = []</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">keys</span>(param).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        queryTempArr.<span class="title function_">push</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;param[key]&#125;</span>`</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">// 将GET请求的参数拼接到url后</span></span><br><span class="line">      <span class="keyword">const</span> queryString = <span class="string">&#x27;?&#x27;</span> + queryTempArr.<span class="title function_">join</span>(<span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line">      url += queryString</span><br><span class="line">      xhr.<span class="title function_">open</span>(method, url, <span class="literal">true</span>)</span><br><span class="line">      xhr.<span class="title function_">send</span>(<span class="literal">null</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method === <span class="string">&#x27;POST&#x27;</span> || method === <span class="string">&#x27;PUT&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 请求体格式</span></span><br><span class="line">      xhr.<span class="title function_">open</span>(method, url)</span><br><span class="line">      xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/json;charset=utf-8&#x27;</span>)</span><br><span class="line">      xhr.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data)) <span class="comment">//请求被放入异步队列中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// DOM 0 级事件监听</span></span><br><span class="line">    xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; status, statusText &#125; = xhr</span><br><span class="line">        <span class="keyword">if</span> (status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span> || status === <span class="number">304</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> response = &#123;</span><br><span class="line">            <span class="attr">data</span>: <span class="title class_">JSON</span>.<span class="title function_">parse</span>(xhr.<span class="property">response</span>), status, statusText</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="title function_">resolve</span>(response)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`request error ， status is <span class="subst">$&#123;status&#125;</span> <span class="subst">$&#123;statusText&#125;</span> `</span>))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h1><p>Axios 是一个基于 promise 的 HTTP请求 库，可以用在浏览器和 node.js 中。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>从浏览器中创建 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest">XMLHttpRequests</a></li><li>可以从 node.js 创建 <a href="http://nodejs.org/api/http.html">http</a> 请求</li><li>支持 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a> 语法</li><li>拦截请求和响应</li><li>转换请求数据和响应数据</li><li>取消请求</li><li>自动转换 JSON 数据</li><li>客户端支持防御 <a href="http://en.wikipedia.org/wiki/Cross-site_request_forgery">XSRF</a></li></ul><h2 id="Axios的拦截器处理流程"><a href="#Axios的拦截器处理流程" class="headerlink" title="Axios的拦截器处理流程"></a>Axios的拦截器处理流程</h2><p>先贴上贴上代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.通过axios.create() 创建一个实例，其功能与直接使用axios类似，创建一个实例能更好的管理和区分不同域的请求</span></span><br><span class="line"><span class="keyword">const</span> axiosInstance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>:<span class="string">&#x27;http://localhost:5000&#x27;</span>,</span><br><span class="line">    <span class="attr">headers</span>:&#123;<span class="string">&#x27;Content-Type&#x27;</span>:<span class="string">&#x27;application/json;charset=utf-8&#x27;</span>&#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">// 2.设置请求拦截器</span></span><br><span class="line">  axiosInstance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">      config.<span class="property">params</span> = &#123;</span><br><span class="line">        <span class="attr">userType</span>:<span class="string">&#x27;jobseeker&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> config</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">error</span> =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">  )</span><br><span class="line"><span class="comment">// 3.设置响应拦截器</span></span><br><span class="line">  axiosInstance.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">      <span class="keyword">return</span> response</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">error</span> =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">  )</span><br><span class="line"><span class="comment">// 4.使用axios实例发送请求</span></span><br><span class="line">  axiosInstance.<span class="title function_">get</span>(<span class="string">&#x27;/get-user-list&#x27;</span>).<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>在整个流程中，拦截器的作用顾名思义，拦截请求的配置，以及响应信息，所以拦截器都应该在发送请求之前进行设置</p><p>拦截器的本质其实就是回调函数，观察其回调就会发现，他的回调就是Promise对象的<code>then()</code>方法的回调函数。</p><p>可以说，相当于在发送请求之前，与接收响应之后，设置拦截器的请求都会被强制进入到拦截器回调函数中做处理，相当于在链式调用中插入了一个<code>then()</code>方法，而<code>then()</code>方法内部的回调函数就是拦截器的回调函数，所以在拦截器的回调中必须返回一个值，来保证数据能够向后传递</p><h2 id="Axios取消请求以及请求防抖"><a href="#Axios取消请求以及请求防抖" class="headerlink" title="Axios取消请求以及请求防抖"></a>Axios取消请求以及请求防抖</h2><p>想要实现取消请求的功能，需要在配置axios以及其实例时，加入cancelToken 属性，其值为一个axios.CancelToken对象，其过程类似于创建Promise对象，需要将其参数保存到外部</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cancel</span><br><span class="line"><span class="keyword">const</span> axiosInstance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>:<span class="string">&#x27;http://localhost:7000&#x27;</span>,</span><br><span class="line">    <span class="attr">headers</span>:&#123;<span class="string">&#x27;Content-Type&#x27;</span>:<span class="string">&#x27;application/json;charset=utf-8&#x27;</span>&#125;</span><br><span class="line">    <span class="attr">cancelToken</span>: <span class="keyword">new</span> <span class="title class_">CancelToken</span>( <span class="function">(<span class="params">c</span>) =&gt;</span> &#123;</span><br><span class="line">      cancel = c</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>上方代码的cancle=c 其实就是将cancel指向c这个函数，类似于promise的reject，，当前在请求时调用这个函数c时，可立即使其内部的promise立即失败，由此取消请求的发送，因此，取消请求可以用作请求防抖来防止过多的重复请求，代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cancel</span><br><span class="line"><span class="keyword">const</span> axiosInstance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>: <span class="string">&#x27;http://localhost:7000&#x27;</span>, <span class="attr">headers</span>: &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json;charset=utf-8&#x27;</span> &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">axiosInstance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cancel <span class="keyword">instanceof</span> <span class="title class_">Function</span>) &#123;</span><br><span class="line">        <span class="title function_">cancel</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    config.<span class="property">cancelToken</span> = <span class="keyword">new</span> axios.<span class="title class_">CancelToken</span>(<span class="function">(<span class="params">c</span>) =&gt;</span> &#123;</span><br><span class="line">        cancel = c</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">axiosInstance.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">&#125;, <span class="function"><span class="params">error</span> =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定到按钮的click监听上</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handelClick</span> () &#123;</span><br><span class="line">    axiosInstance.<span class="title function_">get</span>(<span class="string">&#x27;/test&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        cancel = <span class="literal">null</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>)</span><br><span class="line">    &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中，假如每按钮点击一次就调用一次<code>handelClick()</code>触发一次ajax请求，我们在拦截器中为每个请求设置了一个取消请求的配置，并且将取消请求的函数暴露在了全局作用域，以取消请求来实现请求防抖的流程是在请求到达请求拦截器时，先判断前一个请求的取消函数是否存在，如果存在，则立即调用取消请求，否则不进行处理，在得到响应时，将本次请求的取消函数清除即可</p><blockquote><p>这里通过对按钮点击事件的防抖也是一种处理办法</p></blockquote><p>未完待续…</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> AJAX </tag>
            
            <tag> HTTP </tag>
            
            <tag> Axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript协变和逆变</title>
      <link href="/2023/07/24/covariant-contravariant/"/>
      <url>/2023/07/24/covariant-contravariant/</url>
      
        <content type="html"><![CDATA[<h2 id="协变和逆变是什么？"><a href="#协变和逆变是什么？" class="headerlink" title="协变和逆变是什么？"></a>协变和逆变是什么？</h2><p>我们先来看看维基百科的解释：</p><blockquote><p>协变与逆变（Covariance and contravariance）是在计算机科学中，描述具有父/子型别关系的多个型别通过型别构造器、构造出的多个复杂型别之间是否有父/子型别关系的用语。</p></blockquote><p>简单的说，协变和逆变是一种关系</p><h2 id="如何解释协变与逆变"><a href="#如何解释协变与逆变" class="headerlink" title="如何解释协变与逆变"></a>如何解释协变与逆变</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>我们先假设有以下这几种类型以及关系：</p><p><code>Animal</code>  &gt;=  <code>Dog</code> &gt;=  <code>Greyhound（灰狗）</code> </p><p>以上的类型规定，很显然 灰狗属于狗，狗属于动物，那我们有以下的几种函数的类型</p><p><code>(Animal) → Animal</code></p><p><code>(Dog) → Dog</code></p><p><code>(Greyhound) → Greyhound</code></p><p>假设现在有一个函数<code>g</code>，他的参数为<code>(Dog) → Dog</code>，即：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">g</span>(<span class="params">animal: Animal, dogCallback: (Dog)=&gt; Dog</span>): <span class="built_in">string</span>&#123;</span><br><span class="line">  <span class="comment">// some code to call dogCallback(dog) , dog is Dog type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们要调用函数<code>g</code>，在第二个参数<code>dogCallback</code>的位置传入一个函数，我们暂且叫它<code>f</code></p><h3 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h3><p>我们要传入何种类型的<code>f</code>，才能使得函数<code>g</code>接收的参数<code>dogCallback</code>的类型是安全的呢？</p><h3 id="思考问题"><a href="#思考问题" class="headerlink" title="思考问题"></a>思考问题</h3><p>我们假设使用<code>(Greyhound) → Greyhound</code>类型，记为<code>f:(Greyhound) → Greyhound</code></p><p>从上面<code>f</code>的返回值类型上看，<code>Greyhound</code>是属于<code>Dog</code>，返回值类型是安全，因为灰狗是狗的子类型，我可以调用返回值上是<code>Dog</code>的所有公共属性和方法，没有什么问题。</p><p>我们看看参数类型部分是否安全：</p><p><code>g</code>的参数上定义第二个参数<code>dogCallback</code></p><p><code>g</code>传入的参数<code>dog</code>的类型是<code>Dog</code>，涵盖所有狗的类型</p><p>传入的 <code>f</code> 函数的参数只被定义为 <code>Greyhound</code> 类型</p><p>在函数<code>g</code>中调用<code>f</code>时，<code>Greyhound</code> 类型的参数不能接收<code>Dog</code>类型的变量，传入变量<code>dog</code>的值可能是<code>Greyhound</code><strong>之外</strong>的类型，例如 <code>BlackDog</code></p><p>所以，在参数中，<code>Dog</code> 到 <code>Greyhound</code> 不安全，因为<code>Dog</code>的值<strong>可能</strong>是狗，但不是灰狗，可能是其他类型的狗</p><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>那传入什么类型的函数才是安全的呢？答案是（不止以下两种）：</p><p><code>(Dog) → Greyhound </code></p><p><code>(Animal) → Greyhound</code></p><p>在参数上，<code>Animal</code> 或者 <code>Dog</code> 可以将 <code>Dog</code> 的所有子类型包含在内，因此这是安全的</p><h3 id="理解概念"><a href="#理解概念" class="headerlink" title="理解概念"></a>理解概念</h3><p>返回值的类型要是返回类型，或其子类型，例如 返回类型定为<code>Dog</code>，返回值类型为<code>Dog</code>的子类型<code>Greyhound</code>，返回类型安全</p><p>参数类型 必须是 传入的参数值的类型，或其的子类型，例如参数要求的类型为<code>Dog</code>，传入的参数必须要包含<code>Dog</code>的所有子类型，例如<code>Animal</code>。 <code>Animal</code>包含了<code>Dog</code>，所以<code>Animal</code>到 <code>Dog</code> 是安全的。</p><p>但是传入的子类型不能为 <code>Greyhound</code> , 因为<code>Greyhound</code>  到<code>Dog</code>不安全，即<code>Dog</code> 类型可能会将其他非<code>Greyhound</code>的类型传进去</p><p>这样就意味着<code>(Animal → Greyhound) ≼ (Dog → Dog)</code>， 也就是<code>(Dog → Dog)</code>是<code>(Animal → Greyhound)</code>的子类型</p><p>比较好理解是从<code>Dog</code>到<code>Greyhound</code>，由多到少，很好理解，我们可以称这种变体为<em>协变</em></p><p><code>Animal</code> 到 <code>Dog</code>,这个变体过程由多变少， 我们称这个变体过程为<em>逆变</em></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从宏观上来理解:</p><ul><li><p>协变(covariant)：类型收敛</p></li><li><p>逆变(contravariant)：类型发散</p></li></ul><p>在 TypeScript 中：</p><ul><li><p>对象、类、数组和函数的返回值类型都是协变关系，而函数的参数类型是逆变关系</p></li><li><p>返回值类型是 <strong>协变</strong> 的，意味着如果<code>A</code>为<code>B</code>的子类型，则<code>(T) =&gt;A </code>为<code>(T) =&gt; B</code>的子类型</p></li><li><p>参数类型是 <strong>逆变</strong> 的，意味着如果<code>A</code>为<code>B</code>的子类型， 则<code>(B)=&gt; T</code>为<code>(A) =&gt; T</code>的子类型</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> TypeScript </tag>
            
            <tag> 基础概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用CSS+JS实现一个简单的立方体(可旋转)</title>
      <link href="/2023/07/24/cube/"/>
      <url>/2023/07/24/cube/</url>
      
        <content type="html"><![CDATA[<p>使用CSS3的景深与三维变换+JavaScript实现一个可旋转的立方体（x,y两轴旋转）</p><p>HTML部分：</p><p>首先先构建立方体的DOM结构：</p><ul><li>将6个面使用cube包裹，目的很简单，为了给子元素开启3d景深，</li><li>使用wrap再次包裹，wrap的目的是为了包装整个立方体，可控制缩放</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cube&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cube-face&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cube-face&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cube-face&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cube-face&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cube-face&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cube-face&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其对应样式如下：(使用less书写)</p><p>html与body的样式，使用 overflow: hidden; 隐藏垂直滚动条，防止移动端的滑动</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#dfe6e9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>.wrap:将其设置为100 x 100 px的初始大小，并水平垂直居中，默认将其放大两倍</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: translate(-<span class="number">50%</span>, -<span class="number">50%</span>) scale(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>.cube : 将其设置为100 x 100 px 的初始大小，并使用另一种水平垂直居中的解决办法，且开启内部元素的3D变换</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.cube</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">transform-style</span>: preserve-<span class="number">3</span>d;</span><br><span class="line">    <span class="attribute">transform-origin</span>: center center; <span class="comment">/*设置旋转中心为立方体的重心*/</span> </span><br><span class="line">    <span class="attribute">transform</span>: rotateX(-<span class="number">30deg</span>) rotateY(<span class="number">30deg</span>); <span class="comment">/*默认将立方体选择一定角度*/</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编写6个面之前，我们需要了解浏览器页面的3D坐标系</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/EricReevess/proxy/master/img/coordinate_axis.png" alt="css3d"></p><p>从+Z 到 -Z 方向，为用户看向浏览器屏幕的方向，意味着如果不开启3D变换，那么一切元素都是按照Z轴进行选择</p><p>从+Y 到 -Y 方向，为屏幕从下到上的方向，意味着元素会按照Y轴左右旋转</p><p>从+X 到 -X 方向，为屏幕从左到右的方向，意味着元素可以按照X轴上下翻转</p><p>了解了坐标系，那么可以编写css代码了</p><p>首先我们需要将6个面的公共样式提取出，然后分别为每个面定制选择的角度，以及选择的原点，在这里所有的<code>animation: first 1.5s .8s forwards;</code>可以暂时不编写，因为这是附加的入场动画效果</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.cube-face</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">    user-select: <span class="attribute">none;</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line"><span class="attribute">    &amp;</span>:nth-child(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="attribute">top</span>: -<span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">transform</span>: rotateX(<span class="number">90deg</span>) translateY(<span class="number">50px</span>) translateZ(<span class="number">150px</span>);</span><br><span class="line">        <span class="attribute">transform-origin</span>: bottom;</span><br><span class="line">        <span class="attribute">animation</span>: first <span class="number">1.5s</span> .<span class="number">8s</span> forwards;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="attribute">bottom</span>: -<span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">transform-origin</span>: top;</span><br><span class="line">        <span class="attribute">transform</span>: rotateX(-<span class="number">90deg</span>) translateY(-<span class="number">50px</span>) translateZ(<span class="number">150px</span>);</span><br><span class="line">        <span class="attribute">animation</span>: second <span class="number">1.5s</span> <span class="number">1s</span> forwards;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>) &#123;</span><br><span class="line">        <span class="attribute">left</span>: -<span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">transform-origin</span>: right;</span><br><span class="line">        <span class="attribute">transform</span>: rotateY(-<span class="number">90deg</span>) translateX(<span class="number">50px</span>) translateZ(<span class="number">150px</span>);</span><br><span class="line">        <span class="attribute">animation</span>: third <span class="number">1.5s</span> .<span class="number">4s</span> forwards;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:nth-child</span>(<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="attribute">right</span>: -<span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">transform-origin</span>: left;</span><br><span class="line">        <span class="attribute">transform</span>: rotateY(<span class="number">90deg</span>) translateX(-<span class="number">50px</span>) translateZ(<span class="number">150px</span>);</span><br><span class="line">        <span class="attribute">animation</span>: fourth <span class="number">1.5s</span> .<span class="number">6s</span> forwards;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:nth-child</span>(<span class="number">5</span>) &#123;</span><br><span class="line">        <span class="attribute">transform</span>: rotateY(<span class="number">180deg</span>) translateZ(<span class="number">150px</span>);</span><br><span class="line">        <span class="attribute">animation</span>: fifth <span class="number">1.5s</span> .<span class="number">2s</span> forwards;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:nth-child</span>(<span class="number">6</span>) &#123;</span><br><span class="line">        <span class="attribute">transform</span>: translateZ(<span class="number">150px</span>);</span><br><span class="line">        <span class="attribute">animation</span>: sixth <span class="number">1.5s</span> forwards;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你按照我上方的代码编写，你就会发现结果是这样的一个效果：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/EricReevess/proxy/master/img/image-20200902163752855.png" alt="image-20200902163752855"></p><p>这是因为我们最终的目的是要使用@keyframe来添加进场动画，动画设置forward为播放一次，且在结束时停止，接下来编写6个css动画：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> first &#123;</span><br><span class="line">    <span class="number">100%</span>&#123;</span><br><span class="line">        <span class="attribute">transform</span>: rotateX(<span class="number">90deg</span>) translateY(<span class="number">50px</span>) ;</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> second &#123;</span><br><span class="line">    <span class="number">100%</span>&#123;</span><br><span class="line">        <span class="attribute">transform</span>: rotateX(-<span class="number">90deg</span>) translateY(-<span class="number">50px</span>);</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> third &#123;</span><br><span class="line">    <span class="number">100%</span>&#123;</span><br><span class="line">        <span class="attribute">transform</span>: rotateY(-<span class="number">90deg</span>) translateX(<span class="number">50px</span>) ;</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> fourth &#123;</span><br><span class="line">    <span class="number">100%</span>&#123;</span><br><span class="line">        <span class="attribute">transform</span>: rotateY(<span class="number">90deg</span>) translateX(-<span class="number">50px</span>);</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> fifth &#123;</span><br><span class="line">    <span class="number">100%</span>&#123;</span><br><span class="line">        <span class="attribute">transform</span>: rotateY(<span class="number">180deg</span>) translateZ(<span class="number">50px</span>);</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> sixth &#123;</span><br><span class="line">    <span class="number">100%</span>&#123;</span><br><span class="line">        <span class="attribute">transform</span>: translateZ(<span class="number">50px</span>);</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个动画的最终位置就是每个面的正确位置，最后为每个面加上延迟动画即可，这时你可以看到每一个面交错入场，并搭建成一个立方体的动画效果</p><p>此时需要另外使用一个透明的覆盖层，改变z-index，覆盖整个wrap，用于旋转时的防止立方体元素获得鼠标焦点</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/EricReevess/proxy/master/img/image-20200902155629492.png" alt="image-20200902155629492"></p><p>现在布局以及样式都以及准备完毕了，接下来就进入到JavaScript的编写</p><p>首先获取需要DOM元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wrap = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.wrap&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> cube = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.cube&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> cover = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.cover&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> tip = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.tip &gt; span&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> cubeFace = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;.cube-face&quot;</span>)</span><br></pre></td></tr></table></figure><p>创建需要的变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> keydownPosX;  <span class="comment">//鼠标按下时在在浏览器窗口上的X坐标</span></span><br><span class="line"><span class="keyword">let</span> keydownPosY;  <span class="comment">//鼠标按下时在浏览器窗口上的Y坐标</span></span><br><span class="line"><span class="keyword">let</span> currentDegX = <span class="number">0</span>; <span class="comment">//鼠标当前在浏览器窗口上的X坐标</span></span><br><span class="line"><span class="keyword">let</span> currentDegY = <span class="number">0</span>; <span class="comment">//鼠标当前在浏览器窗口上的Y坐标</span></span><br><span class="line"><span class="keyword">let</span> stopDegX = <span class="number">30</span>;  <span class="comment">//上一次X轴旋转的角度，此处我们默认旋转30度，以便展现立方体</span></span><br><span class="line"><span class="keyword">let</span> stopDegY = -<span class="number">30</span>; <span class="comment">//上一次Y轴旋转的角度</span></span><br><span class="line"><span class="keyword">let</span> timer;<span class="comment">// 自动旋转定时器</span></span><br></pre></td></tr></table></figure><p>设置一个定时器，延时旋转立方体</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    timer = <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        stopDegX += <span class="number">.2</span>;</span><br><span class="line">        cube.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">`rotateX(<span class="subst">$&#123;stopDegY&#125;</span>deg) rotateY(<span class="subst">$&#123;stopDegX&#125;</span>deg)`</span>;</span><br><span class="line">    &#125;, <span class="number">16</span>)</span><br><span class="line">&#125;, <span class="number">800</span>)</span><br></pre></td></tr></table></figure><p>监听鼠标在cover覆盖层上的事件：分别是按下时，移动时，抬起时</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cover.<span class="title function_">addEventListener</span>(<span class="string">&quot;mousedown&quot;</span>, mousedown)</span><br><span class="line">cover.<span class="title function_">addEventListener</span>(<span class="string">&quot;mouseup&quot;</span>, mouseup)</span><br><span class="line">cover.<span class="title function_">addEventListener</span>(<span class="string">&quot;mouseout&quot;</span>, mouseup)</span><br></pre></td></tr></table></figure><p>编写按下时的回调函数：立即清除定时器，记录坐标</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mousedown</span>(<span class="params">ev</span>) &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">    keydownPosX = ev.<span class="property">offsetX</span>;</span><br><span class="line">    keydownPosY = ev.<span class="property">offsetY</span>;</span><br><span class="line">    cover.<span class="title function_">addEventListener</span>(<span class="string">&quot;mousemove&quot;</span>, drag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写拖拽与鼠标抬起事件的回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">drag</span>(<span class="params">ev</span>) &#123; </span><br><span class="line">    <span class="comment">//计算鼠标坐标的变化量，并减小旋转速度，即将鼠标移动的坐标除以3，可调节</span></span><br><span class="line">    currentDegX = (ev.<span class="property">offsetX</span> - keydownPosX) / <span class="number">3</span>; </span><br><span class="line">    currentDegY = -(ev.<span class="property">offsetY</span> - keydownPosY) / <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 将坐标变化量加上之前的旋转角度，设置到transform中</span></span><br><span class="line">    cube.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">`rotateX(<span class="subst">$&#123;stopDegY + currentDegY&#125;</span>deg) rotateY(<span class="subst">$&#123;stopDegX + currentDegX&#125;</span>deg)`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mouseup</span>(<span class="params">ev</span>) &#123;</span><br><span class="line">    stopDegX += currentDegX <span class="comment">// 更新增加的角度</span></span><br><span class="line">    stopDegY += currentDegY</span><br><span class="line">    currentDegX = <span class="number">0</span>; <span class="comment">// 将当前鼠标位置数据清空</span></span><br><span class="line">    currentDegY = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 松开后移除鼠标移动事件</span></span><br><span class="line">    cover.<span class="title function_">removeEventListener</span>(<span class="string">&quot;mousemove&quot;</span>, drag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，可旋转立方体基本功能已经完成，代码相对简单，只涉及到事件对象的信息获取以及对元素的样式操作</p><p>最后附上Demo地址： <a href="https://ericreevess.github.io/proxy/web/Cube3Dv2/">cube</a> (使用PC端浏览器打开)</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 教程 </tag>
            
            <tag> CSS </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探究函数柯里化</title>
      <link href="/2023/07/24/curry/"/>
      <url>/2023/07/24/curry/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>闭包函数： 引用了另一个函数内变量的函数，造成另一个函数的上下文能继续保持在栈中，</p><p>高阶函数：参数包含函数，返回值为函数的函数，可以理解为函数工厂函数</p><p>函数柯里化：将一个接受n个参数的函数，转换为每次调用只接受不超过n个参数的函数，且最多需要n次调用完</p><blockquote><p>carriedFunc  =  carry(func)</p><p>netxArgsFunc = carriedFunc(..partArgs)</p><p>funcResult = carriedFunc(…fullArgs)</p></blockquote><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>参数复用，柯里化后的函数相当于预传参数的函数，这样避免和频繁输入参数</li><li>代码简洁，在不使用对象最为传参数的情况下，避免一次性传入过多的参数导致代码可读性变差</li><li>延迟计算，如果涉及到多个参数的实时输入计算，防止频繁计算出现非预期结果，柯里化可以在没有完全传入参数的情况下节省计算资源</li><li>动态创建特定函数，可以通过不同的参数进行动态返回函数</li></ul><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>要实现分分步传入参数，返回下一步的函数，使得最终步调用函数，需要使用<code>Function.prototype.bind()</code> 方法的特性：使用预备参数生成新函数。<br><code>bind</code>函数第一个参数是决定新函数的<code>this</code>指针，第二个参数之后为参数列表，意味着将一个参数长度为<code>l</code>的函数<code>foo</code>，<code>bind</code>参数列表传入小于<code>l</code>的参数个数<code>n</code>，调用<code>bind</code>后，返回的新函数<code>fooo</code>的参数列长度<code>fooo.length</code>就为<code>l - n</code>，传入的参数会在调用新函数的时候作为预备参数</p><p>以上面的操作，可以写一个递归柯里化函数<code>carry</code>，该函数的参数为需要分步调用的函数<code>foo</code>，每次返回一个新函数<code>carriedFoo</code>，作为返回给使用者的调用函数，也就是柯里化后的函数</p><p>柯里化后的函数可以通过传入参数判断是直接调用，还是继续返回含参函数：</p><ul><li><p>当一次性传入所有<code>foo</code>的参数时<code>args.length = foo.length</code>，直接返回结果</p></li><li><p>当使用者传入<code>carriedFoo</code> 函数的参数列表长度<code>args.length</code>小于原函数参数长度<code>foo.length</code>时，则使用<code>bind</code>将<code>args</code>中的参数作为预备参数生成一个新的函数<code>carriedFooWithArgs</code>，在将<code>carriedFooWithArgs</code>进行柯里化一次</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">carry</span>(<span class="params">foo</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">carriedFoo</span> (...args)&#123;</span><br><span class="line">    <span class="keyword">if</span>(args.<span class="property">length</span> &lt; foo.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="comment">//boundFunc.length = foo.length - args.legnth</span></span><br><span class="line">      <span class="keyword">const</span> carriedFooWithArgs = foo.<span class="title function_">bind</span>(<span class="literal">null</span>, ...args) <span class="comment">// 将不完整的参数绑定至新函数，形成新的预备参数的函数 </span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">carry</span>(carriedFooWithArgs) <span class="comment">// 参数没有传完，继续返回柯里化函数</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">foo</span>(...args) <span class="comment">// 参数传完了，最终调用</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用carry</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">n1, n2, n3</span>) =&gt; n1 + n2 + n3</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> carriedAdd = <span class="title function_">curry</span>(add)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">add</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>) <span class="comment">// 6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="TypeScript-类型定义"><a href="#TypeScript-类型定义" class="headerlink" title="TypeScript 类型定义"></a>TypeScript 类型定义</h2><p>柯里化的ts类型比较复杂，就连 lodash 里面那个类型也是定义了很多可能的情况， 没怎么看懂😅，所以不想写了</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://hackernoon.com/learn-advanced-typescript-4yl727e6">learn-advanced-typescript</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 基础概念 </tag>
            
            <tag> 柯里化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker容器的基本使用</title>
      <link href="/2023/07/24/docker/"/>
      <url>/2023/07/24/docker/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker容器的基本使用"><a href="#Docker容器的基本使用" class="headerlink" title="Docker容器的基本使用"></a>Docker容器的基本使用</h1><h2 id="Docker的基本架构"><a href="#Docker的基本架构" class="headerlink" title="Docker的基本架构"></a>Docker的基本架构</h2><p>关键字：</p><ul><li><p>Dockerfiles：Docker本身的配置文件，配置如何构建容器以及镜像，和端口</p></li><li><p>Image：虚拟系统的镜像</p></li><li><p>DockerContainer(容器)：镜像运行的虚拟环境，类似虚拟机</p></li><li><p>镜像仓库：虚拟系统的基本镜像，或者已保存的镜像</p></li></ul><h2 id="Docker的基本指令"><a href="#Docker的基本指令" class="headerlink" title="Docker的基本指令"></a>Docker的基本指令</h2><ul><li><p>查看当前<code>运行的/所有的</code>镜像</p><blockquote><p>docker ps </p><p>docker ps -a</p></blockquote></li><li><p>从仓库拉取原始镜像，以Nginx为例</p><blockquote><p>docker pull nginx</p></blockquote></li><li><p>查看所有镜像：</p><blockquote><p>docker images</p></blockquote></li><li><p>在使用一个镜像，在后台创建并运行一个容器，并添加镜像别名以及进行端口映射：</p><blockquote><p>docker run –name testNginx -p 80:80 -d nginx</p></blockquote></li><li><p>在后台创建并运行一个容器，并将<code>宿主主机指定目录</code>映射到<code>容器的指定目录</code></p><ul><li>将宿主主机下的<code>/home/index</code> 文件夹映射到 容器的<code>/usr/share/nginx/html</code>文件夹中</li><li>当前文件夹使用<code>pwd</code></li></ul><blockquote><p>docker run –name mappedNginx -p 8080:80 -d  -v /home/index:/usr/share/nginx/html nginx(镜像名)</p></blockquote></li><li><p>进入一个正在运行的容器：</p><blockquote><p>docker exec -it 镜像id bash</p></blockquote></li><li><p>运行/停止/重启一个容器</p><blockquote><p>docker start/stop/restart 容器ID</p></blockquote></li><li><p>提交某个镜像为新镜像</p><blockquote><p>docker commit 镜像id 新镜像名</p></blockquote></li><li><p>从容器里面拷贝文件到宿主主机</p><blockquote><p>docker cp 容器名：要拷贝的文件在容器里面的路径  要拷贝到宿主机的相应路径</p></blockquote><ul><li><p>例：容器名为1d1d,从容器里/cert路径下，将nginx.zip从容器里面拷到宿主机的/var/backup路径下面<br>在宿主机上执行命令： </p><p><code>docker cp 1d1d:/cert/nginx.zip /var/backup</code></p></li></ul></li><li><p>从宿主主机拷贝文件到容器中</p><blockquote><p>docker cp 要拷贝的文件路径  容器名：要拷贝到容器里面对应的路径</p></blockquote><ul><li>例：假设容器名为68b99,现在要将宿主机<code>/var/backup/nginx.zip</code>文件拷贝到容器里面的/cert路径下面   在宿主机上执行命令：<code>docker cp /var/backup/nginx.zip 68b99:/cert</code></li></ul></li><li><p>将一个镜像保存到本地文件中</p><blockquote><p>docker save 镜像名称 &gt;自定义镜像文件名.tar或者zip</p></blockquote></li><li><p>从文件恢复镜像</p><blockquote><p>docker load  &lt; 自定义镜像文件名.tar或者zip</p></blockquote></li><li><p>删除docker镜像</p><blockquote><p>docker rmi 镜像名称</p></blockquote></li></ul><h2 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h2><p>进入镜像后，默认网页文件在<code>/usr/share/nginx/html</code>下</p><ul><li><p>使用Dockerfile以指定文件创建一个Nginx镜像，并运行</p><ul><li><p>使用vim新建一个dockerfile文件，指定使用的镜像，将当前路径下的所有文件拷贝到目标nginx环境的html目录下</p><blockquote><p>vim dockerfile</p><p>进入编辑</p><p>FROM nginx</p><p>ADD ./  /usr/share/nginx/html  </p></blockquote></li><li><p>使用命令构建一个镜像</p><blockquote><p>docker build -t 自定义镜像名 </p></blockquote></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Linux </tag>
            
            <tag> 运维 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECMAScript6-8 常用特性</title>
      <link href="/2023/07/24/ES6-8/"/>
      <url>/2023/07/24/ES6-8/</url>
      
        <content type="html"><![CDATA[<p>本文将总结一ECMAScript 6-8 的常用特性，并使用一些案例来展示特性的使用场景，学以致用</p><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p>在ES6之前使用<code>var</code>关键字来声明变量，会出现重复声明导致变量被覆盖却不会报错的问题，且使用<code>var</code>声明的变量会被提升到最前进行解析，使用function声明的函数次之</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> camper = <span class="string">&#x27;James&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> camper = <span class="string">&#x27;David&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(camper);</span><br><span class="line"><span class="comment">// 打印出 &#x27;David&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;function a&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) </span><br><span class="line"><span class="comment">// 输出 20</span></span><br></pre></td></tr></table></figure><p>与<code>var</code>不同的是，当使用ES6新增的<code>let</code>来声明变量时，没有变量提升，且同一名字的变量只能被声明一次，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> camper = <span class="string">&#x27;James&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> camper = <span class="string">&#x27;David&#x27;</span>;</span><br><span class="line"><span class="comment">//输出错误 Uncaught SyntaxError: Identifier &#x27;camper&#x27; has already been declared</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;function a&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">10</span></span><br><span class="line"><span class="comment">//输出错误 Uncaught SyntaxError: Identifier &#x27;a&#x27; has already been declared</span></span><br></pre></td></tr></table></figure><p>let 声明的变量在{} （花括号）中参数局部作用域，作业是不会污染其他作用域，不会影响作用域链</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> i  = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line"><span class="comment">// 输出错误 Uncaught ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure><h2 id="Const"><a href="#Const" class="headerlink" title="Const"></a>Const</h2><p><code>const</code> 为 英文 <code>constant</code>的简写，其意为常量</p><p>使用<code>const</code>声明的常量拥有以下规则：</p><ul><li>常量一定要赋初值</li><li>与let一样产生块级作用域</li><li>常量名称一般为全大写字母</li><li>常量值不能修改，对象或者数组类型可修改内部数据，这意味着使用<code>const</code>声明的引用常量在堆内存中的地址不能发生变化</li></ul><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><ul><li><p>数组解构</p><p>在 ES6 里面，解构数组可以如同解构对象一样简单。与数组解构不同，数组的扩展运算会将数组里的所有内容分解成一个由逗号分隔的列表。所以，你不能选择哪个元素来给变量赋值，而对数组进行解构却可以让我们做到这一点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> [a, b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b); <span class="comment">// 1, 2</span></span><br><span class="line"><span class="comment">//变量a以及b分别被数组的第一、第二个元素赋值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我们甚至能在数组解构中使用逗号分隔符，来获取任意一个想要的值：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [a, b,,, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c); <span class="comment">// 1, 2, 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不通过第三个变量交换二者的值</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">8</span>, b = <span class="number">6</span>;</span><br><span class="line">[a,b] = [b,a]</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 应该等于 6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 应该等于 8</span></span><br></pre></td></tr></table></figure></li><li><p>对象解构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;ls&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">20</span>,</span><br><span class="line">    <span class="attr">getName</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123;name,age,getName&#125; = obj</span><br></pre></td></tr></table></figure></li><li><p>用于函数传参，这里也使用了ES6的新特性，参数默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">connent</span>(<span class="params">&#123;host=<span class="string">&quot;&quot;</span>,username=<span class="string">&quot;初始值&quot;</span>,password,port&#125;</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(host,username,password,port)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">connect</span>(&#123;</span><br><span class="line">    <span class="attr">host</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">username</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">password</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">port</span>:<span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在某些情况下，你可以在函数的参数里直接解构对象，这样的操作去除了多余的代码，使代码更加整洁</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">profileUpdate</span> = (<span class="params">profileData</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name, age, nationality, location &#125; = profileData;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面的操作解构了传给函数的对象。这样的操作也可以直接在参数里完成</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">profileUpdate</span> = (<span class="params">&#123; name, age, nationality, location &#125;</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">/* 对这些参数执行某些操作 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这样做还有个额外的好处：函数不需要再去操作整个对象，而仅仅是操作复制到函数作用域内部的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">     <span class="attr">start</span>: &#123; <span class="attr">x</span>: <span class="number">5</span>, <span class="attr">y</span>: <span class="number">6</span>&#125;,</span><br><span class="line">     <span class="attr">end</span>: &#123; <span class="attr">x</span>: <span class="number">6</span>, <span class="attr">y</span>: -<span class="number">9</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; start : &#123; <span class="attr">x</span>: startX, <span class="attr">y</span>: startY &#125;&#125; = a;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(startX, startY); <span class="comment">// 5, 6</span></span><br></pre></td></tr></table></figure></li><li><p>在上面的例子里，<code>a.start</code>将值赋给了变量<code>start</code>，<code>start</code>同样也是个对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用解构赋值来得到forecast.tomorrow的max，并将其赋值给maxOfTomorrow。</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">LOCAL_FORECAST</span> = &#123;</span><br><span class="line">  <span class="attr">today</span>: &#123; <span class="attr">min</span>: <span class="number">72</span>, <span class="attr">max</span>: <span class="number">83</span> &#125;,</span><br><span class="line">  <span class="attr">tomorrow</span>: &#123; <span class="attr">min</span>: <span class="number">73.3</span>, <span class="attr">max</span>: <span class="number">84.6</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getMaxOfTmrw</span>(<span class="params">forecast</span>) &#123;</span><br><span class="line">  <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">  <span class="comment">// 在这行以下修改代码</span></span><br><span class="line">  <span class="keyword">const</span> &#123;<span class="attr">tomorrow</span>:&#123;<span class="attr">max</span>:maxOfTomorrow&#125;&#125; = forecast; <span class="comment">// 改变这一行</span></span><br><span class="line">  <span class="comment">// 在这行以上修改代码</span></span><br><span class="line">  <span class="keyword">return</span> maxOfTomorrow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getMaxOfTmrw</span>(<span class="variable constant_">LOCAL_FORECAST</span>)); <span class="comment">// 应该为 84.6</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="简化对象写法"><a href="#简化对象写法" class="headerlink" title="简化对象写法"></a>简化对象写法</h2><p>如果在对象内赋值中发现属性名和属性值变量名称相同，则直接使用属性名即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;apple&#x27;</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="string">&#x27;banana&#x27;</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    apple,</span><br><span class="line">    banana,</span><br><span class="line">    <span class="title function_">getFruit</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">arrowFunc</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 执行的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">arrowFunc2</span> = (<span class="params"></span>) =&gt; (<span class="comment">/*返回的内容*/</span>)</span><br></pre></td></tr></table></figure><ul><li>箭头函数内部的this始终指向在声明时的作用域中的this，且<code>this</code>不可被<code>call()`` bind()`` apply()</code> 更改，通常应用于计时器(因为计时器中的this指向的是windows) 以及 定义类中的函数</li><li>内部没有arguments伪数组，意味着不能使用<code>arguments.callee()</code>方法进行自调用</li><li>当内部代码只有return语句时候，return可省略，使用()包裹返回的内容，但执行的代码使用{} 包裹</li></ul><h2 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h2><p>ES6 在函数中引入 rest参数， 用于获取函数实参，代替arguments </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">plus</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">    args.<span class="title function_">forEach</span>() <span class="comment">//arg作为一个数组，将传入的参数收入到数组中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>ES6 提供了一个新的创建对象的语法，使用关键字<code>class</code>。</p><p>值得注意的是，<code>class</code>只是一个语法糖，它并不像 Java、Python 这一类的语言一样，严格履行了面向对象的开发规范。</p><p>ES6 之前由原型链来进行对象的继承于重用，在构造函数的显式原型上添加公共方法，使用new 来实例化对象，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">SpaceShuttle</span> = <span class="keyword">function</span>(<span class="params">targetPlanet</span>)&#123;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">targetPlanet</span> = targetPlanet;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> zeus = <span class="keyword">new</span> <span class="title class_">SpaceShuttle</span>(<span class="string">&#x27;Jupiter&#x27;</span>);</span><br></pre></td></tr></table></figure><p><code>class</code>的语法只是简单地替换了构造函数的写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpaceShuttle</span> &#123;</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">targetPlanet</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">targetPlanet</span> = targetPlanet;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> zeus = <span class="keyword">new</span> <span class="title class_">SpaceShuttle</span>(<span class="string">&#x27;Jupiter&#x27;</span>);</span><br></pre></td></tr></table></figure><p>注意<code>class</code>关键字声明了一个新的函数，并在其中添加了一个会在使用<code>new</code>关键字创建新对象时调用的构造函数。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在ES5 中，我们常常用到<strong>组合继承</strong>来实现父子间的继承，即使用原型链继承的方式继承父类的方法，使用借用构造函数的方式继承父级的属性，最后再将子类原型的构造器指向自身</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Phone</span>(<span class="params">brand,price</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">brand</span> = brand;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">price</span> = price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SmartPhone</span>(<span class="params">brand,price,os,color</span>)&#123;</span><br><span class="line">    <span class="title class_">Phone</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>,brand,price);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">os</span> = os;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置子类的构造函数原型</span></span><br><span class="line"><span class="title class_">SmartPhone</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Phone</span>;</span><br><span class="line"><span class="keyword">const</span> iPhone = <span class="keyword">new</span> <span class="title class_">SmartPhone</span>(<span class="string">&#x27;Apple&#x27;</span>,<span class="number">1000</span>,<span class="string">&#x27;iOS&#x27;</span>,<span class="string">&#x27;white&#x27;</span>)</span><br></pre></td></tr></table></figure><p>以上继承方法存在一个问题，即创建一个对象需要调用2次父类构造函数，第一次为子类构造函数中借用构造属性时，第二次为子类使用原型继承父类构造函数的方法时</p><p>使用寄生组合式继承可以解决这个问题，这也是ES6的class继承实现原理，与上方的构造的区别就是：</p><ul><li>组合式继承先使用借用函数构造了子类实例的属性，然后再通过改变子类的原型执行父类实例的方式继承父类的方法，调用2次父类构造函数</li><li>寄生组合继承，先使用函数将子类的原型指向了父类的实例，而父类的实例是通过将父类的原型交给一个新函数的原型构造出的，没有调用父类构造器来构造，此后，在new子类构造函数的时候，才调用父类构造函数来构造子类属性，过程中只调用一次父类构造函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createObject</span>(<span class="params">prototype</span>)&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Fun</span> () &#123;&#125;</span><br><span class="line">    <span class="title class_">Fun</span>.<span class="property"><span class="keyword">prototype</span></span> = prototype</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fun</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">subType, superType</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> prototype = <span class="title function_">createObject</span>(superType.<span class="property">protyotype</span>)</span><br><span class="line">    prototype.<span class="property">constructor</span> = subType</span><br><span class="line">    subType.<span class="property"><span class="keyword">prototype</span></span> = prototype</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">SmartPhone</span>,<span class="title class_">Phone</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">SmartPhone</span>()</span><br></pre></td></tr></table></figure><p>ES6中的使用类继承，<code>super()</code>方法<strong>只能</strong>在constructor函数中使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">brand,price</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">brand</span> = brand;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">price</span> = price</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">call</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="comment">//打电话函数 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPhone</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Phone</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">brand,price,os,color</span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(brand,price)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">os</span> = os;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Photo</span>()&#123;</span><br><span class="line">        <span class="comment">//子类拍照函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iPhone = <span class="keyword">new</span> <span class="title class_">SmartPhone</span>(<span class="string">&#x27;Apple&#x27;</span>,<span class="number">1000</span>,<span class="string">&#x27;iOS&#x27;</span>,<span class="string">&#x27;white&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li><p>ES6 子类对父类方法重写：直接在子类中添加与父类的同名函数即可</p></li><li><p>ES6 类实例的get和set</p><ul><li><p>get和set方法时默认缺省的，如果声明了<code>get/set 变量名()&#123;&#125;</code>函数，则在读取或修改某个变量时时，都会调用一次该变量的<code>get</code>或<code>set</code>,在<code>get</code>中可以操控返回值，在<code>set</code>中可以操控修改的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">brand</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">brand</span> = brand;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">brand</span>()&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;读取品牌信息&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">brand</span>(<span class="params">val</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;设置品牌信息&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iPhone = <span class="keyword">new</span> <span class="title class_">Phone</span>()</span><br><span class="line">iPhone.<span class="property">brand</span> = <span class="string">&#x27;Apple&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ES6 对象方法扩展</p><ul><li>判断两个数值是否相等：<code>Object.is(a,b)</code></li><li>合并对象：<code>Object.assign(dstObj,srcObj)</code>，源对象会将属性合并到目标对象中，且覆盖目标对象相同的属性值</li><li>设置对象的隐式原型：<code>Object.setPrototypeOf(dstObj,srcObj)</code>,将源对象设置为目标对象的隐式原型<code>__proto__</code></li></ul></li></ul><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>在class声明的类中，使用<code>static</code>声明的方法将不能被class所创建的实例所调用，只能通过class本身进行调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">staticMethod</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Father</span>.<span class="title function_">staticMethod</span>()</span><br></pre></td></tr></table></figure><h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><ul><li><p>ES6之前，在构造函数上添加属性，其属性属于函数对象，并不属于构造函数本身，由此构造函数构造的对象不能得到构造函数对象的属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Phone</span>(<span class="params"></span>)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Phone</span>.<span class="property">name</span> = <span class="string">&#x27;xxx&#x27;</span>;</span><br><span class="line"><span class="title class_">Phone</span>.<span class="property">call</span> = <span class="keyword">function</span>(<span class="params"></span>)=&gt;&#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> iPhone = <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iPhone.<span class="property">name</span>) <span class="comment">//无法输出</span></span><br></pre></td></tr></table></figure></li><li><p>在ES6的类中，添加静态方法只需要将前缀改为<code>ststic</code>即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> name = <span class="string">&#x27;xxx&#x27;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="title function_">call</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Phone</span>.<span class="property">name</span>) <span class="comment">//只能通过此形式访问静态属性</span></span><br></pre></td></tr></table></figure><p>继承：</p></li></ul><h2 id="扩展运算符…"><a href="#扩展运算符…" class="headerlink" title="扩展运算符…"></a>扩展运算符…</h2><p>将伪数组转换成数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> divs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> divsArray = [...divs];</span><br></pre></td></tr></table></figure><h2 id="ES6的模块引入方式"><a href="#ES6的模块引入方式" class="headerlink" title="ES6的模块引入方式"></a>ES6的模块引入方式</h2><p>在过去，我们会使用<code>require()</code>函数来从外部文件或模块中引入函数或者代码。这时候会遇到一个问题：有些文件或者模块会特别大，但你却往往只需要引入其中的一些核心代码。</p><p>ES6 给我们提供了<code>import</code>这个便利的工具。通过它，我们能够从外部的文件或者模块中选择我们需要的部分进行引入，从而节约载入的时间和内存空间。</p><p>ES6 同样提供的 <code>export</code> / <code>export default</code>  关键字 来暴露一个模块的方法或者变量，具体使用方式请查阅MDN文档</p><h2 id="ES6-模块化"><a href="#ES6-模块化" class="headerlink" title="ES6 模块化"></a>ES6 模块化</h2><ul><li><p>在js文件中使用<code>export</code> / <code>export default</code>暴露函数</p></li><li><p>在html文件中使用： 使用模块的函数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">import</span> * <span class="keyword">as</span> module1 <span class="keyword">from</span> <span class="string">&quot;./xxx.js&quot;</span> <span class="comment">//可使用as 进行重命名</span></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">import</span> &#123;xxx&#125; <span class="keyword">from</span> <span class="string">&quot;./xxx.js&quot;</span> <span class="comment">//解构赋值</span></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> module3&#125; <span class="keyword">from</span> <span class="string">&quot;./xxx.js&quot;</span> <span class="comment">//将默认暴露的模块在使用时重命名</span></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">import</span> module4 <span class="keyword">from</span> <span class="string">&quot;./xxx.js&quot;</span> <span class="comment">//直接使用，只能针对默认暴露的模块</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>暴露模块的三种方式：</p><ol><li><code>export xxx</code></li><li><code>export &#123;a,b,c,...&#125;</code></li><li><code>export default &#123;&#125;</code> ，访问时多一层default</li></ol></li><li><p>使用入口js文件</p><ul><li>创建一个<code>app.js</code> 文件，并在html中引入这个作为模块的js文件</li><li>在<code>app.js</code> 文件中引入其他的模块，并使用</li></ul></li><li><p>兼容性：使用<code>babel</code>将 ES6 转换为 ES5 语法</p><ul><li>需要使用npm安装<code>babel-cli</code> <code>babel-present-env</code> <code>browserify(webpack)</code> </li><li>运行<code>npx babel 源js文件/文件夹 目的js文件/文件夹</code></li><li>使用入口文件将一些列模块文件进行打包：<code>npx browserify 源入口js文件 -o 目标入口js文件 </code></li></ul></li></ul><h2 id="Symbol-基本数据类型"><a href="#Symbol-基本数据类型" class="headerlink" title="Symbol 基本数据类型"></a>Symbol 基本数据类型</h2><ul><li>ES6引入的第六个基本数据类型，标识独一无二的值，类似于字符串</li><li>symbol 的值是唯一的，用来解决命名冲突问题</li><li>symbol不能与其他数据进行任何运算，只能进行相等判断</li><li>symbol定义的对象属性不能使用<code>for ... in ...</code> 来遍历，但是可以使用<code>reflect.ownKeys()</code> 来获取key</li><li>使用场景：<ul><li>为对象添加独一无二的值/函数,避免冲突</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="title class_">Symbol</span>(<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">Symbol</span>(<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a === b) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p><strong>Iterator</strong>是一种接口，为不同 数据结构提供同一的访问机制，任何数据结构只要部署<code>Iterator</code>接口皆可以完成遍历操作 </p><p>每个可迭代的数据类型的实例的隐式原型中都包含一个<code>Symbol(Symbol.iterator)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">FRUIT</span> = [<span class="string">&#x27;apple&#x27;</span>,<span class="string">&#x27;banana&#x27;</span>,<span class="string">&#x27;orange&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> iterator = <span class="variable constant_">FRUIT</span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()) <span class="comment">// &#123;value:&#x27;apple&#x27;,done:false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>())<span class="comment">// &#123;value:&#x27;banana&#x27;,done:false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>())<span class="comment">// &#123;value:&#x27;orange&#x27;,done:false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>())<span class="comment">// &#123;value:undefined&#x27;,done:true&#125;</span></span><br></pre></td></tr></table></figure><p>自定义遍历对象：</p><p>自定义一个对象中的迭代器，迭代指定部分的数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">type</span>:<span class="string">&#x27;fruit&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>:[<span class="string">&#x27;apple&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;banana&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;orange&#x27;</span></span><br><span class="line">         ],</span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()&#123;</span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">next</span>:<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; <span class="variable language_">this</span>.<span class="property">name</span>.<span class="property">length</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;<span class="attr">value</span>:<span class="variable language_">this</span>.<span class="property">name</span>[i++],<span class="attr">done</span>:<span class="literal">false</span>&#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;<span class="attr">value</span>:<span class="literal">undefined</span>,<span class="attr">done</span>:<span class="literal">true</span>&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">of</span> obj2 )&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h2><p>生成器函数是ES6提供的异步编程解决方案之一，语法行为与普通函数完全不同，生成器函数默认返回一个迭代对象，可使用使用迭代器的<code>next()</code>方法 来手动执行函数内部每一行代码 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> * <span class="title function_">gen</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> genIterator = <span class="title function_">gen</span>();</span><br><span class="line">genIterator.<span class="title function_">next</span>(); <span class="comment">//apple</span></span><br><span class="line">genIterator.<span class="title function_">next</span>(); <span class="comment">//banana</span></span><br><span class="line">genIterator.<span class="title function_">next</span>(<span class="title function_">gen</span>()); <span class="comment">//orange</span></span><br></pre></td></tr></table></figure><p>迭代器对象的<code>netx()</code>方法的传参可缺省，默认值为调用的函数</p><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><ul><li>yield关键字后面的表达式的值返回给生成器的调用者。它可以被认为是一个<em>基于生成器的版本</em>的<strong>return</strong>关键字。</li><li>yield实际返回一个迭代器对象 例如 <code>&#123;value:&quot; &quot;,done: false &#125;</code>  </li><li>yield 只能配合生成器函数使用</li><li>yield并不能直接生产值，而是产生一个等待输出的函数</li><li>某个函数包含了yield，意味着这个函数已经是一个Generator</li><li>除IE外，其他所有浏览器均可兼容（包括win10 的Edge）</li><li>如果yield在其他表达式中，需要用()单独括起来</li><li>next()可无限调用，但既定循环完成之后总是返回<code>undeinded</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>  * <span class="title function_">count</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; <span class="literal">true</span> ; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> reset = <span class="keyword">yield</span> i;  <span class="comment">//到此处直接返回一个迭代对象</span></span><br><span class="line">        <span class="keyword">if</span> (reset) &#123; i = -<span class="number">1</span>;&#125; <span class="comment">//这一行语句不会被执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = <span class="title function_">count</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">next</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">next</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">next</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">next</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">next</span>())</span><br></pre></td></tr></table></figure><h3 id="yield参数"><a href="#yield参数" class="headerlink" title="yield参数"></a>yield参数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>  * <span class="title function_">test</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">var</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x,y,z)</span><br><span class="line">    <span class="keyword">return</span> (x+y+z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="title function_">test</span>(<span class="number">5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">next</span>());   <span class="comment">// 6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">next</span>(<span class="number">12</span>)); <span class="comment">// 8</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">next</span>(<span class="number">13</span>)); <span class="comment">// 42 = 24 + 5 + 13</span></span><br></pre></td></tr></table></figure><p>当<code>next()</code>传入参数时，只有上一个yield整体等于传入参数，当前迭代的yield仍然返回之后的表达式的值</p><p>异步编程示例1：解决回调地狱</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回调地狱</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//更多嵌套..</span></span><br><span class="line">&#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用生成器函数的做法：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">one</span> ()&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>);</span><br><span class="line">        iterator.<span class="title function_">next</span>();</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">two</span> ()&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>);</span><br><span class="line">        iterator.<span class="title function_">next</span>();</span><br><span class="line">    &#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">three</span> ()&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">333</span>);</span><br><span class="line">        iterator.<span class="title function_">next</span>();</span><br><span class="line">    &#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> * gen ()&#123;</span><br><span class="line">    one ();</span><br><span class="line">    two ();</span><br><span class="line">    three ();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iterator = <span class="title function_">gen</span>();</span><br><span class="line">iterator.<span class="title function_">next</span>(); <span class="comment">//从one开始自动遍历</span></span><br></pre></td></tr></table></figure><p>异步编程示例2：模拟业务处理逻辑</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟购物传递信息流程：获取用户数据 → 获取订单数据 → 获取商品数据</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getUserInfo</span>(<span class="params">userId</span>)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> userInfo = <span class="string">&quot;通过传入的id获取到用户信息&quot;</span></span><br><span class="line">        iterator.<span class="title function_">next</span>(userInfo);</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getOrderInfo</span>(<span class="params">userInfo</span>)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> orderInfo = <span class="string">&quot;通过传入的id获取到用户信息&quot;</span></span><br><span class="line">        iterator.<span class="title function_">next</span>(orderInfo);</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getGoodsInfo</span>(<span class="params">orderInfo</span>)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> goodsInfo = <span class="string">&quot;通过传入的orderInfo获取到商品信息&quot;</span></span><br><span class="line">        iterator.<span class="title function_">next</span>(goodsInfo);</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> * <span class="title function_">gen</span>(<span class="params">userId</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> userInfo = <span class="keyword">yield</span> <span class="title function_">getUserInfo</span>(userId);</span><br><span class="line">    <span class="keyword">let</span> orderInfo = <span class="keyword">yield</span> <span class="title function_">getOrderInfo</span>(userInfo);</span><br><span class="line">    <span class="keyword">let</span> goodsInfo = <span class="keyword">yield</span> <span class="title function_">getGoodsInfo</span>(orderInfo);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(goodsInfo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iterator = <span class="title function_">gen</span>(<span class="number">11</span>);</span><br><span class="line">iterator.<span class="title function_">next</span>();</span><br></pre></td></tr></table></figure><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>ES6 引入的异步编程结局方案，<code>Promise</code>是一个构造函数，用来封装异步操作，且可获取成功与失败的结果，</p><p><code>Promise</code>接收一个函数作为参数，其中函数的参数分为<code>resolve</code>和<code>reject</code> 两个函数来分别处理成功与失败两种状态，函数内部进行一系列异步操作，在最后调用<code>resolve(data)</code> 和 <code>reject(data)</code>分别赋予Promise实例成功与失败两种状态:</p><ul><li>调用<code>resolve(data)</code>，返回一个状态为成功(fulfilled)的<code>Promise</code>对象，可以使用<code>then()</code>进行进一步处理</li><li>调用<code>reject(data)</code>，返回一个失败(rejected)的<code>Promise</code>对象，如果没有使用<code>then()</code>进行进一步失败处理，浏览器就会抛出异常，值为data，</li></ul><p>在执行以上操作后可以调用:</p><ul><li><p>then()方法</p><ul><li><p>then()方法接收两个函数：<code>function(value)&#123;...&#125;</code> <code>function(reason)&#123;...&#125;</code> </p><ul><li>当p在初始化时的异步操作调用了<code>reslove()</code>之后，执行<code>then()</code>方法中的第一个回调函数<code>function(value)&#123;...&#125;</code> 代码，<code>value</code>为<code>reslove()</code>的参数</li><li>当p在初始化时的异步操作调用了<code>reject()</code>之后，执行<code>then()</code>方法中的第二个回调函数<code>function(reason)&#123;...&#125;</code>代码，<code>reason</code>为 <code>reject()</code>的参数</li></ul></li><li><p><code>promise.then()</code>方法在调用后，返回一个Promise对象。</p></li><li><p>当在<code>promise.then()</code>的成功/失败的回调中使用<code>return</code><strong>返回一个<code>非Promise对象的值</code>时，<code>promise.then()</code>仍然返回一个状态为成功(fulfilled)的Promise对象</strong>，其中带有promise状态以及返回的值，其中Object类型会被转换成 <code>Object</code>字符串</p></li><li><p>当在<code>promise.then()</code>中使用<code>return</code>返回了一个<code>Promise对象</code>时，此时<code>promise.then()</code>返回的<code>promise</code>对象的成功与否 由 返回的<code>promise</code>对象状态 决定</p></li><li><p>当在<code>promise.then()</code>中<strong>使用<code> throw new Error()</code> 或者<code>thow &quot;error&quot;</code>抛出错误，则<code>promise.then()</code>返回的<code>Promise</code>对象为失败状态</strong>，且promise失败值为 <code>thow</code>抛出值</p></li></ul></li><li><p>案例1：使用Promise处理文件异步读取</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span>&#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./test.txt&#x27;</span>,<span class="function">(<span class="params">err,data</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            <span class="title function_">reject</span>(err)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="title function_">resolve</span>(data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value.<span class="title function_">toString</span>());</span><br><span class="line">&#125;,<span class="function"><span class="params">reason</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>案例2：使用Promise 发送AJAX请求：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XmlHttpRequest</span>();</span><br><span class="line">    xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    xhr.<span class="title function_">send</span>();</span><br><span class="line">    xhr.<span class="property">onreadstatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.<span class="property">readyState</span> === <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">response</span>);</span><br><span class="line">                <span class="title function_">resolove</span>(xhr.<span class="property">response</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">status</span>)</span><br><span class="line">                <span class="title function_">reject</span>(xhr.<span class="property">status</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value.<span class="title function_">toString</span>());</span><br><span class="line">&#125;,<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>state往往就是一个实体固有的状态。<br>status则偏向于运行时状态。</p></blockquote></li></ul><p><code>Promise.then()</code>方法的链式调用：</p><ul><li><p>在链式调用的then()方法中，在回调函数中的返回值会作为下一个then()方法中回调的<code>value</code>或<code>reason</code>值，只要在<code>then()</code>的所有回调中使用 <code>return</code>返回了非<code>Promise</code>对象 则状态均为成功<code>reslove</code></p></li><li><p>在<code>then()</code>所有回调函数内使用<code>throw</code>抛出字符串、错误对象 new Error()，则返回的Promise对象状态均为 失败 <code>reject</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> promise.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">   .<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p><code>Promise.then()</code>模拟场景：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">reslove, reject</span>) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> userId = <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">if</span> (userId) &#123;</span><br><span class="line">              <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;请求到了userId&quot;</span>);</span><br><span class="line">              <span class="title function_">reslove</span>(userId)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;没有请求到userId&quot;</span>);</span><br><span class="line">              <span class="title function_">reject</span>();</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> a = p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">reslove, reject</span>) &#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">              <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;请求到了用户信息&quot;</span>);</span><br><span class="line">              <span class="title function_">reslove</span>(value + <span class="string">&quot;用户信息&quot;</span>)</span><br><span class="line">          &#125;, <span class="number">1000</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&#x27;没有请求到用户的用户信息&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">reslove, reject</span>) &#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">              <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;请求到了订单信息&quot;</span>);</span><br><span class="line">              <span class="title function_">reslove</span>(<span class="string">&quot;订单信息&quot;</span>)</span><br><span class="line">          &#125;, <span class="number">1000</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&#x27;没有请求到的订单信息&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(p);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br></pre></td></tr></table></figure></li><li><p>catch()方法：catch()的功能与then()第二个回调函数类似，在Promise对象的状态为失败时调用，一般用于获取</p></li></ul><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul><li><p>集合内部的值不会重复，</p></li><li><p>添加和删除的方法分别为<code>add()</code> <code>delete()</code></p></li><li><p>使用<code>has()</code>方法检测目标是否存在于集合中，返回t/f </p></li><li><p>使用<code>clear()</code>方法清除集合所有元素</p></li><li><p>集合元素个数量使用size()方法得到</p></li><li><p>应用案例：</p><ul><li><p>数组去重：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>]</span><br><span class="line"><span class="keyword">let</span> result = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)]</span><br></pre></td></tr></table></figure></li><li><p>求两数组交集</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> arrSet = <span class="keyword">new</span> <span class="title class_">Set</span>(arr2);</span><br><span class="line"><span class="keyword">let</span> result = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)].<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> arrSet.<span class="title function_">has</span>(item))</span><br></pre></td></tr></table></figure></li><li><p>求两数组的并集</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">let</span> arrSet = <span class="keyword">new</span> <span class="title class_">Set</span>(arr);</span><br><span class="line">[...<span class="keyword">new</span> <span class="title class_">Set</span>(arr2)].<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!arrSet.<span class="title function_">has</span>(item)) &#123;</span><br><span class="line">        arrSet.<span class="title function_">add</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrSet);</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">let</span> union = [...<span class="keyword">new</span> <span class="title class_">Set</span>([...arr, ...arr2])];</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>ES6 引入的 新数据结构，类似于对象，结构为键值对集合，但是key的类型不一定是字符串，可以是任何类型的值，map同样实现了迭代器接口，可以使用<code>[...]</code>，和<code>for of</code> </p><ul><li>Map元素个数量使用<code>size()</code>方法得到</li><li>new Map()可以接收一个键值对形式的数组：一般以一个<code>key</code>和一个<code>value</code>组成的基本数组，返回一个Map对象</li><li>使用<code>set(key,value)</code> 增加一个元素，并返回更新后的map实例</li><li>使用<code>delete(key)</code> 删除一个键值对，并返回布尔值，找到key并删除value返回true，没有找到key返回false</li><li>使用<code>get(key)</code>返回key的value值</li><li>使用<code>has()</code>检测map是否包含某个元素 ，返回布尔值</li><li>使用<code>clear()</code> 清空map ,返回undefined</li></ul><h2 id="ES6-数值方法扩展"><a href="#ES6-数值方法扩展" class="headerlink" title="ES6 数值方法扩展"></a>ES6 数值方法扩展</h2><ul><li><p>使用<code>Number.EPSILON</code> 来解决js计算精度问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">equal</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(a-b) &lt; <span class="title class_">Number</span>.<span class="property">EPSILON</span> ? <span class="attr">true</span>:<span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>检测数值是否为NaN：<code>Number.isNaN()</code>， 返回t/f</p></li><li><p>将小数部分抹去：<code>Number.trunc(floatNumber)</code>， 返回值</p></li><li><ul><li></li></ul></li></ul><h2 id="ES7-新特性"><a href="#ES7-新特性" class="headerlink" title="ES7 新特性"></a>ES7 新特性</h2><ul><li><code>Array.prototype.includes(value)</code>方法，判断value是否存在于数组中，返回布尔值</li><li>使用<code>**</code> 进行幂运算：<code>2 ** 2</code> 等同于 <code>Math.pow(2,2)</code></li></ul><h2 id="ES8-新特性"><a href="#ES8-新特性" class="headerlink" title="ES8 新特性"></a>ES8 新特性</h2><ul><li><p>async 函数</p><ul><li>async 函数为将await 之后的<strong>表达式</strong>以及<strong>await以下的所有语句</strong>都放入异步任务的同步函数</li><li>使用<code>async</code> 为前缀声明的函数的返回值为<code>Promise</code>对象</li><li>返回的<code>Primise</code>对象的状态由<code>async</code> 函数执行的返回值决定，与<code>promise.then()</code>回调函数的<code>return</code>原理相同：如果成功，返回成功promise，并将值放入value中；返回失败promise，则将失败值放入value中</li></ul></li><li><p>await 表达式</p><ul><li><code>await </code>必须写在async函数内部</li><li><code>await</code> <strong>等待右侧promise产生之后，返回值的过程</strong>属于异步微任务，<code>await</code>必须等待到右侧的promise的成功与失败的状态后，线程才会继续执行下面的代码</li><li><code>await</code> 右侧表达式一般为<code>Promise</code> 对象</li><li><code>await</code> 右侧的<code>Promise</code>对象如果状态为成功，则返回其成功的值<code>PromiseValue</code></li></ul></li><li><p><code>await</code> 右侧的<code>Promise</code>对象如果状态为失败，浏览器就会抛出异常，无返回值，需要使用<code>try catch捕获</code> ，<code>catch</code>的参数<code>e</code>为<code>Promise</code>对象失败的值<code>PromiseValue</code></p></li></ul><p>将 async 函数与 await函数相结合使用，将**<code>await </code>等待 <code>promise</code> 之后并返回值** 这过程，放入异步微任务，而在await 之后的代码语句，需要等待<code>await</code> 产生结果后，才能继续执行，且是在在微任务中执行，换句话说，遇到<code>await</code>时就把<code>await</code>之后的代码放入异步微任务，然后再继续向下执行，</p><ul><li><p>案例1：读取文件，使用async函数接收文件信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fileReader</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        fs.<span class="title function_">readFile</span>(<span class="string">&#x27;文件路径&#x27;</span>,<span class="function">(<span class="params">err,data</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err) =&gt; <span class="title function_">reject</span>(err);</span><br><span class="line">            <span class="title function_">resolve</span>(data);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">dataReceiver</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> fileData = <span class="keyword">await</span> <span class="title function_">fileReader</span>();</span><br><span class="line">    <span class="keyword">return</span> fileData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>案例2：使用async 与 await 发送AJAX请求并处理消息，这也是<code>axios</code>的实现原理之一</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">AjaxRequest</span>(<span class="params">requestUrl</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XmlHttpRequest</span>();</span><br><span class="line">        xhr.<span class="title function_">open</span>(<span class="string">&#x27;get&#x27;</span>,requestUrl);</span><br><span class="line">        xhr.<span class="title function_">send</span>();</span><br><span class="line">        xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.<span class="property">readyState</span> === <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>)&#123;</span><br><span class="line">                <span class="title function_">reslove</span>(xhr.<span class="property">response</span>)</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="title function_">reject</span>(xhr.<span class="property">status</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getMessage</span>(<span class="params">requestUrl</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> requestData;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">    requestData = <span class="keyword">await</span> <span class="title class_">AjaxRequest</span>(requestUrl); </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(requestData) <span class="comment">//此时await为同步代码，会产生阻塞，当await获得到promise值后才能执行到这一步</span></span><br><span class="line">        <span class="keyword">return</span> requestData;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>案例3：在React组件生命周期中使用async函数 和await 处理请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="ES8-对象扩展"><a href="#ES8-对象扩展" class="headerlink" title="ES8 对象扩展"></a>ES8 对象扩展</h2><ul><li><p><code>Object.keys(object)</code> 获取对象所有的键，返回一个数组</p></li><li><p><code>Object.values(object)</code> 获取对象所有的键值，返回一个数组</p></li><li><p><code>Object.values(object)</code> 获取对象的所有键值，以对象的形式生成一个数组，可以通过数组创建<code>map</code>对象</p></li><li><p>获得对象属性的描述对象 <code>Object.getOwnPropertyDescriptions(object)</code>，返回一个对象，描述object内部所有属性的选项设置(可读、可写、可枚举等)</p></li><li><p>ES5 补充：<code>Object.defineProperty()</code>，对对象属性进行监听，注意不能在get/set中直接调用被修改的属性值，否则造成死循环</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj,propertyName,&#123;</span><br><span class="line">    <span class="comment">//为此当前对象属性设置函数，例如set、get</span></span><br><span class="line">    <span class="comment">//钩子分别在获取、设置属性值时调用</span></span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    <span class="title function_">set</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ECMAScript </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现ES6的新特性——Promise</title>
      <link href="/2020/08/23/Promise/"/>
      <url>/2020/08/23/Promise/</url>
      
        <content type="html"><![CDATA[<blockquote><p>ECMAscript 6 原生提供了 Promise 对象。Promise 对象代表了未来将要发生的事件，用来传递异步操作的消息。</p></blockquote><h2 id="了解JavaScript事件循环"><a href="#了解JavaScript事件循环" class="headerlink" title="了解JavaScript事件循环"></a>了解JavaScript事件循环</h2><p>在解析promise的机制之前，我们需要掌握浏览器的事件循环，此处引用一张事件循环流程图</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/EricReevess/proxy/master/img/event_loop.png" alt="image"></p><p>在上图中的最后2两行队列均为异步队列，可以观察到，每个宏任务队列后都跟随一个微任务队列，</p><blockquote><p>注意，需要把第一个同步任务，也就是首次同步执行的代码视为一个宏任务</p></blockquote><p>在执行栈中的函数遇到异步任务时，会将异步任务交给 右侧相应模块进行处理</p><p>第一个队列为宏任务队列，也是主要的异步任务队列，其中的任务由计数器处理模块，ajax请求线程与文件处理模块(NodeJs)进行推入，</p><p>第二个队列为微任务队列，在promise对象的<code>then()</code>方法，与Node中的<code>process.nextTick()</code>都会在执行时，将传入的回调函数推入<strong>当前宏任务后</strong>的微任务队列，</p><p>当宏任务与微任务相互嵌套时，此时就可能会产生一些异步任务队列与执行栈会相互添加内容，即在栈中异步队列的函数 与 栈中函数产生异步任务，因此形成循环，而JS的异步任务常常通过事件进行执行，也就是为什么这种循环叫做事件循环</p><h2 id="Promise-是什么？"><a href="#Promise-是什么？" class="headerlink" title="Promise 是什么？"></a>Promise 是什么？</h2><p>抽象的说，Promise是JavaScript中进行异步编程的一个新的解决方案</p><p>具体的说，Promise就是一个构造函数，通过函数构造出的实例可以封装一系列异步操作，并可以从中得到异步操作产生的结果数据</p><h2 id="为什么要使用Promise？"><a href="#为什么要使用Promise？" class="headerlink" title="为什么要使用Promise？"></a>为什么要使用Promise？</h2><blockquote><p>使用链式调用的编写方式，解决异步回调地狱（代码缩进）的问题 </p></blockquote><p>所谓回调地狱，就是当我们要进行多个异步操作的时候，此时一个回调函数包含另一个异步操作，当异步操作数量达到一定程度时，代码会向右持续缩进，这样会使得程序可读性和可维护性下降</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回调地狱</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//更多嵌套..</span></span><br><span class="line">&#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>在上面的计时器回调代码中，我们可以看到代码缩进一直在增加，在实际的开发环境中，如果有几十个回调，那么代码就变得非常的不美观，且不易维护</p><p>但在promise的链式调用中，只需要将上一个处理的对象使用方法继续进行处理，且捕获异常和错误也比较方便</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/EricReevess/proxy/master/img/image-20200826225041424.png" alt="image-20200826225041424"></p><p>解决异步任务的最佳办法，是将promise对象配合 ES8 中新增的 async函数与await来操作结果，其中await会等待promise的值，并将之后的语句放入异步任务中执行</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/EricReevess/proxy/master/img/image-20200826225805992.png" alt="image-20200826225805992"></p><h2 id="Promise-a-规范"><a href="#Promise-a-规范" class="headerlink" title="Promise/a+ 规范"></a>Promise/a+ 规范</h2><p>规范出现的原因：</p><ol><li>我们不知道异步请求什么时候返回数据，所以我们就需要些回调函数。但是在某些情况下我们需要知道数据是在什么时候返回的，然后进行一些处理。</li><li>当我们在异步回调里面继续执行异步操作的时候，这样就形成了异步回调函数的嵌套，不好维护以及查找问题</li></ol><p>规范的内容是什么？</p><ol><li>不管进行什么操作都返回一个Promise实例对象，这个对象里面会有一些属性和方法</li><li>这个Promise实例对象有三种状态</li><li>一个promise对象只能改变一次状态，而且都会返回一个数据<ul><li>pending<ul><li>默认状态</li></ul></li><li>fulfilled<ul><li>调用<code>resolve()</code>返回的状态</li><li>英文含义为 已完成 ，实际上表示成功的状态</li><li>返回value</li></ul></li><li>rejected<ul><li>调用<code>reject()</code>返回的状态</li><li>英文含义为 拒绝了  ， 实际上表示为失败的状态</li><li>返回reason</li></ul></li></ul></li></ol><h2 id="Promise执行机制"><a href="#Promise执行机制" class="headerlink" title="Promise执行机制"></a>Promise执行机制</h2><h3 id="Promise的任务执行流程"><a href="#Promise的任务执行流程" class="headerlink" title="Promise的任务执行流程"></a>Promise的任务执行流程</h3><ol><li>创建一个Promise对象，处于<code>pending</code>状态</li><li>执行异步操作，成功，调用<code>resolve()</code>；失败，调用<code>reject()</code> ，都会返回一个新的promise对象</li><li>执行实例promise.then()方法，按照当前状态，执行内部的回调，可重复步骤2</li></ol><blockquote><p>Promise实例利用闭包，通过调用函数来改变不同的状态，由此来执行对应的回调函数</p></blockquote><p>下列代码中，创建了一个promise对象同时立即改变状态，而跟随其后又连续调用2个<code>then()</code>，每个<code>then()</code>调用结束都会<strong>默认</strong>返回一个新的<code>promise</code>对象，而<code>then()</code>中成功/失败的回调内部返回的值则为新<code>promise</code>的<code>value</code>，在这一系列调用中如果没有<strong>抛出任何异常</strong>或者<strong>返回任何失败的promise</strong>，则都会视为<strong>成功</strong>的<code>promise</code></p><p>注意：<strong>throw xxx 均为失败状态 ,xxx 为reason的值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>((<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="number">11</span>)</span><br><span class="line">  &#125;)).<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value &#x27;</span>,value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reason&#x27;</span>, reason)</span><br><span class="line">    &#125;</span><br><span class="line">  ).<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value &#x27;</span>,value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reason&#x27;</span>, reason)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>如果想在结果的回调中再执行一个异步任务（也可以说是触发一系列的异步任务），在结果回调函数内需要返回一个新的<code>promise</code>对象，并成为.then()的返回结果可以在下一次.then()做出更多的操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>((<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="number">11</span>)</span><br><span class="line">  &#125;)).<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span>&#123;</span><br><span class="line">          <span class="comment">// 异步任务，请求之类的</span></span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">          <span class="title function_">resolve</span>(<span class="string">&#x27;22&#x27;</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(reason)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  ).<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value &#x27;</span>,value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reason&#x27;</span>, reason)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><h3 id="Promise异常传递"><a href="#Promise异常传递" class="headerlink" title="Promise异常传递"></a>Promise异常传递</h3><p>当<code>promise</code>对象进行一系列任务操作时，在Promise链式调用的回调中，不编写处理失败的回调函数，只在链式调用的末尾使用<code>catch()</code>处理异常情况，只要遇到了失败状态的<code>promise</code>，就会将失败的promise逐级传递到最后的<code>catch()</code>失败处理回调中，如果不抛出异常或者返回失败的<code>promise</code>对象，<code>.catch()</code>和<code>.then()</code> 一样，返回成功的<code>promise</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="number">0</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value &#x27;</span>,value)</span><br><span class="line">    &#125;).<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value &#x27;</span>,value)</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fatalError&#x27;</span>, reason)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Promise-中断传递"><a href="#Promise-中断传递" class="headerlink" title="Promise 中断传递"></a>Promise 中断传递</h3><p>如果因为某个错误，想要在链式调用的过程中中断整个过程，则需要返回一个<code>pending</code>状态的promise，即返回<code>new Promise(()=&gt; &#123;&#125;)</code></p><p>原理：因为<code>then()</code>内部的回调函数最终是由调用执行器中的<code>resolve()</code>或者<code>reject()</code>从而触发执行的，返回一个pending的<code>promise</code>显然并没有改变任何状态，因为初始化<code>promise</code>的状态就是<code>pending</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="number">0</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value &#x27;</span>,value)</span><br><span class="line">    &#125;).<span class="title function_">then</span>(</span><br><span class="line">       <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value &#x27;</span>,value)</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">           <span class="function"><span class="params">return</span> =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">()=&gt;</span> &#123;&#125;)</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fatalError&#x27;</span>, reason)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="实现-Promise"><a href="#实现-Promise" class="headerlink" title="实现 Promise"></a>实现 Promise</h2><h3 id="方法以及规则"><a href="#方法以及规则" class="headerlink" title="方法以及规则"></a>方法以及规则</h3><p>在了解了官方Promise的使用方法后，为了实现Promise，我们需要更详细的内部原理与运行机制</p><hr><ul><li>构造函数<code>Promise</code>的方法<ul><li><code>Promise(executor)</code></li><li><code>Promise.resolve(value)</code></li><li><code>Promise.reject(reason)</code></li><li><code>Promise.all(promiseArray)</code></li><li><code>Promise.race(promiseArray)</code></li></ul></li><li>实例对象<code>promise</code>的方法<ul><li><code>promise.then(onResolved , onRejected)</code></li><li><code>promise.catch(onRejected)</code></li></ul></li><li>规则：<ol><li>调用<code>Promise(executor)</code>进行初始化<code>promise</code>时：<ol><li>改变状态与值的内部函数<code>resolve(value)</code>或者<code>reject(reason)</code>的调用类型为<strong>异步调用</strong>，意味着可能等待<code>then()</code>执行后才进行调用</li><li>如果存在多次调用<code>resolve(value)</code>或者<code>reject(reason)</code>，则以第一个调用为准，舍弃后续调用</li><li><code>resolve(value)</code>和<code>reject(reason)</code>都不执行，而是使用throw xx来抛出错误，需要将<code>promise</code>状态设置成<code>rejected</code></li><li>返回一个<code>Promise</code>实例</li></ol></li><li>调用<code>promise.then()</code>时<ol><li><code>promise.then()</code>应该返回一个新的<code>promise</code>对象</li><li>如果<code>promise</code>的状态为pending，那么将其推入实例的回调函数数组中</li><li>如果<code>promise</code>的状态为fulfilled或者rejected，那么将传入的回调立即作为异步函数执行</li><li>如果在规则2.3满足的情况下，回调函数返回了一个<code>promise</code>对象，那么，<code> promise.then()</code>返回的新<code> promise</code> 对象为回调函数返回的对象</li><li><code>promise.then()</code>能够实现传透的功能，即在不传入失败的回调函数<code>onRejected</code>或者成功的回调函数<code>onResloved</code>时，使用<code>then()</code>的链式调用能够将失败的<code>promise</code>往后传递</li></ol></li><li>调用<code>Promise.resolve(value)</code>时，<code>value</code>可以为<code>promise</code>类型，也可以为非<code>promise</code>类型，调用后返回一个成功/失败的<code>promise</code></li><li>调用<code>Promise.reject(reason)</code>时，<code>reason</code> 只能是非<code>promise</code>类型的值</li><li>调用<code>Promise.all(promiseArray)</code> 应该在所有promise均为成功的情况下，返回一个值为所有<code>promise</code>的值的数组的新的成功的<code>promise</code>，否则，返回第一个失败的<code>promise</code></li><li>调用<code>Promise.race(promiseArray)</code> 应该返回数组中第一个改变状态的<code>promise</code></li></ol></li></ul><h3 id="Promise构造函数"><a href="#Promise构造函数" class="headerlink" title="Promise构造函数"></a>Promise构造函数</h3><p>Promise主构造函数，接收一个函数作为执行器，执行后<strong>立即</strong>产生一个<code>promise</code>对象</p><ul><li>构造函数内部拥有三个属性<ul><li>state：保存状态</li><li>data：保存数据</li><li>callbacks：保存一个<code>then()</code>方法添加的回调函数的对象</li></ul></li><li>在<code>resolve()</code>和<code>reject()</code>对<code>this.state</code>和<code>this.data</code>的改变后，需要符合规则1.1和1.2：即将对应回调函数推入异步任务队列中</li><li>在<code>resolve()</code>和<code>reject()</code>都没有被调用的情况下，需要符合规则1.3 ： 即使用捕获来处理异常情况</li><li>在executor中调用<code>resolve()</code>或者<code>reject()</code> ，其本质是同步/异步地改变状态和值（多数情况下为同步），然后将<code>promise</code>对象内部的callbacks 中对应的成功或者回调放置在异步队列中进行调用，可能此时callbacks没有回调函数，但是<code>promise.then()</code>是同步的将回调放入自身callbacks中，即<strong>放入回调函数</strong>这一操作永远比在<strong>异步队列中执行回调函数</strong>先执行，这就是为什么Promise的链式调用能够处理异步请求的原因</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Promise</span> (executor) &#123;</span><br><span class="line">    <span class="comment">// 实例的自身状态属性</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="variable constant_">PENDING</span> <span class="comment">// 对象状态默认为pending</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span> = <span class="literal">undefined</span> <span class="comment">// 对象的值默认为undefined</span></span><br><span class="line">    <span class="comment">// 存储自身的回调函数，这个回调函数数组由.then()方法进行传入</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">callbacks</span> = [] <span class="comment">// 元素结构为对象，存储2个函数：&#123;onResolved()&#123;&#125;, onRejected()&#123;&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 此时有的执行器内部调用.resolve()的前后2种状态，</span></span><br><span class="line"><span class="comment">    * 1. 调用resolve()之前自身的状态回调函数才被添加，也就意味着执行器内部立即执行.resolve()</span></span><br><span class="line"><span class="comment">    * 2. 调用resolve()之后自身的状态回调函数才被添加，也就意味着执行器内部延迟执行.resolve()</span></span><br><span class="line"><span class="comment">    * 所以无论何时调用resolve()，它必须在被添加回调callbacks之后才能被调用*/</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 去除后续的resolve调用，保证状态的唯一性</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> !== <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将状态改成fulfilled，并保存value到实例data中</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = <span class="variable constant_">FULFILLED</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span> = value</span><br><span class="line">        <span class="comment">// 如果回调数组中有函数，那么将其推入宏任务队列中，异步调用</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">callbacksObj</span> =&gt;</span> &#123;</span><br><span class="line">                    callbacksObj.<span class="title function_">onResolved</span>(value)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 失败状态 同理</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">reason</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> !== <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = <span class="variable constant_">REJECTED</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span> = reason</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">callbacksObj</span> =&gt;</span> &#123;</span><br><span class="line">                    callbacksObj.<span class="title function_">onRejected</span>(reason)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 即执行外来的executor，并且将2个函数作为参数交给executor,如果有调用resolve或者reject，那也将一并执行,并使用try catch 捕获throw抛出的值或者错误</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="title function_">executor</span>(resolve,reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，如果使用<code>function</code>声明的<code>resolve()</code>和<code>reject()</code>函数，那么内部的<code>this</code>就是指向的<code>window</code>，因为这两个函数被外部传入的箭头函数<code>executor</code>调用，而外部的executor的<code>this</code>指向的是<code>window</code>，那么内部的两个函数就是被<code>windows</code>调用，将<code>resolve()</code>和<code>reject()</code>改为箭头函数声明，即在声明时就执行父级作用域的<code>this</code>，即<code>new</code>语句产生的<code>promise</code>对象</p><h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then ()"></a>Promise.prototype.then ()</h3><p>给<code>Promise</code>主构造函数原型上添加then方法 ，主要用于实例<code>promise</code></p><ul><li><p><code>then()</code> 方法主要是用于同步的将传入的回调函数放入<code>promise</code>的callbacks属性中、或者根据promise的状态调用响应的回调函数，最后返回一个新的<code>promise</code>对象</p></li><li><p><code>_proimise</code>的状态为pending ，那么直接将回调推入callbacks属性中，那么此时构造<code>_proimise</code>的执行器中的<code>resolve()</code> 或者 <code>reject()</code> 还没有被执行，也就是说，在状态还没出现之前，就调用了<code>then()</code>，那么如何在后面异步任务中产生了状态之后就可以马上执行前面<code>then()</code>中的回调以及返回新的<code>promise</code>对象呢？</p><ul><li><p>在<code>resolve()</code> 或者 <code>reject()</code>被调用的时候也会将回调函数数组中的函数加入异步队列中等待调用，而等待到这些函数被调用的时候，即是返回的<code>promise</code>对象获得状态的时候，而传入的回调<code>onResolved</code>和<code>onRejected</code>也有三种情况：返回<code>promise</code>，返回非<code>promise</code>，抛出异常，使用<code>try catch </code>以及递归进行处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="comment">// 当在resolve调用的时候，这里的onResolved会被加入异步队列并被调用，同时也使得返回的promise拥有了状态和值</span></span><br><span class="line">        onResolved (value) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> result = <span class="title function_">onResolved</span>(value)</span><br><span class="line">              <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">                result.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(result)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">              <span class="title function_">reject</span>(error)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          onRejected (reason) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> result = <span class="title function_">onRejected</span>(reason)</span><br><span class="line">              <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">                result.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(result)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">              <span class="title function_">reject</span>(error)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>promise</code>的状态为resolve或者reject，此时异步队列中已经没有执行的回调，需要在接收到回调的时候将其放入异步队列中，即使用计时器，在计时器异步任务中执行对应状态的回调函数</p><ul><li><p>如果状态回调函数返回的是非_Promise类的值，也就是说手动调用<code>onResolved</code> / <code>onRejected</code> 后返回的值不是 <code>Promise</code> 类型，那么返回的新对象就在执行器中直接调用<code>resolve(result)</code>来将返回的promise对象设置为 成功的状态（只要不抛出错误且不返回<code>promise</code>的回调均为成功）</p></li><li><p>状态回调函数内部使用<code>throw</code>抛出了异常或者普通值，那么在<code>catch(error)&#123;&#125;</code>中直接将要返回的promise的状态设置为rejected，且值为error</p></li><li><p>状态回调函数内部返回了一个<code>promise</code>对象，此时需要将这个对象特殊处理</p><ol><li><p>首先整个<code>then()</code>方法的参数接收2个函数参数，返回一个新<code>promise</code>对象，其中构造函数执行器为同步执行，所以将判断代码放入执行器中</p></li><li><p>判断调用<code>then()</code>方法的本体<code>promise</code>的状态，其中最简单的如果是pending状态则就仅仅将回调函数放入返回的新<code>promise</code>对象的回调数组中，然后将在异步任务中被调用，这次情况就符合第一次创建<code>promise</code>对象时，执行器中的<code>resolve()</code>或者<code>rejected()</code>在<strong>异步任务</strong>中的情况</p></li><li><p>如果调用<code>then()</code>方法的本体<code>promise</code>的状态为fulfilled或者rejected ， 此时需要对应状态使用计时器创建一个新的异步任务，并在这个异步任务中调用.then()传入的回调函数，并拿到回调函数返回的结果，通过结果来进一步生成新的<code>promise</code>作为<code>then()</code>的返回结果</p></li></ol></li></ul><blockquote><p>那么此时就会遇到一个问题：如何去继承回调中返回的 promise的状态和值呢？如何判断这个promise的状态是成功还是失败呢？</p></blockquote><p><code>then()</code> 方法就是用来判断调用的promise的成功与失败的方法，那么我们可以<code>then()</code>内的回调中，即返回的<code>promise</code>内也对作为<code>promise</code>对象的结果，调用一次<code>then()</code>，并在其中传入，要返回的新<code>promise</code>的状态设置函数<code>resolve(value)</code>和<code>reject(reason)</code>，这样就可以将后续<code>promise</code>的状态与最终值继承到第一次调用<code>then</code>返回的<code>promise</code>对象中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="variable language_">this</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> handleCallback = <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> result = <span class="title function_">callback</span>(_this.<span class="property">data</span>) <span class="comment">// 将结果计算出来</span></span><br><span class="line">                <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">                    result.<span class="title function_">then</span>(resolve, reject) <span class="comment">// 将上方new Promise的resolve、reject作为结果的promise.then()的回调</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                <span class="title function_">reject</span>(error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在此可以举一个例子：  </p><ul><li><p>假如说现在创建了一个<code>Promise</code>的实例对象<code>p</code>,其状态为fulfilled ，值为<code>11</code></p></li><li><p>然后调用了<code>p.then()</code>，其中成功的回调返回了一个新的<code>Promise</code>实例对象，且状态为成功，值为<code>22</code></p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;<span class="title function_">resolve</span>(<span class="number">22</span>)&#125;))</span><br></pre></td></tr></table></figure><ul><li><p>接着<code>p.then()</code> 调用后，会返回一个新的 <code>Promise</code>实例对象，我们来看这个新的 <code>Promise</code>实例对象是如何产生的</p><ol><li>按照<code>then()</code>的代码进入 <code>return</code>右侧 <code>new Promise()</code>的执行器中，在这里，我们将这个 <code>new Promise()</code>最后所构造出来的对象称为 <code>p1</code></li><li>此时的<code>this</code>为最前面的实例对象<code>p</code>，对<code>p</code>的状态进行判断，执行转到 <code>else if (this.state === RESOLVED) &#123;...&#125;</code>中，其内部为一整个异步任务，被主线程放到异步队列中等待执行，此时<code>p.then()</code>的同步任务就执行完毕了</li><li>假设同步任务已经执行完毕，现在跳转到异步任务中执行，也就是开始执行<code>setTimeout</code>中回调的内容，异步任务开始</li><li>在 <code>try catch</code> 中,<code>p.then()</code> 内部的函数将<code>p.data</code>作为参数放入传入的 <code>value=&gt; ...</code> 箭头函数中执行，此时的<code>onResolved(this.data)</code>就等于带着参数执行了<code>value =&gt; new Promise((resolve,reject) =&gt; &#123;resolve(22)&#125;</code></li><li>此时判断result，发现返回了一个<code>Promise</code>的实例对象，这里简称<code>result</code>，其状态为<code>fulfilled</code>，值为22，那么调用这个实例对象<code>result.then()</code>，且成功、失败的的回调函数分别为<code>p1</code>的<code>resolve(value)</code>和<code>reject(reason)</code></li><li>进入到<code>result.then()</code>中，同样又进入一个新promise的创建流程，进入执行器，判断<code>result</code>的状态，上方我们设置的为成功的状态，那么在同步队列执行完的异步队列中同样执行了<code>let result = onResolved(this.data)</code>这一句，且此时的<code>onResolved(this.data)</code>就是p1构造器中的<code>resolve(value)</code>，调用之后，此时p1的对返回的<code>promise</code>对象的<code>this.data</code>继承已经完成了</li><li>这个时候构造p1的异步任务已经完成了，此时通过return返回，成为<code>p.then()</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span> (<span class="params">onResolved , onRejected</span>) &#123;</span><br><span class="line"><span class="comment">// 始终返回一个新的_promise，需要判断返回的状态，以及回调返回的值，</span></span><br><span class="line">  <span class="comment">// 将判断任务放入执行器中执行，以便产生不同状态的promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是无状态的，那么直接将回调放入属性中</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">          onResolved (value) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> result = <span class="title function_">onResolved</span>(value)</span><br><span class="line">              <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">                result.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(result)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">              <span class="title function_">reject</span>(error)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          onRejected (reason) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> result = <span class="title function_">onRejected</span>(reason)</span><br><span class="line">              <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">                result.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(result)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">              <span class="title function_">reject</span>(error)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">RESOLVED</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果这个_promise对象有状态，则将其回调放入异步队列中执行，并判断其执行后的返回值是否为_Promise类型</span></span><br><span class="line">      <span class="comment">// 如果是，则需要使用自身的.then来判断在其手动创建的_promise的执行器到底是调用了那个状态函数</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> result = <span class="title function_">onResolved</span>(<span class="variable language_">this</span>.<span class="property">data</span>)</span><br><span class="line">          <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">Promise</span>)&#123;</span><br><span class="line">            <span class="comment">// result.then(</span></span><br><span class="line">              <span class="comment">// 如果手动返回的_promise的执行器中调用的是resolve()，那么则会执行</span></span><br><span class="line">              <span class="comment">// 当成功/失败时，将原来的.then()对象也为成功/失败，并且继承回调内部返回的_promise的值</span></span><br><span class="line">              <span class="comment">//value =&gt; resolve(value),</span></span><br><span class="line">              <span class="comment">//reason =&gt; reject(reason)</span></span><br><span class="line">            <span class="comment">//)</span></span><br><span class="line">            result.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(result)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> result = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">data</span>)</span><br><span class="line">          <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">Promise</span>)&#123;</span><br><span class="line">            result.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(result)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时会发现，上面的代码<code>try catch</code>部分重复了4次，所以将重复代码提取为一个新函数，并增加异常传透的功能</p></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) &#123;</span><br><span class="line">  <span class="comment">// 实现传透</span></span><br><span class="line">  <span class="comment">// 如果没有传入成功的回调函数，当promise成功时，会默认将onResolved赋值为一个函数，通过返回值来传递成功的promise</span></span><br><span class="line">  <span class="comment">// 如果没有传入失败的回调函数，当遇到失败的promise时，将onRejected默认赋值为一个函数，通过抛出值来传递失败的的promise</span></span><br><span class="line">  onResolved = <span class="keyword">typeof</span> onResolved === <span class="string">&#x27;function&#x27;</span> ? onResolved : <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;</span><br><span class="line">  <span class="comment">// 始终返回一个新的_promise，需要判断返回的状态，以及回调返回的值，</span></span><br><span class="line">  <span class="comment">// 将判断任务放入执行器中执行，以便产生不同状态的promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleCall</span> = (<span class="params">callback</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">data</span>)</span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">          result.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(result)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是无状态的，那么直接将回调放入属性中</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">          onResolved (value) &#123;</span><br><span class="line">            <span class="title function_">handleCall</span>(onResolved)</span><br><span class="line">          &#125;,</span><br><span class="line">          onRejected (reason) &#123;</span><br><span class="line">            <span class="title function_">handleCall</span>(onRejected)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">RESOLVED</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果这个_promise对象有状态，则将其回调放入异步队列中执行，并判断其执行后的返回值是否为_Promise类型</span></span><br><span class="line">      <span class="comment">// 如果是，则需要使用自身的.then来判断在其手动创建的_promise的执行器到底是调用了那个状态函数</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">handleCall</span>(onResolved)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">handleCall</span>(onRejected)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候就有一个问题：为什么调用.then()的有状态的promise时候，内部的<code>handleCall(onResolved)</code>要使用异步调用呢？</p><p>这是因为，状态主要是依靠构造promise时执行器中的<code>resolve()</code>和<code>reject()</code>两个函数进行的，而先有回调函数再有状态的原因是在构造器内部使用了计时器调用了<code>resolve()</code>和<code>reject()</code>，导致同步的<code>then()</code>先执行，将内部传入的回调放进了<code>promise</code>对象的callbacks中</p><p>但先有状态，后有回调的情况就是：先执行了构造器的所有内容，立即改变了状态以及值，将执行自身的回调函数这一任务放进了计时器，从而变为了在同步任务结束之后的异步任务；接着在结束<code>promise</code>的构造后，立即调用了<code>then()</code></p><p>但进入了.then()后，有状态的promise则不会像无状态的一样，直接放入promise的callbacks，来等待<code>resolve()</code>和<code>reject()</code>，因为已经在执行器里面同步执行过了，这个时候.then()要根据调用回调函数的结果，返回一个新的<code>promise</code>，而这一过程往往是应用于发送异步请求，如果在此处直接调用<code>handleCall(onResolved)</code>，那么主线程就会等待这个<code>then()</code>中回调函数产生的结果从而去创建新promise（包括改变它的状态与值）这一过程，这就违背了Promise思想的初衷</p><p>还有一点是，异步的<code>handleCall(onResolved)</code>与同步创建<code>promise</code>的执行器形成了闭包，这样，<code>handleCall(onResolved)</code>在异步任务中执行时，还可以去改变同步任务时创建的状态为pending的<code>promise</code>对象，然后通过微任务队列，先调用<code>then()</code>的先执行，先改变<code>then()</code>返回的promise的状态，这样就形成了一种前后关系</p><h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h3><p><code>catch()</code>其实就是<code>then()</code>处理失败的情况，传入回调到<code>onRejected</code> 调用并返回<code>then()</code>的结果即可，其中<code>onResolved</code>的位置设置为<code>undefined</code>或者<code>null</code>都可以 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">catch</span> = <span class="keyword">function</span> (<span class="params">onRejected</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">undefined</span>, onRejected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-resolve-value"><a href="#Promise-resolve-value" class="headerlink" title="Promise.resolve(value)"></a>Promise.resolve(value)</h3><p><code>Promise.resolve(value)</code> 返回一个成功的<code>promise</code>，值为<code>value</code>，<code>value</code>的值可以普通值，也可以是<code>promise</code>对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .reslove()返回一个新的promise对象，并且需要判断value的类型</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">resolve</span> = <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">Promise</span>)&#123;</span><br><span class="line">            <span class="comment">// 此处使用传入的promise.then方法来解决新返回的promise的状态</span></span><br><span class="line">            value.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-reject-reason"><a href="#Promise-reject-reason" class="headerlink" title="Promise.reject(reason)"></a>Promise.reject(reason)</h3><p><code>Promise.reject(reason)</code>返回一个失败的<code>promise</code>，值为<code>reason</code>，<code>reason</code>的值只能为非<code>promise</code>类型的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .reject()方法也是返回一个promise对象，并且只接受一个reason</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">reject</span> = <span class="keyword">function</span> (<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(reason)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-all-promiseArray"><a href="#Promise-all-promiseArray" class="headerlink" title="Promise.all(promiseArray)"></a>Promise.all(promiseArray)</h3><p><code>Promise.all(promiseArray)</code> 返回一个<code>promise</code>，接收一个参数<code>promiseArray</code>(_promise数组)，但其中的元素可以是<code>promise</code>对象，也可以是非<code>promise</code>对象</p><ul><li><p>当内部所有promise的状态都为成功的时候，返回成功的promise，且promise的value为一个数组，其值promiseArray所有promise的value</p></li><li><p>否则返回失败的<code>promise</code> 且其value为状态为失败的<code>promise</code>的<code>value</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property">all</span> = <span class="keyword">function</span> (<span class="params">promiseArray</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (promiseArray <span class="keyword">instanceof</span> <span class="title class_">Array</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> valueArray = <span class="keyword">new</span> <span class="title class_">Array</span>(promiseArray.<span class="property">length</span>)</span><br><span class="line">            <span class="keyword">let</span> counter = <span class="number">0</span></span><br><span class="line">            <span class="comment">// 遍历promise数组使用then判断状态，并在回调中执行值的积累和以及改变状态</span></span><br><span class="line">            promiseArray.<span class="title function_">forEach</span>(<span class="function">(<span class="params">promise, idx</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 无论数组中的值是否为promise类型，使用.resolve()将其强制转换为promise对象，再进行.then()的判断</span></span><br><span class="line">                <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(promise).<span class="title function_">then</span>(</span><br><span class="line">                    <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">                        counter++</span><br><span class="line">                        valueArray[idx] = value</span><br><span class="line">                        <span class="keyword">if</span> (counter === promiseArray.<span class="property">length</span>) &#123;</span><br><span class="line">                            <span class="title function_">resolve</span>(valueArray)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="title function_">reject</span>(reason)</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>valueArray[idx] = value 这行为什么不能被 valueArray.push(value )代替呢？</p><p>此处不使用push进行增加元素的原因是因为传入的promise在构造时，可能resolve()或者reject()延迟调用的情况，如果使用了索引，那么在同步遍历时，就以闭包的形式锁定了value在数组中的位置</p></blockquote></li></ul><h3 id="Promise-race-promiseArray"><a href="#Promise-race-promiseArray" class="headerlink" title="Promise.race(promiseArray)"></a>Promise.race(promiseArray)</h3><p><code>Promise.race(promiseArray)</code> 返回一个<code>promise</code>，接收一个参数<code>promiseArray</code>(promise数组)</p><ul><li>返回数组中，最快产生成功或者失败状态的<code>promise</code></li><li>例如：[p1,p2,3]  ,p1延迟2秒更新状态, p2 为同步获得状态，3为非promise，那么将数组看做为一个队列，p2和3为最先获得状态，但p2排在3的前面，所以最终结果输出p2</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property">race</span> = <span class="keyword">function</span> (<span class="params">promiseArr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (promiseArr <span class="keyword">instanceof</span> <span class="title class_">Array</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            promiseArr.<span class="title function_">forEach</span>(<span class="function"><span class="params">__promise</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (promise <span class="keyword">instanceof</span> <span class="title class_">Promise</span>)&#123;</span><br><span class="line">                    promise.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(__promise).<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用微任务"><a href="#使用微任务" class="headerlink" title="使用微任务"></a>使用微任务</h3><p>到此你会发现，当promise调用回调函数的时候，总是使用的<code>setTimeout()</code>来将其模拟为异步任务来调用，这个时候就出现了一个问题:</p><p>如果在所有创建<code>promise</code>对象之前就启动一个0秒的定时器来调用输出，那么这个定时器内的内容一定是最先输出的（宏任务队列）这明显不符合<code>官方Promise</code>的一个特点：始终在异步微任务中调用回调函数；</p><p>通过文档了解到所有定时器函数、ajax请求、DOM事件回调均为宏任务，而因为使用了定时器，以上实现的promise并没有启动任何微任务，那么如何将一个回调函数变成在微任务中执行呢？</p><p>这个问题可以在使用<code>CommandJs</code>模块规范的NodeJs中使用<code>process.nextTick(callback)</code>解决，<code>process.nextTick(callback)</code>在NodeJs中用于将回调函数加入微任务队列，由此就可以真正模拟<code>官方Promise</code>的功能</p><p>以下是<code>Promise</code>构造函数 以及<code>then()</code>方法的的最终代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Promise</span> (executor) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">state</span> = <span class="variable constant_">PENDING</span> </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span> = <span class="literal">undefined</span> </span><br><span class="line">  </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">callbacks</span> = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> !== <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="variable constant_">FULFILLED</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span> = value</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">callbacksObj</span> =&gt;</span> &#123;</span><br><span class="line">          callbacksObj.<span class="title function_">onResolved</span>(value)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">reason</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> !== <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="variable constant_">REJECTED</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span> = reason</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">callbacksObj</span> =&gt;</span> &#123;</span><br><span class="line">          callbacksObj.<span class="title function_">onRejected</span>(reason)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) &#123;</span><br><span class="line">  </span><br><span class="line">  onResolved = <span class="keyword">typeof</span> onResolved === <span class="string">&#x27;function&#x27;</span> ? onResolved : <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> reason</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleCall</span> = (<span class="params">callback</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">data</span>)</span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">          result.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(result)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">        onResolved (value) &#123;</span><br><span class="line">          <span class="title function_">handleCall</span>(onResolved)</span><br><span class="line">        &#125;, onRejected (reason) &#123;</span><br><span class="line">          <span class="title function_">handleCall</span>(onRejected)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">      process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">handleCall</span>(onResolved)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">handleCall</span>(onRejected)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ES6-class（类）版本的-Promise"><a href="#ES6-class（类）版本的-Promise" class="headerlink" title="ES6 class（类）版本的 Promise"></a>ES6 class（类）版本的 Promise</h3><p>新增 <code>Promise.any(array)</code> 方法，其目的与<code>Promise.all(array)</code>方法相反：只要数组中出现成功的状态的<code>promise</code>，立即返回成功状态的<code>promise</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span> (executor) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="variable constant_">PENDING</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">callbacks</span> = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = <span class="variable constant_">FULFILLED</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span> = value</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">callbackObj</span> =&gt;</span> &#123;</span><br><span class="line">              callbackObj.<span class="title function_">onResolved</span>(value)</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">reason</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = <span class="variable constant_">REJECTED</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span> = reason</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">callbackObj</span> =&gt;</span> &#123;</span><br><span class="line">              callbackObj.<span class="title function_">onRejected</span>(reason)</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 实例方法直接使用ES6函数声明方式</span></span><br><span class="line">  then (onResolved, onRejected) &#123;</span><br><span class="line">    onResolved = <span class="keyword">typeof</span> onResolved === <span class="string">&#x27;function&#x27;</span> ? onResolved : <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> reason</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">callbackHandler</span> = (<span class="params">callback</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> result = <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">data</span>)</span><br><span class="line">          <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">            result.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(result)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">          onResolved () &#123;</span><br><span class="line">            <span class="title function_">callbackHandler</span>(onResolved)</span><br><span class="line">          &#125;, onRejected () &#123;</span><br><span class="line">            <span class="title function_">callbackHandler</span>(onRejected)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">        process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">callbackHandler</span>(onResolved)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">callbackHandler</span>(onRejected)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">catch</span> (onRejected) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">undefined</span>, onRejected)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在类中使用关键字 static声明 类本身方法，即此类型方法只属于类本身，而不属于每个类的实例，</span></span><br><span class="line">  <span class="comment">// 以下均为类方法</span></span><br><span class="line">  <span class="keyword">static</span> resolve (value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">        value.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> reject (reason) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(reason)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> all (promiseArr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (promiseArr <span class="keyword">instanceof</span> <span class="title class_">Array</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> data = []</span><br><span class="line">        <span class="keyword">let</span> counter = <span class="number">0</span></span><br><span class="line">        promiseArr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">promise, idx</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(promise).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            counter++</span><br><span class="line">            data[idx] = value</span><br><span class="line">            <span class="keyword">if</span> (counter === promiseArr.<span class="property">length</span>) &#123;</span><br><span class="line">              <span class="title function_">resolve</span>(data)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(reason)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> race (promiseArr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (promiseArr <span class="keyword">instanceof</span> <span class="title class_">Array</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        promiseArr.<span class="title function_">forEach</span>(<span class="function"><span class="params">promise</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(promise).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(value)</span><br><span class="line">          &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(reason)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> any (promiseArr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (promiseArr <span class="keyword">instanceof</span> <span class="title class_">Array</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> data = []</span><br><span class="line">        <span class="keyword">let</span> counter = <span class="number">0</span></span><br><span class="line">        promiseArr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">promise, idx</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(promise).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(value)</span><br><span class="line">          &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            counter++</span><br><span class="line">            data[idx] = reason</span><br><span class="line">            <span class="keyword">if</span> (counter === promiseArr.<span class="property">length</span>) &#123;</span><br><span class="line">              <span class="title function_">reject</span>(data)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Promise面试题"><a href="#Promise面试题" class="headerlink" title="Promise面试题"></a>Promise面试题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>((<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">  &#125;)).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">7</span>)</span><br><span class="line">  <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">8</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>让我们从头开始解析：</p><ol><li>首先第一句执行<code>console.log(0)</code>的计时器进入宏队列</li><li>主线程同步任务到达第一个new，创建第一个promise ，执行内部的<code>console.log(1)</code>，然后执行<code>then()</code>，将 <code>console.log(2)</code> 以下直到 <code>console.log(6)</code>以上的放入微任务队列</li><li>主线程同步任务到达<code>console.log(6)</code>下方的new，创建第二个promise，执行<code>console.log(7)</code>，然后执行<code>then()</code> 将<code>console.log(8)</code>放入微任务队列</li><li>主线程同步任务执行完毕，开始执行异步任务</li><li>首先执行异步微任务队列</li><li>微任务队列中的<strong>第一个</strong>微任务，包含<code>console.log(2)</code> 的<code>.then()</code>代码块被执行，接着进入<code>console.log(2)</code> 下方的new中执行<code>console.log(3)</code>，以及<code>resolve()</code>，再执行<code>.then()</code>，此时将调用<code>console.log(4)</code>的回调放入微任务队列末尾</li><li>此时第一个<code>promise.then()</code>中的代码已经执行完毕了，即产生了结果，所以他的下一个<code>then()</code>被执行，<code>console.log(6)</code>被加入微任务队列</li><li>接下来执行<strong>微任务队列</strong>中的<strong>第二个</strong>异步微任务，即第二个<code>promise.then()</code>中的<code>console.log(8)</code></li><li>接着处理微任务队列中的<strong>第三个</strong>异步微任务，即第<strong>6</strong>步放入的任务，执行完毕后，执行下一个<code>then()</code>，<code>console.log(5)</code>的回调被放入微任务队列</li><li>接着处理微任务队列中的<strong>第四个</strong>异步微任务，即第<strong>7</strong>步被放入的调用<code>console.log(6)</code>的回调</li><li>最后执行微任务队列中最后一个任务，即第<strong>9</strong>步中放入的调用<code>console.log(5)</code>的回调</li><li>此时<strong>微任务队列</strong>中的任务已经全部执行完毕，开始转到<strong>宏任务队列</strong>中，执行下一个宏任务</li><li>第<strong>1</strong>步中的计时器 <code>console.log(0)</code>被执行，整个过程执行完毕</li><li>整体输出 1 7 2 3 8 4 6 5 0</li></ol><h2 id="Promise总结"><a href="#Promise总结" class="headerlink" title="Promise总结"></a>Promise总结</h2><p>最后，简单的总结一下Promise主要的的工作过程</p><ul><li>每个<code>promise</code>对象都拥有一个回调容器，包含成功与失败的回调函数，他们在<code>promise</code>本身被创建的时候为空</li><li><code>promise</code>处理异步任务关键是在于在创建<code>promise</code>时，内部的状态改变函数一般为同步执行，改变立即其状态以及值，但同时将执行自身的回调函数放入异步微任务队列中</li><li>then方法的过程分为两种情况<ul><li>第一种情况是当<code>promise</code>无状态时，将收到的函数<strong>立即</strong>推入<code>promise</code>的回调容器中()，等待主线程处理微任务队列</li><li>第二种情况是当<code>promise</code>有状态时，直接将回调函数调用推入异步微队列，并立即返回一个新的<code>promise</code>（此时状态暂时为<code>pending</code>），利用JS的闭包，将改变这个返回的<code>promise</code>对象<strong>状态</strong>的函数放入微任务中的回调内，这样做就可以在异步微任务中更新立即返回的<code>promise</code>的状态</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 教程 </tag>
            
            <tag> ES6 </tag>
            
            <tag> 异步编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript 实现div的拖拽与变形</title>
      <link href="/2020/08/20/drag-resize/"/>
      <url>/2020/08/20/drag-resize/</url>
      
        <content type="html"><![CDATA[<h1 id="封装一个简单的拖拽-变形的div的模块"><a href="#封装一个简单的拖拽-变形的div的模块" class="headerlink" title="封装一个简单的拖拽+变形的div的模块"></a>封装一个简单的拖拽+变形的div的模块</h1><p>在编写拖拽与变形之前，我们需要知道DOM与元素大小相关的属性</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/EricReevess/proxy/master/img/EED5E2105E90D3063C11A0116A427264.png" alt="elem-size"></p><p>需要的参数：被拖动的元素css选择器elemSelector，容器元素选择器wrapSelector</p><h2 id="拖拽-边界指针提示部分"><a href="#拖拽-边界指针提示部分" class="headerlink" title="拖拽+边界指针提示部分"></a>拖拽+边界指针提示部分</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dragElement</span> (elemSelector, wrapSelector) &#123;</span><br><span class="line">  <span class="keyword">let</span> elemDom = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(elemSelector)</span><br><span class="line">  <span class="keyword">let</span> wrapDom = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(wrapSelector)</span><br><span class="line">  <span class="comment">/* 分别需要 </span></span><br><span class="line"><span class="comment">   鼠标左键按下时相对于被拖动元素内部的坐标mouseDownOffsetX, mouseDownOffsetY</span></span><br><span class="line"><span class="comment">   鼠标指针相对于body可视区域的坐标mouseMoveClientX, mouseMoveClientY</span></span><br><span class="line"><span class="comment">   被拖动元素当前的left 与 top 偏移量 elemLeft, elemTop</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">let</span> &#123; offsetHeight, offsetWidth &#125; = elemDom</span><br><span class="line">  <span class="keyword">let</span> mouseDownOffsetX, mouseDownOffsetY, mouseMoveClientX, mouseMoveClientY, elemLeft, elemTop</span><br><span class="line">  <span class="comment">// 将被拖动元素设置为绝对定位，并且将容器元素设置为相对定位，</span></span><br><span class="line">  wrapDom.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&#x27;relative&#x27;</span></span><br><span class="line">  elemDom.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&#x27;absolute&#x27;</span></span><br><span class="line">  <span class="comment">// 监听鼠标在元素内部的移动事件，为不同区域变换不同的指针类型</span></span><br><span class="line">  elemDom.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, elemMouseMove)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 鼠标按下时的事件，记录按下的坐标，并同时添加在容器内部移动鼠标，松开鼠标，离开区域的监听事件，其中后两个的目的是移除鼠标松开和离开容器时的鼠标移动监听</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">onElemMousedown</span> (e) &#123;</span><br><span class="line">    mouseMoveClientX = e.<span class="property">clientX</span></span><br><span class="line">    mouseMoveClientY = e.<span class="property">clientY</span></span><br><span class="line">    wrapDom.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, mouseMoveOnWrap)</span><br><span class="line">    wrapDom.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseup&#x27;</span>, removeListener)</span><br><span class="line">    wrapDom.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseleave&#x27;</span>, removeListener)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 鼠标在容器上移动的监听事件，实时获取鼠标相对于窗口的坐标，实时改变拖动元素的位置</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">mouseMoveOnWrap</span> (e) &#123;</span><br><span class="line">    clientX = e.<span class="property">clientX</span></span><br><span class="line">    clientY = e.<span class="property">clientY</span></span><br><span class="line">    elemLeft = mouseMoveClientX - mouseDownOffsetX</span><br><span class="line">    elemTop = mouseMoveClientY - mouseDownOffsetY</span><br><span class="line">    elemDom.<span class="property">style</span>.<span class="property">left</span> = elemLeft + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    elemDom.<span class="property">style</span>.<span class="property">top</span> = elemTop + <span class="string">&#x27;px&#x27;</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">elemMouseMove</span> (e) &#123;</span><br><span class="line">    <span class="comment">// 此处内部的offsetX, offsetY记录在移动过程中在被拖动元素内部的位置</span></span><br><span class="line">    <span class="keyword">const</span> &#123; offsetX, offsetY &#125; = e</span><br><span class="line">    <span class="comment">// 在元素被变形的时候更新检测宽度和高度，放置在拖动过程中鼠标形状发生错误</span></span><br><span class="line">    offsetHeight = e.<span class="property">target</span>.<span class="property">offsetHeight</span></span><br><span class="line">    offsetWidth = e.<span class="property">target</span>.<span class="property">offsetWidth</span></span><br><span class="line">    <span class="comment">//如果 鼠标偏移量在一个内部范围内，即内圈范围，则出现move指针形状，并添加鼠标按下监听事件</span></span><br><span class="line">    <span class="keyword">if</span> (offsetX &gt; <span class="number">6</span> &amp;&amp; offsetX &lt; offsetWidth - <span class="number">6</span> &amp;&amp; offsetY &gt; <span class="number">6</span> &amp;&amp; offsetY &lt; offsetHeight - <span class="number">6</span>) &#123;</span><br><span class="line">      e.<span class="property">target</span>.<span class="property">style</span>.<span class="property">cursor</span> = <span class="string">&#x27;move&#x27;</span></span><br><span class="line">      elemDom.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousedown&#x27;</span>, onElemMousedown)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// 此时返回，不做执行移除按下事件</span></span><br><span class="line">    <span class="comment">// 一下是对不同区域变换不同的鼠标指针</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offsetY &gt; -<span class="number">5</span> &amp;&amp; offsetY &lt; <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (offsetX &gt; -<span class="number">5</span> &amp;&amp; offsetX &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        e.<span class="property">target</span>.<span class="property">style</span>.<span class="property">cursor</span> = <span class="string">&#x27;nw-resize&#x27;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offsetX &gt; offsetWidth - <span class="number">5</span> &amp;&amp; offsetX &lt; offsetWidth + <span class="number">5</span>) &#123;</span><br><span class="line">        e.<span class="property">target</span>.<span class="property">style</span>.<span class="property">cursor</span> = <span class="string">&#x27;ne-resize&#x27;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        e.<span class="property">target</span>.<span class="property">style</span>.<span class="property">cursor</span> = <span class="string">&#x27;n-resize&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offsetY &gt; offsetHeight - <span class="number">5</span> &amp;&amp; offsetY &lt; offsetHeight + <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (offsetX &gt; -<span class="number">5</span> &amp;&amp; offsetX &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        e.<span class="property">target</span>.<span class="property">style</span>.<span class="property">cursor</span> = <span class="string">&#x27;sw-resize&#x27;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offsetX &gt; offsetWidth - <span class="number">5</span> &amp;&amp; offsetX &lt; offsetWidth + <span class="number">5</span>) &#123;</span><br><span class="line">        e.<span class="property">target</span>.<span class="property">style</span>.<span class="property">cursor</span> = <span class="string">&#x27;se-resize&#x27;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        e.<span class="property">target</span>.<span class="property">style</span>.<span class="property">cursor</span> = <span class="string">&#x27;n-resize&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offsetX &gt; -<span class="number">5</span> &amp;&amp; offsetX &lt; <span class="number">5</span> || offsetX &gt; offsetWidth - <span class="number">5</span> &amp;&amp; offsetX &lt; offsetWidth + <span class="number">5</span>) &#123;</span><br><span class="line">      e.<span class="property">target</span>.<span class="property">style</span>.<span class="property">cursor</span> = <span class="string">&#x27;e-resize&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      e.<span class="property">target</span>.<span class="property">style</span>.<span class="property">cursor</span> = <span class="string">&#x27;default&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由于这些区域都不是拖动的有效区域，在此最好移除鼠标按下事件</span></span><br><span class="line">    elemDom.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousedown&#x27;</span>, onElemMousedown)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除的事件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeListener</span> (e) &#123;</span><br><span class="line">    e.<span class="property">target</span>.<span class="property">style</span>.<span class="property">cursor</span> = <span class="string">&#x27;default&#x27;</span></span><br><span class="line">    wrapDom.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, mouseMoveOnWrap)</span><br><span class="line">    wrapDom.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mouseup&#x27;</span>, <span class="variable language_">arguments</span>.<span class="property">callee</span>) </span><br><span class="line">    wrapDom.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mouseleave&#x27;</span>, <span class="variable language_">arguments</span>.<span class="property">callee</span>)</span><br><span class="line">    <span class="comment">// 此处调用arguments.callee可将mouseup，mouseleave的监听移除</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="边缘拖拽变形部分"><a href="#边缘拖拽变形部分" class="headerlink" title="边缘拖拽变形部分"></a>边缘拖拽变形部分</h2><p>所需参数，被拖动的元素选择器elemSelector，拖动元素的最小宽度和高度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">resizeRect</span> (elemSelector, minWidth, minHeight) &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  需要的变量鼠标在按下时的浏览器窗口坐标clientClickDownX, clientClickDownY</span></span><br><span class="line"><span class="comment">  鼠标在拖动过程中的浏览器窗口坐标currentClientX, currentClientY</span></span><br><span class="line"><span class="comment">  鼠标在拖动元素内部的相对坐标rectMouseOffsetX, rectMouseOffsetY</span></span><br><span class="line"><span class="comment">  首先初始化记录拖动元素在点击之前的宽度elemWidth和高度elemHeight以及top值和left值</span></span><br><span class="line"><span class="comment">  并设置元素的最小宽度和高度 minWidth，minHeight</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">let</span> clientClickDownX, clientClickDownY, currentClientX, currentClientY, rectMouseOffsetX, rectMouseOffsetY</span><br><span class="line">  <span class="keyword">let</span> elemDom = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(elemSelector)</span><br><span class="line">  <span class="keyword">let</span> elemHeight = elemDom.<span class="property">offsetHeight</span></span><br><span class="line">  <span class="keyword">let</span> elemWidth = elemDom.<span class="property">offsetWidth</span></span><br><span class="line">  <span class="keyword">let</span> elemTop = elemDom.<span class="property">offsetTop</span></span><br><span class="line">  <span class="keyword">let</span> elemLeft = elemDom.<span class="property">offsetLeft</span></span><br><span class="line">  elemDom.<span class="property">style</span>.<span class="property">minHeight</span> = minHeight + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">  elemDom.<span class="property">style</span>.<span class="property">minWidth</span> = minWidth + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">  <span class="comment">// 在按下鼠标的时候，向全局变量记录下按下的浏览器窗口坐标clientClickDown以及元素内部坐标rectMouseOffset</span></span><br><span class="line">  elemDom.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousedown&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    clientClickDownX = e.<span class="property">clientX</span></span><br><span class="line">    clientClickDownY = e.<span class="property">clientY</span></span><br><span class="line">    rectMouseOffsetX = e.<span class="property">offsetX</span></span><br><span class="line">    rectMouseOffsetY = e.<span class="property">offsetY</span></span><br><span class="line">  <span class="comment">// 对按下的位置进行判断，分别为上下左右4条边，同时也将4个交也进行了处理，</span></span><br><span class="line">    <span class="keyword">if</span> (rectMouseOffsetY &gt; <span class="number">0</span> &amp;&amp; rectMouseOffsetY &lt; <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, rectTopResize)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rectMouseOffsetY &lt; elemHeight + <span class="number">5</span> &amp;&amp; rectMouseOffsetY &gt; elemHeight - <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, rectBottomResize)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rectMouseOffsetX &gt; -<span class="number">5</span> &amp;&amp; rectMouseOffsetX &lt; <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, rectLeftResize)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rectMouseOffsetX &lt; elemWidth + <span class="number">5</span> &amp;&amp; rectMouseOffsetX &gt; elemWidth - <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, rectRightResize)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 在鼠标抬起时，存储当前元素的宽高以及定位，为下一次判断与变形做准备，同时移除4个可能的事件监听</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseup&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    elemTop = elemDom.<span class="property">offsetTop</span></span><br><span class="line">    elemLeft = elemDom.<span class="property">offsetLeft</span></span><br><span class="line">    elemHeight = elemDom.<span class="property">offsetHeight</span></span><br><span class="line">    elemWidth = elemDom.<span class="property">offsetWidth</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, rectTopResize)</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, rectBottomResize)</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, rectLeftResize)</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, rectRightResize)</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 顶部变形，顶部的型变量等于 鼠标按下的Y轴坐标clientClickDownY- 鼠标当前的Y轴坐标currentClientY，最终的高度等于 上一次的高度elemHeight + 变化量 ，同时如果要将元素保持在原位（对边或者对角线不动）,则需要改变对应的定位值，top定位值则等于 当前的定位值elemTop - （鼠标按下的Y轴坐标clientClickDownY- 鼠标当前的Y轴坐标currentClientY），左侧变化同理</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">rectTopResize</span> (e) &#123;</span><br><span class="line">    currentClientY = e.<span class="property">clientY</span></span><br><span class="line">    elemDom.<span class="property">style</span>.<span class="property">height</span> = elemHeight + (clientClickDownY - currentClientY) + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (elemDom.<span class="property">offsetHeight</span> === minHeight) &#123;</span><br><span class="line">      elemDom.<span class="property">style</span>.<span class="property">top</span> = elemDom.<span class="property">offsetTop</span> + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      elemDom.<span class="property">style</span>.<span class="property">top</span> = elemTop - (clientClickDownY - currentClientY) + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 底部变形则不需要改变top值，因为div的高度增长默认是向下生长，右侧同理</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">rectBottomResize</span> (e) &#123;</span><br><span class="line">    currentClientY = e.<span class="property">clientY</span></span><br><span class="line">    elemDom.<span class="property">style</span>.<span class="property">height</span> = elemHeight + (currentClientY - clientClickDownY) + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">rectLeftResize</span> (e) &#123;</span><br><span class="line">    currentClientX = e.<span class="property">clientX</span></span><br><span class="line">    elemDom.<span class="property">style</span>.<span class="property">width</span> = elemWidth + (clientClickDownX - currentClientX) + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (elemDom.<span class="property">offsetWidth</span> === minWidth) &#123;</span><br><span class="line">      elemDom.<span class="property">style</span>.<span class="property">left</span> = elemDom.<span class="property">offsetLeft</span> + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      elemDom.<span class="property">style</span>.<span class="property">left</span> = elemLeft - (clientClickDownX - currentClientX) + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">rectRightResize</span> (e) &#123;</span><br><span class="line">    currentClientX = e.<span class="property">clientX</span></span><br><span class="line">    elemDom.<span class="property">style</span>.<span class="property">width</span> = elemWidth + (currentClientX - clientClickDownX) + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="暴露模块"><a href="#暴露模块" class="headerlink" title="暴露模块"></a>暴露模块</h2><p>使用匿名函数自调用(IIFE)，将函数挂载到windows中，成为全局方法,参数minWidth和minHeight默认为5px</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"><span class="variable language_">window</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">dragResize</span> = <span class="keyword">function</span> (<span class="params">elemSelector, wrapSelector, minWidth = <span class="number">5</span>, minHeight = <span class="number">5</span></span>) &#123;</span><br><span class="line">    <span class="title function_">dragElement</span>(elemSelector, wrapSelector)</span><br><span class="line">    <span class="title function_">resizeRect</span>(elemSelector, minWidth, minHeight)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="variable language_">window</span>)</span><br></pre></td></tr></table></figure><p>最终的效果，请访问<a href="https://ericreevess.github.io/webpage-demos/drag-resize/">drag-resize</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> CSS </tag>
            
            <tag> 拖拽 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

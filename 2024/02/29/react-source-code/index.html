<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>React 架构与源码理解 | Reeves'Blog</title><meta name="description" content="前言2023年8月，毕业2年后被裁员失业，只能说塞翁失马，焉知非福。 在21年毕业时，React Hook 已经替代了 Class 组件成为官方推崇的主流，平时上班一直想抽空学习 React 的源码，但是零散时间根本没法集中。趁着去年8月失业的这段时间，集中最近看了卡颂老师的React 技术揭秘，本文记录了学习过程中对 React 源码和架构的理解，文中有对原文的直接或间接引用。 2024年1月2"><meta name="keywords" content="React, JavaScript, 源码"><meta name="author" content="Eric Reeves"><meta name="copyright" content="Eric Reeves"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://ericreevess.gitee.io/2024/02/29/react-source-code/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="React 架构与源码理解"><meta property="og:url" content="https://ericreevess.gitee.io/2024/02/29/react-source-code/"><meta property="og:site_name" content="Reeves'Blog"><meta property="og:description" content="前言2023年8月，毕业2年后被裁员失业，只能说塞翁失马，焉知非福。 在21年毕业时，React Hook 已经替代了 Class 组件成为官方推崇的主流，平时上班一直想抽空学习 React 的源码，但是零散时间根本没法集中。趁着去年8月失业的这段时间，集中最近看了卡颂老师的React 技术揭秘，本文记录了学习过程中对 React 源码和架构的理解，文中有对原文的直接或间接引用。 2024年1月2"><meta property="og:image" content="https://ms314006.github.io/static/b7a8f321b0bbc07ca9b9d22a7a505ed5/97b31/React.jpg"><meta property="article:published_time" content="2024-02-29T03:41:45.486Z"><meta property="article:modified_time" content="2024-02-29T05:13:14.230Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.4.2',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
      const now = new Date()
      const expiryDay = ttl * 86400000
      const item = {
        value: value,
        expiry: now.getTime() + expiryDay,
      }
      localStorage.setItem(key, JSON.stringify(item))
    },
  
  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2024-02-29 13:13:14'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">21</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">41</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">12</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="color"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React%E6%9E%B6%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">React架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#React-15-%E6%9E%B6%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">React 15 架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Reconciler-%E5%8D%8F%E8%B0%83%E5%99%A8"><span class="toc-number">2.1.1.</span> <span class="toc-text">Reconciler 协调器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Render-%E6%B8%B2%E6%9F%93%E5%99%A8"><span class="toc-number">2.1.2.</span> <span class="toc-text">Render 渲染器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#React-15-%E6%9E%B6%E6%9E%84%E4%BA%A7%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.3.</span> <span class="toc-text">React 15 架构产生的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-16-%E6%9E%B6%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">React 16 架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%A9%BA%E9%97%B2%E6%97%B6%E9%97%B4"><span class="toc-number">2.2.1.</span> <span class="toc-text">浏览器空闲时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Scheduler-%E8%B0%83%E5%BA%A6%E5%B1%82"><span class="toc-number">2.2.2.</span> <span class="toc-text">Scheduler 调度层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Reconciler-%E5%8D%8F%E8%B0%83%E5%B1%82-%EF%BC%88%E8%B4%9F%E8%B4%A3%E8%AE%A1%E7%AE%97%E6%9B%B4%E6%96%B0%EF%BC%89"><span class="toc-number">2.2.3.</span> <span class="toc-text">Reconciler 协调层 （负责计算更新）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Render-%E6%B8%B2%E6%9F%93%E5%99%A8-1"><span class="toc-number">2.2.4.</span> <span class="toc-text">Render 渲染器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94%EF%BC%88Algebraic-Effects%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">代数效应（Algebraic Effects）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%89%AF%E4%BD%9C%E7%94%A8"><span class="toc-number">3.1.</span> <span class="toc-text">函数式编程与副作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94%E6%80%9D%E6%83%B3"><span class="toc-number">3.2.</span> <span class="toc-text">代数效应思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React%E4%B8%AD%E7%9A%84%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94"><span class="toc-number">3.3.</span> <span class="toc-text">React中的代数效应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8Generator"><span class="toc-number">3.4.</span> <span class="toc-text">代数效应和生成器Generator</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fiber"><span class="toc-number">4.</span> <span class="toc-text">Fiber</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#React-Fiber-%E8%8A%82%E7%82%B9"><span class="toc-number">4.1.</span> <span class="toc-text">React Fiber 节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fiber-%E6%A0%91%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.</span> <span class="toc-text">Fiber 树结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JSX"><span class="toc-number">5.</span> <span class="toc-text">深入理解JSX</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JSX"><span class="toc-number">5.1.</span> <span class="toc-text">JSX</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-Element-%E5%92%8C-React-Component-%E4%B8%8E-JSX-%E7%9A%84-%E5%85%B3%E7%B3%BB"><span class="toc-number">5.2.</span> <span class="toc-text">React Element 和 React Component 与 JSX 的 关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-createElement"><span class="toc-number">5.3.</span> <span class="toc-text">React.createElement</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-ReactElement"><span class="toc-number">5.4.</span> <span class="toc-text">React.ReactElement</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-Component"><span class="toc-number">5.5.</span> <span class="toc-text">React Component</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSX-%E4%B8%8E-Fiber-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">5.6.</span> <span class="toc-text">JSX 与 Fiber 的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E7%BC%93%E5%AD%98"><span class="toc-number">6.</span> <span class="toc-text">双缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fiberRoot-%E5%92%8C-rootFiber-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.</span> <span class="toc-text">fiberRoot 和 rootFiber 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-%E5%8D%8F%E8%B0%83%E8%BF%87%E7%A8%8B"><span class="toc-number">8.</span> <span class="toc-text">React 协调过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Render-%E9%98%B6%E6%AE%B5"><span class="toc-number">8.1.</span> <span class="toc-text">Render 阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-Fiber-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%9B%E5%BB%BA-fiberRoot-%E5%92%8C-rootFiber"><span class="toc-number">8.1.1.</span> <span class="toc-text">创建 Fiber 数据结构, 创建 fiberRoot 和 rootFiber</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5-legacyCreateRootFromDOMContainer-container%EF%BC%8CforceHydrate-%EF%BC%8C%E6%B8%85%E7%A9%BAroot-DOM-%E5%86%85%E5%AE%B9"><span class="toc-number">8.1.1.1.</span> <span class="toc-text">进入 legacyCreateRootFromDOMContainer(container，forceHydrate)，清空root DOM 内容</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5-createLegacyRoot-container-options-%EF%BC%8C%E5%88%9B%E5%BB%BA-fiberRoot-%E7%9A%84%E5%A4%96%E5%B1%82%E5%AF%B9%E8%B1%A1-rootType"><span class="toc-number">8.1.1.2.</span> <span class="toc-text">进入 createLegacyRoot(container, options)，创建 fiberRoot 的外层对象 rootType</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5-new-ReactDOMBlockingRoot-container-LegacyRoot-options-%EF%BC%8C%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-fiberRoot%E5%AE%9E%E4%BE%8B"><span class="toc-number">8.1.1.3.</span> <span class="toc-text">进入 new ReactDOMBlockingRoot(container, LegacyRoot, options)，创建一个 fiberRoot实例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5-createRootImpl-container-tag-options"><span class="toc-number">8.1.1.4.</span> <span class="toc-text">进入 createRootImpl(container, tag, options)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5-createContainer-container-tag-hydrate-hydrationCallbacks"><span class="toc-number">8.1.1.5.</span> <span class="toc-text">进入 createContainer(container, tag, hydrate, hydrationCallbacks)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5-createFiberRoot-containerInfo-tag-hydrate-hydrationCallbacks"><span class="toc-number">8.1.1.6.</span> <span class="toc-text">进入 createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5-new-FiberRootNode-containerInfo-tag-hydrate-%EF%BC%8C-%E5%88%9B%E5%BB%BAF"><span class="toc-number">8.1.1.7.</span> <span class="toc-text">进入 new FiberRootNode(containerInfo, tag, hydrate)， 创建F</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5-createHostRootFiber-tag"><span class="toc-number">8.1.1.8.</span> <span class="toc-text">进入 createHostRootFiber(tag)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5-createFiber-HostRoot-null-null-mode-%EF%BC%8C%E5%88%9B%E5%BB%BArootFiber"><span class="toc-number">8.1.1.9.</span> <span class="toc-text">进入 createFiber(HostRoot, null, null, mode)，创建rootFiber</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5-new-FiberNode-tag-pendingProps-key-mode-%EF%BC%8C%E5%AE%9E%E4%BE%8B%E5%8C%96-rootFiber"><span class="toc-number">8.1.1.10.</span> <span class="toc-text">进入 new FiberNode(tag, pendingProps, key, mode)，实例化 rootFiber</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E9%98%B6%E6%AE%B5-fiberRoot-%E4%BB%A5%E5%8F%8A-rootFiber"><span class="toc-number">8.1.2.</span> <span class="toc-text">更新阶段 fiberRoot 以及 rootFiber</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#workLoop-%E6%A8%A1%E6%8B%9F%E5%8F%AF%E4%B8%AD%E6%96%AD%E9%80%92%E5%BD%92"><span class="toc-number">8.1.2.1.</span> <span class="toc-text">workLoop 模拟可中断递归</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#performUnitOfWork-%E9%80%92%E5%BD%92%E5%88%9B%E5%BB%BA-fiber-%E5%8D%95%E9%93%BE%E6%A0%91%E7%BB%93%E6%9E%84"><span class="toc-number">8.1.2.2.</span> <span class="toc-text">performUnitOfWork 递归创建 fiber 单链树结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%80%9C%E9%80%92%E2%80%9D%E9%98%B6%E6%AE%B5"><span class="toc-number">8.1.2.3.</span> <span class="toc-text">“递”阶段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%80%9C%E5%BD%92%E2%80%9D%E9%98%B6%E6%AE%B5"><span class="toc-number">8.1.2.4.</span> <span class="toc-text">“归”阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#performUnitOfWork%E6%80%BB%E7%BB%93"><span class="toc-number">8.1.2.4.1.</span> <span class="toc-text">performUnitOfWork总结</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#beginWork"><span class="toc-number">8.1.2.5.</span> <span class="toc-text">beginWork</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#completeWork"><span class="toc-number">8.1.2.6.</span> <span class="toc-text">completeWork</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Commit-%E9%98%B6%E6%AE%B5"><span class="toc-number">8.2.</span> <span class="toc-text">Commit 阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Before-Mutation-%E5%AD%90%E9%98%B6%E6%AE%B5"><span class="toc-number">8.2.1.</span> <span class="toc-text">Before Mutation 子阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%B0%83%E7%94%A8-getSnapshotBeforeUpdate%EF%BC%9F"><span class="toc-number">8.2.1.1.</span> <span class="toc-text">为什么要调用 getSnapshotBeforeUpdate？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8-%E8%B0%83%E5%BA%A6-useEffect-%E7%9A%84-callback"><span class="toc-number">8.2.1.2.</span> <span class="toc-text">如何调用&#x2F;调度 useEffect 的 callback</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mutation-%E5%AD%90%E9%98%B6%E6%AE%B5"><span class="toc-number">8.2.2.</span> <span class="toc-text">Mutation 子阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Placement-effect"><span class="toc-number">8.2.2.1.</span> <span class="toc-text">Placement effect</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Update-effect"><span class="toc-number">8.2.2.2.</span> <span class="toc-text">Update effect</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Deletion-effect"><span class="toc-number">8.2.2.3.</span> <span class="toc-text">Deletion effect</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Layout-%E9%98%B6%E6%AE%B5"><span class="toc-number">8.2.3.</span> <span class="toc-text">Layout 阶段</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Diffing-%E7%AE%97%E6%B3%95"><span class="toc-number">9.</span> <span class="toc-text">Diffing 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-%E8%8A%82%E7%82%B9%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">9.1.</span> <span class="toc-text">DOM 节点的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Diff-%E7%AE%97%E6%B3%95%E9%99%90%E5%88%B6"><span class="toc-number">9.2.</span> <span class="toc-text">Diff 算法限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Diff-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.3.</span> <span class="toc-text">Diff 的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E8%8A%82%E7%82%B9Diff"><span class="toc-number">9.3.1.</span> <span class="toc-text">单节点Diff</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%8A%82%E7%82%B9Diff"><span class="toc-number">9.3.2.</span> <span class="toc-text">多节点Diff</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0"><span class="toc-number">10.</span> <span class="toc-text">状态更新</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%83%E6%99%BA%E6%A8%A1%E5%9E%8B"><span class="toc-number">10.1.</span> <span class="toc-text">心智模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0"><span class="toc-number">10.1.1.</span> <span class="toc-text">同步更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%9B%B4%E6%96%B0"><span class="toc-number">10.1.2.</span> <span class="toc-text">并发更新</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-Hooks"><span class="toc-number">11.</span> <span class="toc-text">React Hooks</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E5%BF%B5"><span class="toc-number">11.1.</span> <span class="toc-text">理念</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://ms314006.github.io/static/b7a8f321b0bbc07ca9b9d22a7a505ed5/97b31/React.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Reeves'Blog</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">React 架构与源码理解</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-29T03:41:45.486Z" title="发表于 2024-02-29 11:41:45">2024-02-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-29T05:13:14.230Z" title="更新于 2024-02-29 13:13:14">2024-02-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JavaScript/">JavaScript</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JavaScript/React/">React</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>46分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2023年8月，毕业2年后被裁员失业，只能说塞翁失马，焉知非福。</p>
<p>在21年毕业时，React Hook 已经替代了 Class 组件成为官方推崇的主流，平时上班一直想抽空学习 React 的源码，但是零散时间根本没法集中。趁着去年8月失业的这段时间，集中最近看了卡颂老师的<a target="_blank" rel="noopener" href="https://react.iamkasong.com/">React 技术揭秘</a>，本文记录了学习过程中对 React 源码和架构的理解，文中有对原文的直接或间接引用。</p>
<p>2024年1月25日再一次被裁员而失业，但需温故知新，重新出发。</p>
<h2 id="React架构"><a href="#React架构" class="headerlink" title="React架构"></a>React架构</h2><h3 id="React-15-架构"><a href="#React-15-架构" class="headerlink" title="React 15 架构"></a>React 15 架构</h3><p>分为两层：</p>
<ul>
<li>Reconciler（协调器）：负责找出变化的组件</li>
<li>Renderer（渲染器）  ：负责将变化的组件渲染到页面上</li>
</ul>
<h4 id="Reconciler-协调器"><a href="#Reconciler-协调器" class="headerlink" title="Reconciler 协调器"></a>Reconciler 协调器</h4><p>对触发更新进行一系列操作：</p>
<ul>
<li>调用函数组件、类组件的render方法，将返回的JSX借助babel转换成js然后递归创建虚拟DOM</li>
<li>将虚拟DOM和上次更新时的虚拟DOM对比</li>
<li>通过对比找出本次更新中变化的虚拟DOM</li>
<li>通知Renderer将变化的虚拟DOM渲染到页面上</li>
</ul>
<h4 id="Render-渲染器"><a href="#Render-渲染器" class="headerlink" title="Render 渲染器"></a>Render 渲染器</h4><p>接受 Reconciler 通知的更新，重新渲染发生变化的组件</p>
<h4 id="React-15-架构产生的问题"><a href="#React-15-架构产生的问题" class="headerlink" title="React 15 架构产生的问题"></a>React 15 架构产生的问题</h4><p>在 React 15 的版本中，协调器和渲染器交替执行，即找到了差异就直接更新差异，让后将多个差异进行批处理<br>协调器使用递归进行DOM树的差异对比，当DOM树一定深度或者页面元素较多时，整个递归更新时间超过了1帧的生成时间16.6ms，如果页面存在交互或者动画，那么就会产生卡顿。</p>
<h3 id="React-16-架构"><a href="#React-16-架构" class="headerlink" title="React 16 架构"></a>React 16 架构</h3><p>分为三层：<br>调度层：调度任务的优先级，将任务细分优先级<br>协调层：构建Fiber 数据结构，通过 Fiber 对象对比差异，记录产生的差异对 DOM 的操作<br>渲染层：负责将更改内容渲染到页面上，也就是 VDOM 到 DOM</p>
<h4 id="浏览器空闲时间"><a href="#浏览器空闲时间" class="headerlink" title="浏览器空闲时间"></a>浏览器空闲时间</h4><p>这里指的浏览器空闲时间是在现代浏览器以60帧每秒的屏幕刷新率下，每一帧的生成时间16.6ms中，主线程执行完任务的空闲时间，React 16 正是利用了这部分时间，将不同优先级的任务分配到这些有限的时间片中，来避免对主线程产生长时间的占用。</p>
<h4 id="Scheduler-调度层"><a href="#Scheduler-调度层" class="headerlink" title="Scheduler 调度层"></a>Scheduler 调度层</h4><p>React 15 没有调度层，使用了 js 自身的递归去遍历 虚拟DOM，js的递归一旦开始就无法暂停，如果当虚拟DOM树过于庞大，或者说层次比较深，那么就会长时间占用js主线程，影响页面的交互，和动画。<br>React 16 于2016年开发，17年下半年发布，放弃了 React 15 的递归 VDOM 对比，使用循环来模拟递归，对比过程使用浏览器的空闲时间完成，不会长期占用js主线程，避免了对比 VDOM 时对页面造成的卡顿</p>
<blockquote>
<p><strong>MDN：</strong><br><strong>requestIdleCallback</strong> 是一个用于在浏览器空闲时执行任务的 API，它允许开发者在不影响用户体验的情况下执行一些较为耗时的任务。这个 API 最早由 Google Chrome 团队提出，并于2015年在 Chrome 浏览器中首次实现。由于不是每个浏览器都支持<strong>requestIdleCallback，React最后没有采用该api</strong></p>
</blockquote>
<p>React 16 中使用的是React 团队自己实现的任务调度库package/scheduler，可以实现在浏览器空闲时执行任务，而且还可以设置任务的优先级，高优先级任务先执行，低优先级任务后执行。</p>
<p>使用循环模拟可中断任务实现的伪代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空闲执行 伪代码</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">workLoop</span>(<span class="params">deadline</span>) &#123;</span><br><span class="line">  <span class="comment">// 停止循环标识</span></span><br><span class="line">  <span class="keyword">let</span> shouldYield = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环条件为存在下一个工作单元，且没有更高优先级的工作</span></span><br><span class="line">  <span class="keyword">while</span> (nextUnitOfWork &amp;&amp; !shouldYield) &#123;</span><br><span class="line">    nextUnitOfWork = <span class="title function_">performUnitOfWork</span>(</span><br><span class="line">        nextUnitOfWork</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 当前帧空余时间要没了，停止工作循环</span></span><br><span class="line">    shouldYield = deadline.<span class="title function_">timeRemaining</span>() &lt; <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 下一个周期空闲时间再执行任务</span></span><br><span class="line">  <span class="title function_">requestIdleCallback</span>(workLoop)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空闲时间执行任务</span></span><br><span class="line"><span class="title function_">requestIdleCallback</span>(workLoop)</span><br></pre></td></tr></table></figure>

<h4 id="Reconciler-协调层-（负责计算更新）"><a href="#Reconciler-协调层-（负责计算更新）" class="headerlink" title="Reconciler 协调层 （负责计算更新）"></a>Reconciler 协调层 （负责计算更新）</h4><p>React 15 中 的协调器绑定了渲染器，只要协调器找到了差异就立即调用渲染器更新页面，寻找差异和渲染是交叉进行的，也就是说渲染完上一个差异后，再寻找下一个差异。<br>但是在React 16 中，将协调器reconciler和渲染器render 分开了，使用了一个新的Fiber 数据结构 对象代替了 React 15 的 虚拟DOM，并且 Fiber 配合协同 scheduler ，可以将 render 阶段的任务拆分。<br>协调器会找出所有差异后，再将差异统一交给渲染器进行更新，协调器的任务就是将差异部分Fiber打上<strong>标记</strong><br>所以说，从React15到React16，协调器（Reconciler）重构的一大目的是：将老的<strong>同步更新</strong>的架构变为<strong>异步可中断更新</strong>。</p>
<h4 id="Render-渲染器-1"><a href="#Render-渲染器-1" class="headerlink" title="Render 渲染器"></a>Render 渲染器</h4><p>根据 Fiber 节点的标记，同步更新对应的DOM<br>Render在执行渲染操作的过程中被设定为不可被打断，而 scheduler 和 reconciler 的任务设定为可以被打断的</p>
<h2 id="代数效应（Algebraic-Effects）"><a href="#代数效应（Algebraic-Effects）" class="headerlink" title="代数效应（Algebraic Effects）"></a>代数效应（Algebraic Effects）</h2><blockquote>
<p>React核心团队成员<a target="_blank" rel="noopener" href="https://github.com/sebmarkbage/">Sebastian Markbåge(opens new window)</a>（React Hooks的发明者）曾说：我们在React中做的就是践行代数效应（Algebraic Effects）。</p>
</blockquote>
<p>代数效应是<strong>函数式编程</strong>中的一个概念，用于将<strong>副作用</strong>从<strong>函数</strong>调用中<strong>分离</strong>。</p>
<h3 id="函数式编程与副作用"><a href="#函数式编程与副作用" class="headerlink" title="函数式编程与副作用"></a>函数式编程与副作用</h3><p>在函数式编程中，强调的是函数的”纯粹性”（purity），纯粹的函数不会产生副作用，其输出只依赖于输入，不会影响外部状态。这种纯粹性使得函数更易于测试、推理和组合。<br><strong>副作用</strong>是指函数的执行会对<strong>函数程序外部的状态</strong>或其他部分产生可观察的影响，这些影响不仅仅体现在函数的返回值上。这种影响可以包括但不限于：</p>
<ol>
<li><strong>修改外部状态：</strong> 如果函数修改了外部变量、数据结构或状态，这被认为是副作用。例如，修改全局变量、数组或对象的值。</li>
<li><strong>I/O 操作：</strong> 与外部世界的交互，如读取或写入文件、发送或接收网络请求、数据库查询等，都会引发副作用，因为它们会影响系统状态。</li>
<li><strong>界面交互：</strong> 当函数导致了用户界面上的可见变化，例如弹出对话框、更新屏幕上的内容或改变网页中的DOM结构，这也被认为是副作用。</li>
</ol>
<h3 id="代数效应思想"><a href="#代数效应思想" class="headerlink" title="代数效应思想"></a>代数效应思想</h3><p>由于js没有原生实现代数效应的机制，代数效应的思想可以用类似于 try catch 的模式进行虚构一个语法<br>平时我们编写业务时需要在同步函数里面依次使用请求获取一些值，这些都是异步操作例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getTotalPicNum</span>(<span class="params">user1, user2</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> picNum1 = <span class="title function_">getPicNum</span>(user1);</span><br><span class="line">  <span class="keyword">const</span> picNum2 = <span class="title function_">getPicNum</span>(user2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> picNum1 + picNum2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如<code>getPicNum</code>是一个异步请求，如果我们需要通过这个异步请求获取器结果，我们通常需要使用async/await</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getTotalPicNum</span>(<span class="params">user1, user2</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> picNum1 = <span class="keyword">await</span> <span class="title function_">getPicNum</span>(user1);</span><br><span class="line">  <span class="keyword">const</span> picNum2 = <span class="keyword">await</span> <span class="title function_">getPicNum</span>(user2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> picNum1 + picNum2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然可以解决问题，但是async改变了getTotalPicNum作为同步函数的调用方法，一般来说async function 具有传染性，会使其调用函数也变为async，会破坏本应该为同步函数的特性<br>那么有没有一种办法能保持getTotalPicNum 的同步特征呢？js没有提供，但是我们可以使用代数效应思想结合try/catch 虚构一个 语法 try/handle 关键字preform/resume<br>传统的try/catch在 try 代码块抛出异常时，那么就会终止执行代码块，转去执行 catch 代码块，错误之后的代码无法被执行，而try/handle 则不同。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getPicNum</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> picNum = perform name;</span><br><span class="line">  <span class="keyword">return</span> picNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title function_">getTotalPicNum</span>(<span class="string">&#x27;kaSong&#x27;</span>, <span class="string">&#x27;xiaoMing&#x27;</span>);</span><br><span class="line">&#125; handle (who) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (who) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;kaSong&#x27;</span>:</span><br><span class="line">      resume <span class="keyword">with</span> <span class="number">230</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;xiaoMing&#x27;</span>:</span><br><span class="line">      resume <span class="keyword">with</span> <span class="number">122</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      resume <span class="keyword">with</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述语法中，当遇到perform 关键字时，就会携带参数转去handle 代码块中执行分支代码，最终使用resume 将结果返回给 perform 左边的变量，而函数getPicNum getTotalPicNum的类型也都未改变，这样分离函数的副作用到handle中，避免了对原函数的影响，实现了关注点分离的效果。</p>
<h3 id="React中的代数效应"><a href="#React中的代数效应" class="headerlink" title="React中的代数效应"></a>React中的代数效应</h3><p>React Hooks 是对 代数效应的一种实践。<br>Hooks为React 函数组件带来了生命周期和状态管理，并且，则不需要改变函数组件的性质（例如前面类似于加个hook function之类的），函数组件内部使用 useState useEffect 等，开发者不需要关注其中的实现，React 会为我们进行处理，开发者的关注点是这个hooks api 给我带来了状态管理和生命周期，我只需要使用他们来编写组件就好了</p>
<h3 id="代数效应和生成器Generator"><a href="#代数效应和生成器Generator" class="headerlink" title="代数效应和生成器Generator"></a>代数效应和生成器Generator</h3><p>从React15到React16，协调器（Reconciler）重构的一大目的是：将老的同步更新的架构变为异步可中断更新。<br>异步可中断更新可以理解为：更新在执行过程中可能会被打断（浏览器时间分片用尽或有更高优任务插队），当可以继续执行时恢复之前执行的中间状态。<br>浏览器原生支持类似异步中断更新的实现，也就是生成器函数<br>生成器函数<code>Generator</code>返回一个迭代器，通过调用迭代器来惰性执行函数体，其中函数体内使用yield关键字进行分步，Generator 是 js 对<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh/%E5%8D%8F%E7%A8%8B">协程</a>的一种实现<br>但是 React 团队因为生成器函数的一些缺陷放弃了使用他实现 <strong>协调器Reconciler</strong>：</p>
<ul>
<li>生成器函数会改变函数调用的方式，也就是说具有传染性，其返回的是一个迭代器，要通过context.next()的方式进行调用。</li>
<li>生成器函数在调用的过程中具有中间状态，并且与上下文关联，也就是中间状态在生成器函数的作用域中</li>
</ul>
<p>例如Hooks 发明者 <a target="_blank" rel="noopener" href="https://github.com/sebmarkbage">sebmarkbage</a> 回答的issue ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">doWork</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="title function_">doExpensiveWorkA</span>(a);</span><br><span class="line">  <span class="keyword">yield</span>;</span><br><span class="line">  <span class="keyword">var</span> y = x + <span class="title function_">doExpensiveWorkB</span>(b);</span><br><span class="line">  <span class="keyword">yield</span>;</span><br><span class="line">  <span class="keyword">var</span> z = y + <span class="title function_">doExpensiveWorkC</span>(c);</span><br><span class="line">  <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>每当浏览器有空闲时间都会依次执行其中一个<code>doExpensiveWork</code>，当时间用尽则会中断，当再次恢复时会从中断位置继续执行。<br>只考虑“单一优先级任务的中断与继续”情况下生成器函数可以很好的实现异步可中断更新。<br>但是当我们考虑“高优先级任务插队”的情况，如果此时已经完成doExpensiveWorkA与doExpensiveWorkB计算出x与y。此时B组件接收到一个高优更新，我们要重新计算 <code>var y = x + doExpensiveWorkB(b);</code><br>由于每一次更新任务队列，都需要重新创建一个生成器的上下文，而我们想复用的<code>x</code>又是在之前的生成器上下文中，那么就无法重用<code>x</code>的值了</p>
<h2 id="Fiber"><a href="#Fiber" class="headerlink" title="Fiber"></a>Fiber</h2><p>Fiber 是 React 16中 的一个数据结构，用于 reconciler 中对比差异，Fiber这个词在计算机科学中不是什么新名词，中文名为<strong>纤程，</strong>Wiki 中描述到：</p>
<blockquote>
<p>在<strong>计算机科学</strong>中，<strong>纤程</strong>（英语：Fiber）是一种最轻量化的<strong>线程</strong>（lightweight threads）。它是一种用户态线程（user thread），让<strong>应用程式</strong>可以独立决定自己的线程要如何运作。作业系统<strong>内核</strong>不能看见它，也不会为它进行<strong>排程</strong>。</p>
</blockquote>
<p>在 React 的官方文档中有这样的描述：</p>
<blockquote>
<p><strong>“fiber” reconciler 是一个新尝试，致力于解决 stack reconciler 中固有的问题，同时解决一些历史遗留问题。Fiber 从 React 16 开始变成了默认的 reconciler。</strong><br><strong>它的主要目标是：</strong></p>
<ul>
<li><strong>能够把可中断的任务切片处理。</strong></li>
<li><strong>能够调整优先级，重置并复用任务。</strong></li>
<li><strong>能够在父元素与子元素之间交错处理，以支持 React 中的布局。</strong></li>
<li><strong>能够在 render() 中返回多个元素。</strong></li>
<li><strong>更好地支持错误边界。</strong></li>
</ul>
</blockquote>
<p>可以理解为 Fiber 是 React 自己实现的一套机制，支持任务不同优先级，可中断与恢复，并且恢复后可以复用之前的中间状态。</p>
<h3 id="React-Fiber-节点"><a href="#React-Fiber-节点" class="headerlink" title="React Fiber 节点"></a>React Fiber 节点</h3><p><strong>Fiber包含三层含义</strong>：</p>
<ol>
<li>作为架构来说，之前React15的Reconciler采用递归的方式执行，数据保存在递归调用栈中，所以被称为stack Reconciler。React16的Reconciler基于Fiber节点实现，被称为Fiber Reconciler。</li>
<li>作为静态的数据结构来说，每个Fiber节点对应一个React element，保存了该组件的类型（函数组件/类组件/原生组件…）、对应的DOM节点等信息。</li>
<li>作为动态的工作单元来说，每个Fiber节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新…）。</li>
</ol>
<p>react 16 使用 Fiber 树代替了 虚拟DOM树，每个fiber 节点中有许多与 dom fiber 更新，副作用 等相关的属性</p>
<ul>
<li>与DOM实例相关：<ul>
<li>tag: 代表Fiber 所部表示的React 元素的类型，以number表示</li>
<li>type: 保存组件的基础类型，或者构造函数、类</li>
<li>stateNode: 当前fiber 对应的 原生DOM 的实例</li>
</ul>
</li>
<li>与构建 Fiber 树相关的<ul>
<li>return: 指向该fiber 节点的 父级fiber 节点的指针</li>
<li>child: 指向当前fiber的第一个子fiber</li>
<li>sibling: 指向当前fiber 的下一个兄弟节点</li>
<li>index: fiber索引</li>
<li>alternate: 与 workInProgress 树中 的fiber 节点互相指向，</li>
</ul>
</li>
<li>组件状态 props相关的<ul>
<li>pendingProps: fiber即将更新的props</li>
<li>memoizedProps：上一次的 props</li>
<li>memoizedState： 上一次的 state</li>
</ul>
</li>
<li>副作用相关属性<ul>
<li>updateQueue： 当前 fiber 的 state 的更新操作 和 回调函数 的队列</li>
<li>flags： 当前 fiber 需要执行的dom 操作</li>
<li>subtreeFlags： 记录当前 fiber节点的子树 要执行的 DOM 操作</li>
<li>deletions： 记录需要删除的子fiber</li>
<li>nextEffect：  下一个需要执行副作用的 兄弟 fiber 节点</li>
<li>firstEffect、lastEffect： 记录当前 fiber 节点的 子fiber 中，第一个和最后一个需要执行副作用的子fiber节点</li>
<li>mode：更新页面的渲染模式，不同组件可能使用不同模式</li>
</ul>
</li>
</ul>
<h3 id="Fiber-树结构"><a href="#Fiber-树结构" class="headerlink" title="Fiber 树结构"></a>Fiber 树结构</h3><p><strong>Fiber 树是一个 单链表树结构（Singly Linked List Tree Structure）</strong><br>例如下面的组件结构：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">a</span>&gt;</span>link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">img</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的 Fiber 树为:<br><img src= "/img/loading.gif" data-lazy-src="fiber_tree_example.png" alt="Fiber 树图示"></p>
<p>从fiber 树的 结构以及 更新的方式来看，fiber之间使用的链表结构来进行收集更新，也就是为什么能在判断中使用React hooks</p>
<h2 id="深入理解JSX"><a href="#深入理解JSX" class="headerlink" title="深入理解JSX"></a>深入理解JSX</h2><h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><p>JSX是 一种 声明式的语法，用来描述React 的组件内容结构<br>JSX代码会在编译时会被Babel编译为React.createElement方法。所以在每一个JSX文件中需要导入React<br>在React 17 中，已经不需要编写 React 导入，babel与React 团队合作，将jsx文件默认导入了一个<code>_jsx</code>函数用于转换JSX代码</p>
<h3 id="React-Element-和-React-Component-与-JSX-的-关系"><a href="#React-Element-和-React-Component-与-JSX-的-关系" class="headerlink" title="React Element 和 React Component 与 JSX 的 关系"></a>React Element 和 React Component 与 JSX 的 关系</h3><h3 id="React-createElement"><a href="#React-createElement" class="headerlink" title="React.createElement"></a>React.createElement</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createElement</span>(<span class="params">type, config, children</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> propName;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> props = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> key = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> ref = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> source = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (config != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 将 config 处理后赋值给 props</span></span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> childrenLength = <span class="variable language_">arguments</span>.<span class="property">length</span> - <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 处理 children，会被赋值给props.children</span></span><br><span class="line">  <span class="comment">// ...省略</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理 defaultProps</span></span><br><span class="line">  <span class="comment">// ...省略</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">ReactElement</span>(</span><br><span class="line">    type,</span><br><span class="line">    key,</span><br><span class="line">    ref,</span><br><span class="line">    self,</span><br><span class="line">    source,</span><br><span class="line">    <span class="title class_">ReactCurrentOwner</span>.<span class="property">current</span>,</span><br><span class="line">    props,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 type config children 创建一个 描述 DOM 的 React Element</p>
<ol>
<li>从 config 中分离内部预留属性:<code>key ref self source</code></li>
<li>初始化 props，如果type是组件，那么将type.defaultProps与props 合并</li>
<li>处理 children， createElement 支持在从children参数后传入多个children，<ol>
<li>如果只有一个children，那么props.children = children</li>
<li>如果有多个children，那么props.children = childArray</li>
</ol>
</li>
<li>将处理好的几个数据交给 ReactElement 函数生成 element 对象</li>
<li>如果是开发环境，通过 defineProperty 为 props上的key 和 ref 设置 一个getter 函数， 在开发者在组件内部访问props.key 或者 props.ref 时给予使用错误，</li>
</ol>
<h3 id="React-ReactElement"><a href="#React-ReactElement" class="headerlink" title="React.ReactElement"></a>React.ReactElement</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ReactElement</span> = <span class="keyword">function</span>(<span class="params">type, key, ref, self, source, owner, props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> element = &#123;</span><br><span class="line">    <span class="comment">// 标记这是个 React Element</span></span><br><span class="line">    <span class="attr">$$typeof</span>: <span class="variable constant_">REACT_ELEMENT_TYPE</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">type</span>: type,</span><br><span class="line">    <span class="attr">key</span>: key,</span><br><span class="line">    <span class="attr">ref</span>: ref,</span><br><span class="line">    <span class="attr">props</span>: props,</span><br><span class="line">    <span class="attr">_owner</span>: owner,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>创建 react element 对象的工厂方法，其作用就是将传递的参数<code>type,props,key,ref,owner,self</code>放入js对象中，再使用<code>$$typeof</code>将这个js对象标记为 React Element<code>REACT_ELEMENT_TYPE</code> 类型（Symbol）,然后返回该对象</p>
<h3 id="React-Component"><a href="#React-Component" class="headerlink" title="React Component"></a>React Component</h3><p>React Component 指的是我们在编写时，使用class 或者 function 声明的 React 组件，这是一个抽象的组件概念，其背后都会生成对应的 Element 对象，由于class 只是 es6 构建对象的语法糖，所以使用 instanceof无法区分class 组件 和 function 组件，React 通过 在编写 class 组件时 组件继承的 ClassComponent 实例的原型上的<code>isReactComponent</code> 来标记class 组件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ClassComponent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">isReactComponent</span> = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="JSX-与-Fiber-的关系"><a href="#JSX-与-Fiber-的关系" class="headerlink" title="JSX 与 Fiber 的关系"></a>JSX 与 Fiber 的关系</h3><p>JSX是一种描述组件内容的类似HTML的语法，目的是生成React Element数据结构<br>React Element 用来提供在 Reconciler 中创建 对应 fiber 节点的一些基本DOM信息，例如 type，key，props 等</p>
<h2 id="双缓存"><a href="#双缓存" class="headerlink" title="双缓存"></a>双缓存</h2><p>React 16后 的 DOM更新使用的双缓存，也就是在当前已有的计算结果下，在内存中保存下一次更新的结果，从而达到快速更新的目的<br>React 16+ 使用 双缓存完成FIber树的构建以及DOM的快速更新，在React 运行时会同时存在 2最多 个Fiber 树结构，<br>第一个是current fiber tree ，也就是记录了当前页面展现的内容的树，当发生更新时，会重新构建一颗 WorkingInProgress fiber tree，其中记录即将要渲染到页面的内容，当WorkingInProgress 构建完成之后，会直接在内存中替换 current fiber tree，在替换之前，current fiber tree 上的每个节点内的 alternate 属性都指向 WorkingInProgress fiber tree 中对应的节点，同理 WorkingInProgress fiber tree 中的每个节点的 alternate 也指向  current fiber tree 的对应节点</p>
<p>React 初始构建时，会将root fiber作为 current fiber tree ，且只有一个fiber 节点，然后复制一份 root fiber ，让 current fiber tree的 根 fiber 中alternate 指向 复制后的 new root fiber 节点，让 new root fiber 作为 WorkingInProgress fiber tree 的根节点，然后在WorkingInProgress fiber tree中构建子fiber树，更新完毕之后，将 current fiber tree 替换为 WorkingInProgress fiber tree，WorkingInProgress fiber tree 就 成为 了current fiber tree</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">currentFiber.<span class="property">alternate</span> === workInProgressFiber;</span><br><span class="line">workInProgressFiber.<span class="property">alternate</span> === currentFiber;</span><br></pre></td></tr></table></figure>

<p>在每个fiber 中 都存储了 DOM ，fiber 完成构建后，所有 DOM 也都被创建（更新）了</p>
<h2 id="fiberRoot-和-rootFiber-的区别"><a href="#fiberRoot-和-rootFiber-的区别" class="headerlink" title="fiberRoot 和 rootFiber 的区别"></a>fiberRoot 和 rootFiber 的区别</h2><p>fiberRoot 指的是Fiber 数据结构的最外层对象，可以看做是 Fiber树的控制器，记录当前fiber树的信息信息等数据<br>rootFiber 指的是 fiber 树的根节点，对应的是组件挂载时对应的 root div<br>fiberRoot 可以 包含多个 rootFiber，因为可能会有多个 render 的 root<br>rootFIber 中的stateNode 指向 fiberRoot， fiberRoot中 的current 指向 rootFiber</p>
<h2 id="React-协调过程"><a href="#React-协调过程" class="headerlink" title="React 协调过程"></a>React 协调过程</h2><p>React 的更新分为2个阶段： render 、commit</p>
<ul>
<li>render 阶段：<ul>
<li>此阶段的任务随时可以被打断</li>
<li>此阶段分为两个子阶段<ul>
<li>首次渲染阶段 （mount）</li>
<li>更新阶段 （update）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>render 阶段的流程大致为：</p>
<ol>
<li>先创建 fiberRoot 和 rootFiber ，</li>
<li>根据 React Element 树结构为每一个 react 元素构建 fiber 对象，并创建相应的DOM ，</li>
<li>构建 WorkingInProgress fiber tree ，为需要更新的fiber的标注DOM操作类型flag（初始化渲染只有rootFiber 被标注）</li>
</ol>
<ul>
<li>commit阶段:<ul>
<li>该阶段不可被打断</li>
<li>获取WIP fiber tree， 根据每个Fiber节点的Tag 进行不同类型的DOM操作，也就是渲染器执行阶段，</li>
</ul>
</li>
</ul>
<h3 id="Render-阶段"><a href="#Render-阶段" class="headerlink" title="Render 阶段"></a>Render 阶段</h3><p><strong>render 会先判断 container 是否为DOM，然后将参数交给</strong><code>**legacyRenderSubtreeIntoContainer**</code><strong>函数</strong><br>render 接受3个参数：</p>
<ol>
<li>element：React.createElement 返回的 React 元素js对象</li>
<li>container：DOM 元素</li>
<li>callback： 完成渲染后的回调函数</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactDOM.render() 渲染方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params"></span></span><br><span class="line"><span class="params">  element: React$Element&lt;<span class="built_in">any</span>&gt;, <span class="comment">// createElement 方法的返回值 React 元素对象</span></span></span><br><span class="line"><span class="params">  container: Container, <span class="comment">// root DOM 元素</span></span></span><br><span class="line"><span class="params">  callback: ?<span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">invariant</span>(</span><br><span class="line">    <span class="title function_">isValidContainer</span>(container), <span class="comment">// 检测container 是否为 DOM 元素</span></span><br><span class="line">    <span class="string">&#x27;Target container is not a DOM element.&#x27;</span>,</span><br><span class="line">  );</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 开发者警告提示</span></span><br><span class="line">  <span class="comment">// if (__DEV__) &#123; ...&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将子树渲染到容器中</span></span><br><span class="line">  <span class="comment">// 操作： 创建 fiberRoot 和 rootFiber</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">legacyRenderSubtreeIntoContainer</span>(</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    element,</span><br><span class="line">    container,</span><br><span class="line">    <span class="literal">false</span>, <span class="comment">// 是否是服务器渲染，在服务器渲染中会复用DOM元素，否则会清空DOM中的内容</span></span><br><span class="line">    callback,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建-Fiber-数据结构-创建-fiberRoot-和-rootFiber"><a href="#创建-Fiber-数据结构-创建-fiberRoot-和-rootFiber" class="headerlink" title="创建 Fiber 数据结构, 创建 fiberRoot 和 rootFiber"></a>创建 Fiber 数据结构, 创建 fiberRoot 和 rootFiber</h4><p>legacyRenderSubtreeIntoContainr 函数将子树渲染到容器中，开始创建fiberRoot，此函数接受5个参数：</p>
<ol>
<li>parentComponent：父 react 组件</li>
<li>children：子节点列表</li>
<li>container：要渲染子树的容器</li>
<li>forceHydrate：是否启用服务器渲染</li>
<li>callback： 渲染完成后的回调</li>
</ol>
<p>在初始渲染时，只需传入element 到 children ，container ， callback 三个参数</p>
<ol>
<li>访问<code>container._reactRootContainer</code> 判断该 container 是<strong>执行初始化渲染，还是更新渲染</strong></li>
<li>初始渲染下，使用 DOM 元素 container，调用<code>legacyCreateRootFromDOMContainer(container)</code>创建 <code>fiberRoot</code>和 <code>rootFIber</code></li>
<li>此时 上面说到的current fiber tree 已经构建完成</li>
<li>处理 callback 的 this 指向，指向 root DOM的实例，函数组件作为 root DOM 时初始化渲染时<strong>没有实例的</strong></li>
<li>调用<code>updateContainer</code>使用非批量更新，防止初始化渲染时，更新被打断</li>
<li>返回 <code>ReactDOM.render</code> 中第一个参数的 DOM 实例对象，如果是 React 组件 那么返回 null ，在初始化时，这里返回null</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">legacyRenderSubtreeIntoContainer</span>(<span class="params"></span></span><br><span class="line"><span class="params">  parentComponent: ?React$Component&lt;<span class="built_in">any</span>, <span class="built_in">any</span>&gt;,</span></span><br><span class="line"><span class="params">  children: ReactNodeList,</span></span><br><span class="line"><span class="params">  container: Container,</span></span><br><span class="line"><span class="params">  forceHydrate: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params">  callback: ?<span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 开发者警告提示</span></span><br><span class="line">  <span class="comment">// if (__DEV__) &#123; ...&#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 此处访问_reactRootContainer 是为了检测是否已经是初始化后的容器</span></span><br><span class="line">  <span class="comment">// _reactRootContainer 不存在 以为着需要进行初始渲染</span></span><br><span class="line">  <span class="comment">// _reactRootContainer 存在 意味着需要进行更新渲染</span></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">root</span>: <span class="title class_">RootType</span> = (container.<span class="property">_reactRootContainer</span>: <span class="built_in">any</span>);</span><br><span class="line">  <span class="keyword">let</span> fiberRoot;</span><br><span class="line">  <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">    <span class="comment">// 初始化挂载，创建fiberRoot</span></span><br><span class="line">    root = container.<span class="property">_reactRootContainer</span> = <span class="title function_">legacyCreateRootFromDOMContainer</span>(</span><br><span class="line">      container,</span><br><span class="line">      forceHydrate,</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 取得 fiberRoot</span></span><br><span class="line">    fiberRoot = root.<span class="property">_internalRoot</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> originalCallback = callback;</span><br><span class="line">      callback = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> instance = <span class="title function_">getPublicRootInstance</span>(fiberRoot);</span><br><span class="line">        originalCallback.<span class="title function_">call</span>(instance);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Initial mount should not be batched.</span></span><br><span class="line">    <span class="comment">// 初始化挂载不执行批量更新</span></span><br><span class="line">    <span class="comment">// 由于批量更新 batchUpdates 可以被打断，但是初始化时需要一次性渲染完成，不能被打断</span></span><br><span class="line">    <span class="title function_">unbatchedUpdates</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">updateContainer</span>(children, fiberRoot, parentComponent, callback);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 更新渲染的分支</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回的是 ReactDOM.render 中第一个参数的DOM实例对象</span></span><br><span class="line">  <span class="comment">// 如果是 React 组件 那么返回 null ，在初始化时，这里一般返回null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getPublicRootInstance</span>(fiberRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="进入-legacyCreateRootFromDOMContainer-container，forceHydrate-，清空root-DOM-内容"><a href="#进入-legacyCreateRootFromDOMContainer-container，forceHydrate-，清空root-DOM-内容" class="headerlink" title="进入 legacyCreateRootFromDOMContainer(container，forceHydrate)，清空root DOM 内容"></a>进入 legacyCreateRootFromDOMContainer(container，forceHydrate)，清空root DOM 内容</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">legacyCreateRootFromDOMContainer</span>(<span class="params"></span></span><br><span class="line"><span class="params">  container: Container,</span></span><br><span class="line"><span class="params">  forceHydrate: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">RootType</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> shouldHydrate =</span><br><span class="line">    forceHydrate || <span class="title function_">shouldHydrateDueToLegacyHeuristic</span>(container);</span><br><span class="line">  <span class="comment">//非服务器渲染下， 先清空这个root DOM 内的所有元素</span></span><br><span class="line">  <span class="keyword">if</span> (!shouldHydrate) &#123;</span><br><span class="line">    <span class="keyword">let</span> warned = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> rootSibling;</span><br><span class="line">    <span class="comment">// 这里从DOM内的最后一个孩子开始移除</span></span><br><span class="line">    <span class="keyword">while</span> ((rootSibling = container.<span class="property">lastChild</span>)) &#123;</span><br><span class="line">     <span class="comment">// if (__DEV__)  &#123; ... &#125;</span></span><br><span class="line">      container.<span class="title function_">removeChild</span>(rootSibling);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// if (__DEV__)  &#123; ... &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清空完成之后，调用创建 Root 的方法，返回 一个对象，将初始化完成后的 fiberRoot对象 挂载到 _internalRoot 属性 上</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createLegacyRoot</span>(</span><br><span class="line">    container,</span><br><span class="line">    shouldHydrate</span><br><span class="line">      ? &#123;</span><br><span class="line">          <span class="attr">hydrate</span>: <span class="literal">true</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      : <span class="literal">undefined</span>,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>先判断是否服务器渲染，在服务器渲染下，不会清空节点内容</li>
<li>不是服务器渲染，那么使用循环从DOM内部的最后一个子元素开始删除所有内部DOM元素</li>
<li>返回 <code>createLegacyRoot(container, shouldHydrate)</code> 调用后的结果，由于后续均为非服务器渲染，这里先忽略服务器渲染的参数</li>
</ol>
<ul>
<li><strong>问题：为什么要先清除DOM中的内容？</strong><ul>
<li>React 需要将DOM 中的内容进行全面托管，避免了不受控制的DOM掺杂进去影响页面</li>
<li>避免React渲染结果与现有的元素冲突</li>
<li>清除无用的事件监听，清除DOM，那么也就清除了监听事件</li>
</ul>
</li>
</ul>
<p>所以说，清除 DOM 内容是为了确保 React 在开始渲染之前处于一个干净、一致且可控制的状态，以便它可以有效地构建和管理整个应用的渲染。</p>
<h5 id="进入-createLegacyRoot-container-options-，创建-fiberRoot-的外层对象-rootType"><a href="#进入-createLegacyRoot-container-options-，创建-fiberRoot-的外层对象-rootType" class="headerlink" title="进入 createLegacyRoot(container, options)，创建 fiberRoot 的外层对象 rootType"></a>进入 createLegacyRoot(container, options)，创建 fiberRoot 的外层对象 rootType</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">RootType</span> = &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="attr">children</span>: <span class="title class_">ReactNodeList</span>): <span class="built_in">void</span>,</span><br><span class="line">  <span class="title function_">unmount</span>(): <span class="built_in">void</span>,</span><br><span class="line">  <span class="attr">_internalRoot</span>: <span class="title class_">FiberRoot</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createLegacyRoot</span>(<span class="params"></span></span><br><span class="line"><span class="params">  container: Container,</span></span><br><span class="line"><span class="params">  options?: RootOptions,</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">RootType</span> &#123;</span><br><span class="line">  <span class="comment">// 使用root DOM， LegacyRoot 类型的常量，返回一个 ReactDOMBlockingRoot 实例化的新对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReactDOMBlockingRoot</span>(container, <span class="title class_">LegacyRoot</span>, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>此函数中，直接返回了 <code>ReactDOMBlockingRoot(container, LagacyRoot, options)</code>实例化的js对象，类型为 RootType，其中第二个参数 LegacyRoot 是一个值为 0 的类型常量，</li>
<li>此处的 LegacyRoot 其实代表的是使用 ReactDOM.render 渲染的 root</li>
<li>React 每个版本都在添加一些实验性的功能来改变渲染的方式：</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// react v17.0.2 </span></span><br><span class="line"><span class="comment">// src/react/packages/react-reconciler/src/ReactRootTags.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">RootTag</span> = <span class="number">0</span> | <span class="number">1</span> | <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过调用 ReactDOM.render 的 Root类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">LegacyRoot</span> = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 通过调用 ReactDOM.createBlockingRoot</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">BlockingRoot</span> = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 通过调用 ReactDOM.createRoot</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ConcurrentRoot</span> = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h5 id="进入-new-ReactDOMBlockingRoot-container-LegacyRoot-options-，创建一个-fiberRoot实例"><a href="#进入-new-ReactDOMBlockingRoot-container-LegacyRoot-options-，创建一个-fiberRoot实例" class="headerlink" title="进入 new ReactDOMBlockingRoot(container, LegacyRoot, options)，创建一个 fiberRoot实例"></a>进入 new ReactDOMBlockingRoot(container, LegacyRoot, options)，创建一个 fiberRoot实例</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ReactDOMBlockingRoot</span>(<span class="params"></span></span><br><span class="line"><span class="params">  container: Container,</span></span><br><span class="line"><span class="params">  tag: RootTag,</span></span><br><span class="line"><span class="params">  options: <span class="built_in">void</span> | RootOptions,</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 将 fiberRoot 挂载到 _internalRoot 属性上</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_internalRoot</span> = <span class="title function_">createRootImpl</span>(container, tag, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReactDOMBlockingRoot 其实就是返回了一个只有一个<code>_internalRoot</code>属性的对象，<code>this._internalRoot</code>使用<code>createRootImpl(container, tag, options)</code>创建的</p>
<h5 id="进入-createRootImpl-container-tag-options"><a href="#进入-createRootImpl-container-tag-options" class="headerlink" title="进入 createRootImpl(container, tag, options)"></a>进入 createRootImpl(container, tag, options)</h5><p>这个方法内主要是 使用<code>createContainer(container, tag, hydrate, hydrationCallbacks)</code>创建fiberRoot对象，并且标记DOM 为fiber的根节点，然后再使用事件委托接管DOM上的所有事件，最后返回fiberRoot</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// createRootImpl 函数创建 fiberRoot 后 并委托 root DOM上的所有事件，返回 fiberRoot 对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createRootImpl</span>(<span class="params"></span></span><br><span class="line"><span class="params">  container: Container,</span></span><br><span class="line"><span class="params">  tag: RootTag,</span></span><br><span class="line"><span class="params">  options: <span class="built_in">void</span> | RootOptions,</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// Tag is either LegacyRoot or Concurrent Root</span></span><br><span class="line">  <span class="comment">// 标签 为 LegacyRoot 或者 Concurrent Root 其中之一</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ... 省略一些服务器渲染相关代码</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建 fiberRoot 对象，并且创建 fiberRoot.current = rootFiber</span></span><br><span class="line">  <span class="keyword">const</span> root = <span class="title function_">createContainer</span>(container, tag, hydrate, hydrationCallbacks);</span><br><span class="line">  <span class="comment">//标记DOM为根容器，将rootFiber 挂载到 DOM对象的 [__reactContainer$ + 随机数字] key 中</span></span><br><span class="line">  <span class="title function_">markContainerAsRoot</span>(root.<span class="property">current</span>, container);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取该DOM 的nodeType 属性，类型为 数字</span></span><br><span class="line">  <span class="keyword">const</span> containerNodeType = container.<span class="property">nodeType</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enableEagerRootListeners 默认为 true</span></span><br><span class="line">  <span class="keyword">if</span> (enableEagerRootListeners) &#123;</span><br><span class="line">    <span class="comment">// 这里判断DOM是否是 html的注释类型的DOM，如果是，就取这个节点的父节点</span></span><br><span class="line">    <span class="keyword">const</span> rootContainerElement =</span><br><span class="line">      container.<span class="property">nodeType</span> === <span class="variable constant_">COMMENT_NODE</span> ? container.<span class="property">parentNode</span> : container;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听根 DOM 上所有支持的事件，React 开始 接管 root DOM 上的事件</span></span><br><span class="line">    <span class="title function_">listenToAllSupportedEvents</span>(rootContainerElement);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if (mutableSources) &#123; ... &#125; 服务器渲染相关</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="进入-createContainer-container-tag-hydrate-hydrationCallbacks"><a href="#进入-createContainer-container-tag-hydrate-hydrationCallbacks" class="headerlink" title="进入 createContainer(container, tag, hydrate, hydrationCallbacks)"></a>进入 createContainer(container, tag, hydrate, hydrationCallbacks)</h5><p><code>createContainer</code>其实内部就返回了<code>createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks);</code>的返回结构，真是套娃😓，这下<code>createFiberRoot</code>总算进入创建 fiberRoot 阶段了吧</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">FiberRoot</span> = &#123;</span><br><span class="line">  ...<span class="title class_">BaseFiberRootProperties</span>,</span><br><span class="line">  ...<span class="title class_">ProfilingOnlyFiberRootProperties</span>,</span><br><span class="line">  ...<span class="title class_">SuspenseCallbackOnlyFiberRootProperties</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// createContainer_old</span></span><br><span class="line"><span class="comment">// 使用DOM 创建 fiberRoot</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createContainer</span>(<span class="params"></span></span><br><span class="line"><span class="params">  containerInfo: Container,</span></span><br><span class="line"><span class="params">  tag: RootTag,</span></span><br><span class="line"><span class="params">  hydrate: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params">  hydrationCallbacks: <span class="literal">null</span> | SuspenseHydrationCallbacks,</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">FiberRoot</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createFiberRoot</span>(containerInfo, tag, hydrate, hydrationCallbacks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="进入-createFiberRoot-containerInfo-tag-hydrate-hydrationCallbacks"><a href="#进入-createFiberRoot-containerInfo-tag-hydrate-hydrationCallbacks" class="headerlink" title="进入 createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks)"></a>进入 createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks)</h5><p>createFiberRoot 内，首先通过 构造函数<code>FiberRootNode</code>实例化 fiberRoot 对象<br>然后再使用createHostRootFiber(tag) 创建 一个未初始化的fiber节点uninitializedFiber，此fiber节点就是rootFIber<br>将fiberRoot.current -&gt; rootFIber   rootFiber.stateNode -&gt; fiberRoot<br>最后再初始化rootFIber中的更新队列updateQueue对象，第一个更新任务是空更新</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值先创建 fiberRoot 然后再创建 rootFiber ，初始化 rootFiber.updateQueue</span></span><br><span class="line"><span class="comment">// 返回 fiberRoot</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createFiberRoot</span>(<span class="params"></span></span><br><span class="line"><span class="params">  containerInfo: <span class="built_in">any</span>,</span></span><br><span class="line"><span class="params">  tag: RootTag,</span></span><br><span class="line"><span class="params">  hydrate: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params">  hydrationCallbacks: <span class="literal">null</span> | SuspenseHydrationCallbacks,</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">FiberRoot</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 FiberRootNode 创建 fiberRoot 对象，fiberRoot 用于管理fiber树以及记录fiber 等更新信息</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">root</span>: <span class="title class_">FiberRoot</span> = (<span class="keyword">new</span> <span class="title class_">FiberRootNode</span>(containerInfo, tag, hydrate): <span class="built_in">any</span>);</span><br><span class="line">  <span class="keyword">if</span> (enableSuspenseCallback) &#123;</span><br><span class="line">    root.<span class="property">hydrationCallbacks</span> = hydrationCallbacks;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Cyclic construction. This cheats the type system right now because</span></span><br><span class="line">  <span class="comment">// stateNode is any.</span></span><br><span class="line">  <span class="comment">// 先创建一个未初始化的 root fiber， 也就是 fiber 树根，第一次渲染时，tag为LegacyRoot</span></span><br><span class="line">  <span class="comment">// uninitializedFiber 的 类型 为 Fiber，也就是rootFiber</span></span><br><span class="line">  <span class="keyword">const</span> uninitializedFiber = <span class="title function_">createHostRootFiber</span>(tag);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将rootFiber 放入 rootFiber.current中</span></span><br><span class="line">  root.<span class="property">current</span> = uninitializedFiber;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将rootFiber 的stateNode 指为 fiberRoot</span></span><br><span class="line">  uninitializedFiber.<span class="property">stateNode</span> = root;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对 rootFiber.updateQueue 对象 进行初始化</span></span><br><span class="line">  <span class="title function_">initializeUpdateQueue</span>(uninitializedFiber);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="进入-new-FiberRootNode-containerInfo-tag-hydrate-，-创建F"><a href="#进入-new-FiberRootNode-containerInfo-tag-hydrate-，-创建F" class="headerlink" title="进入 new FiberRootNode(containerInfo, tag, hydrate)， 创建F"></a>进入 new FiberRootNode(containerInfo, tag, hydrate)， 创建F</h5><p><code>FiberRootNode</code> 是fiberRoot对象的构造函数，初始化了一堆默认的属性</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FiberRoot 构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">FiberRootNode</span>(<span class="params">containerInfo, tag, hydrate</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">tag</span> = tag;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">containerInfo</span> = containerInfo;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pendingChildren</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">current</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pingCache</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">finishedWork</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">timeoutHandle</span> = noTimeout;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">context</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pendingContext</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">hydrate</span> = hydrate;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">callbackNode</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">callbackPriority</span> = <span class="title class_">NoLanePriority</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">eventTimes</span> = <span class="title function_">createLaneMap</span>(<span class="title class_">NoLanes</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">expirationTimes</span> = <span class="title function_">createLaneMap</span>(<span class="title class_">NoTimestamp</span>);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pendingLanes</span> = <span class="title class_">NoLanes</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">suspendedLanes</span> = <span class="title class_">NoLanes</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pingedLanes</span> = <span class="title class_">NoLanes</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">expiredLanes</span> = <span class="title class_">NoLanes</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">mutableReadLanes</span> = <span class="title class_">NoLanes</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">finishedLanes</span> = <span class="title class_">NoLanes</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">entangledLanes</span> = <span class="title class_">NoLanes</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">entanglements</span> = <span class="title function_">createLaneMap</span>(<span class="title class_">NoLanes</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (supportsHydration) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">mutableSourceEagerHydrationData</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableSchedulerTracing) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">interactionThreadID</span> = <span class="title function_">unstable_getThreadID</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">memoizedInteractions</span> = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">pendingInteractionMap</span> = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (enableSuspenseCallback) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hydrationCallbacks</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// DEV 警告</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="进入-createHostRootFiber-tag"><a href="#进入-createHostRootFiber-tag" class="headerlink" title="进入 createHostRootFiber(tag)"></a>进入 createHostRootFiber(tag)</h5><p>createHostRootFiber主要是创建 fiber的根 rootFiber，此时会通过tag的类型来决定渲染模式mod，使用<code>ReactDOM.render</code>渲染下，mode 为 同步模式</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">TypeOfMode</span> = <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// react 的渲染模式</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">NoMode</span> = <span class="number">0b00000</span>; <span class="comment">// 同步渲染</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">StrictMode</span> = <span class="number">0b00001</span>; <span class="comment">// 严格模式</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Remove BlockingMode and ConcurrentMode by reading from the root</span></span><br><span class="line"><span class="comment">// tag instead</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">BlockingMode</span> = <span class="number">0b00010</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ConcurrentMode</span> = <span class="number">0b00100</span>; <span class="comment">// 并发模式</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ProfileMode</span> = <span class="number">0b01000</span>; <span class="comment">// 性能测试模式</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">DebugTracingMode</span> = <span class="number">0b10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// createHostRootFiber 用于 使用tag来决定渲染模式，也就是说不同类型的组件会使用不同的渲染模式</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createHostRootFiber</span>(<span class="params">tag: RootTag</span>): <span class="title class_">Fiber</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> mode;</span><br><span class="line">  <span class="keyword">if</span> (tag === <span class="title class_">ConcurrentRoot</span>) &#123;</span><br><span class="line">    <span class="comment">// mode = 0b00100 | 0b00010 | 0b00001 = 0b00111</span></span><br><span class="line">    mode = <span class="title class_">ConcurrentMode</span> | <span class="title class_">BlockingMode</span> | <span class="title class_">StrictMode</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag === <span class="title class_">BlockingRoot</span>) &#123;</span><br><span class="line">    <span class="comment">// mode = 0b00010 | 0b00001 = 0b00011</span></span><br><span class="line">    mode = <span class="title class_">BlockingMode</span> | <span class="title class_">StrictMode</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 在使用ReactDOM.render()创建root fiber时，使用的是同步渲染模式</span></span><br><span class="line">    <span class="comment">// mode = 0b00000</span></span><br><span class="line">    mode = <span class="title class_">NoMode</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableProfilerTimer &amp;&amp; isDevToolsPresent) &#123;</span><br><span class="line">    <span class="comment">// Always collect profile timings when DevTools are present.</span></span><br><span class="line">    <span class="comment">// This enables DevTools to start capturing timing at any point–</span></span><br><span class="line">    <span class="comment">// Without some nodes in the tree having empty base times.</span></span><br><span class="line">    <span class="comment">// mode = mode | ProfileMode</span></span><br><span class="line">    mode |= <span class="title class_">ProfileMode</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个fiber</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createFiber</span>(<span class="title class_">HostRoot</span>, <span class="literal">null</span>, <span class="literal">null</span>, mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 mode 使用 按位或<code>|</code>来巧妙的将不同模式进行归类或者说是聚合，这样后续就可以将mode使用按位与<code>&amp;</code>运算来将结果和目标模式进行对比，以此判断mod中是否包含该目标模式，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mode = <span class="number">0b1100</span>; <span class="comment">// 二进制表示的 mode 变量，假设是 0b1100</span></span><br><span class="line"><span class="keyword">const</span> profileMode = <span class="number">0b0010</span>; <span class="comment">// 二进制表示的需要检查的模式，假设是 0b0010</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用按位与操作符进行检查</span></span><br><span class="line"><span class="keyword">if</span> ((mode &amp; profileMode) === profileMode) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;mode 包含了 profileMode&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;mode 不包含 profileMode&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="进入-createFiber-HostRoot-null-null-mode-，创建rootFiber"><a href="#进入-createFiber-HostRoot-null-null-mode-，创建rootFiber" class="headerlink" title="进入 createFiber(HostRoot, null, null, mode)，创建rootFiber"></a>进入 createFiber(HostRoot, null, null, mode)，创建rootFiber</h5><p>HostRoot表示该fiber节点是一个根Fiber，mode指明该fiber 是什么渲染模式，这里使用的是noMode，即同步渲染<br>在其中返回了一个<code>FiberNode</code>函数的实例化对象 类型为 <code>Fiber</code>， 初始化的 <code>props</code> 和 <code>key</code> 都为空</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createFiber = <span class="keyword">function</span>(<span class="params"></span></span><br><span class="line"><span class="params">  tag: WorkTag,</span></span><br><span class="line"><span class="params">  pendingProps: mixed,</span></span><br><span class="line"><span class="params">  key: <span class="literal">null</span> | <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  mode: TypeOfMode,</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Fiber</span> &#123;</span><br><span class="line">  <span class="comment">// $FlowFixMe: the shapes are exact here but Flow doesn&#x27;t like constructors</span></span><br><span class="line">  <span class="comment">// 通过FiberNode 构造函数创建了一个Fiber实例，而不是使用Fiber</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FiberNode</span>(tag, pendingProps, key, mode);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="进入-new-FiberNode-tag-pendingProps-key-mode-，实例化-rootFiber"><a href="#进入-new-FiberNode-tag-pendingProps-key-mode-，实例化-rootFiber" class="headerlink" title="进入 new FiberNode(tag, pendingProps, key, mode)，实例化 rootFiber"></a>进入 new FiberNode(tag, pendingProps, key, mode)，实例化 rootFiber</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fiber对象实例构造函数，</span></span><br><span class="line"><span class="comment">// 这个构造函数仅仅将fiber 代表的组件类型tag ，即将接受的props，key，该fiber的渲染模式进行了初始化</span></span><br><span class="line"><span class="comment">// 其余值均为空，所以返回的对象 是一个 未完全初始化的fiber 对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">FiberNode</span>(<span class="params"></span></span><br><span class="line"><span class="params">  tag: WorkTag,</span></span><br><span class="line"><span class="params">  pendingProps: mixed,</span></span><br><span class="line"><span class="params">  key: <span class="literal">null</span> | <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  mode: TypeOfMode,</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// Instance</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">tag</span> = tag;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">key</span> = key;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">elementType</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">stateNode</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fiber</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">return</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">child</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sibling</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">index</span> = <span class="number">0</span>;   <span class="comment">// root fiber 的 index = 0</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">ref</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pendingProps</span> = pendingProps;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">memoizedProps</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">updateQueue</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">memoizedState</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">dependencies</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">mode</span> = mode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Effects</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">flags</span> = <span class="title class_">NoFlags</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">nextEffect</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">firstEffect</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">lastEffect</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">lanes</span> = <span class="title class_">NoLanes</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">childLanes</span> = <span class="title class_">NoLanes</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">alternate</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调试相关属性</span></span><br><span class="line">  <span class="comment">// if (enableProfilerTimer) &#123; ... &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// DEV 相关 debug 调试 属性</span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="comment">// This isn&#x27;t directly used but is handy for debugging internals:</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_debugID</span> = debugCounter++;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_debugSource</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_debugOwner</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_debugNeedsRemount</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_debugHookTypes</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!hasBadMapPolyfill &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">Object</span>.<span class="property">preventExtensions</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="更新阶段-fiberRoot-以及-rootFiber"><a href="#更新阶段-fiberRoot-以及-rootFiber" class="headerlink" title="更新阶段 fiberRoot 以及 rootFiber"></a>更新阶段 fiberRoot 以及 rootFiber</h4><p>接着调用<code>updateContainer</code>会正式进入 render 阶段，遍历生成 WIP fiber 树，React 16 + 使用了可中断的循环来模拟递归<br><code>unbatchedUpdates</code>指的是不进行批量更新，首屏渲染需要尽快将画面呈现在页面上</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initial mount should not be batched.</span></span><br><span class="line"><span class="comment">// 初始化挂载不执行批量更新</span></span><br><span class="line"><span class="comment">// 由于批量更新batchUpdates 可以被打断，但是初始化时需要一次性渲染完成，不能被打断</span></span><br><span class="line"><span class="title function_">unbatchedUpdates</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">updateContainer</span>(children, fiberRoot, parentComponent, callback);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="workLoop-模拟可中断递归"><a href="#workLoop-模拟可中断递归" class="headerlink" title="workLoop 模拟可中断递归"></a>workLoop 模拟可中断递归</h5><p>生成WIP fiber 树主要开始于<code>performSyncWorkOnRoot</code>或<code>performConcurrentWorkOnRoot</code>方法的调用，取决于本次更新是同步还是异步可中断更新（初始化的时候调用的是同步更新）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// performSyncWorkOnRoot会调用该方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">workLoopSync</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="title function_">performUnitOfWork</span>(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// performConcurrentWorkOnRoot会调用该方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">workLoopConcurrent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span> &amp;&amp; !<span class="title function_">shouldYield</span>()) &#123;</span><br><span class="line">    <span class="title function_">performUnitOfWork</span>(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>workLoopConcurrent</code>中新增了一个<code>shouldYield</code>函数，<code>shouldYield</code>可以决定工作循环是否继续执行，如果当前帧没有剩余的线程空闲时间，那么就会等到下一个帧再决定是否继续遍历<br><code>workInProgress</code>代表的是当前已经创建的 workInProgress fiber 节点通过循环调用<code>performUnitOfWork</code>来模拟递归</p>
<p>在 <code>workLoopConcurrent</code> 并发模式下我们创建一个比较大的列表：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(e =&gt; e + 1)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">      &#123;new Array(50000).fill(0).map((_, i) =&gt; <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;i + count&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>)&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候我们打开浏览器的performance调试，就会看到以下的结果：<br><code>performWorkUntilDeadline</code>的执行时间基本都是在 5ms 以内<br><img src= "/img/loading.gif" data-lazy-src="react_concurrent_chrome_debug.png" alt="React并发调试"><br>而在当我们在点击一次 ul ，也就是触发一次更新后，疯狂移动鼠标，那么就会发现这样的一种情况<br>这里的 蓝色 Hit Test 指的是浏览器确定用户的鼠标事件，也就是在处理我们疯狂移动鼠标的过程，<br>因为在下一帧生成之前 鼠标事件检测占用了太多的 时间，导致只有几个帧的空闲时间给协调器做差异对比，导致后面React 直接决定调用 <code>renderRootSync</code> 来处理剩下的 fiber，再极端一点，如果整个过程中线程空闲时候非常少，那么React 就不会启用 并发渲染模式，而是直接使用 同步渲染<br><img src= "/img/loading.gif" data-lazy-src="react_sync_chrome_debug.png" alt="React Legacy 调试"></p>
<h5 id="performUnitOfWork-递归创建-fiber-单链树结构"><a href="#performUnitOfWork-递归创建-fiber-单链树结构" class="headerlink" title="performUnitOfWork 递归创建 fiber 单链树结构"></a>performUnitOfWork 递归创建 fiber 单链树结构</h5><p><code>performUnitOfWork</code> 会从 <code>WIP rootFiber</code>节点开始，参考其对等的 <code>unitOfWork.alternate</code> 进行深度优先遍历，该函数工作会有两个阶段：<strong>递</strong> 和 <strong>归</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">performUnitOfWork</span>(<span class="params">unitOfWork: Fiber</span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="comment">// The current, flushed, state of this fiber is the alternate. Ideally</span></span><br><span class="line">  <span class="comment">// nothing should rely on this, but relying on it here means that we don&#x27;t</span></span><br><span class="line">  <span class="comment">// need an additional field on the work in progress.</span></span><br><span class="line">  <span class="keyword">const</span> current = unitOfWork.<span class="property">alternate</span>; <span class="comment">// 拿到 current fiber 树 对应的节点</span></span><br><span class="line">  <span class="title function_">setCurrentDebugFiberInDEV</span>(unitOfWork);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> next;</span><br><span class="line">  <span class="keyword">if</span> (enableProfilerTimer &amp;&amp; (unitOfWork.<span class="property">mode</span> &amp; <span class="title class_">ProfileMode</span>) !== <span class="title class_">NoMode</span>) &#123;</span><br><span class="line">    <span class="title function_">startProfilerTimer</span>(unitOfWork);</span><br><span class="line">    <span class="comment">// 将current fiber节点(current) 与 当前 已创建的WIP fiber 节点(unitOfWork) </span></span><br><span class="line">    <span class="comment">// 交给beginWork，生成下一个节点</span></span><br><span class="line">    next = <span class="title function_">beginWork</span>(current, unitOfWork, subtreeRenderLanes);</span><br><span class="line">    <span class="title function_">stopProfilerTimerIfRunningAndRecordDelta</span>(unitOfWork, <span class="literal">true</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next = <span class="title function_">beginWork</span>(current, unitOfWork, subtreeRenderLanes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">resetCurrentDebugFiberInDEV</span>();</span><br><span class="line">  unitOfWork.<span class="property">memoizedProps</span> = unitOfWork.<span class="property">pendingProps</span>;</span><br><span class="line">  <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// If this doesn&#x27;t spawn new work, complete the current work.</span></span><br><span class="line">    <span class="title function_">completeUnitOfWork</span>(unitOfWork);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    workInProgress = next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title class_">ReactCurrentOwner</span>.<span class="property">current</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="“递”阶段"><a href="#“递”阶段" class="headerlink" title="“递”阶段"></a>“递”阶段</h5><p><code>performUnitOfWork</code>内会将 current fiber节点(current) 与 当前已创建的WIP fiber 节点(unitOfWork) 交给beginWork，进行深度优先遍历来创建子fiber节点，直到遍历到叶子fiber节点（没有子组件的节点）,就进入 <strong>“归”</strong> 阶段</p>
<h5 id="“归”阶段"><a href="#“归”阶段" class="headerlink" title="“归”阶段"></a>“<strong>归</strong>”阶段</h5><p>归阶段会调用<code>completeUnitOfWork</code>处理当前 fiber 节点，当前Fiber 节点如果有兄弟节点 <code>unitOfWork.sibilings !== null</code>那么就会进入到兄弟 fiber 节点的 <strong>“递”</strong>阶段<br>如果不存在兄弟 fiber 节点，那么进入<code>unitOfWork.return</code>的 “归” 阶段，也就是当前 fiber 节点的父节点<br>最终，递归交替执行，会归到 <code>rootFiber</code>，<code>render</code>阶段结束<br>以上面的 App 结构为例：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">a</span>&gt;</span>link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">img</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的递归 fiber 树顺序为:</p>
<p><img src= "/img/loading.gif" data-lazy-src="fiber_tree_recursion.png" alt="递归 fiber 路径"></p>
<h6 id="performUnitOfWork总结"><a href="#performUnitOfWork总结" class="headerlink" title="performUnitOfWork总结"></a>performUnitOfWork总结</h6><p>现在我们大致了解：<br>React 16+ 使用 <code>workLoopSync/workLoopConcurrent</code>配合 <code>performUnitOfWork</code> 以循环的方式深度遍历整个 fiber 树，以此来达到同步、异步可中断的更新<br>其中<code>workLoopSync</code>的更新是不可中断的，其更新模式也也叫 Legacy 模式，用于兼容旧的同步更新，而<code>workLoopConcurrent</code> 则为并发模式，其任务可以被打断，避免协调器长时间占用主线程对界面产生卡顿的问题。<br><code>performUnitOfWork</code>是用于在循环中通过深度遍历 fiber 单链结构树 来构建 <code>workingInProgress</code>fiber 树的，实现了树的非递归遍历，因此可以配合<code>workLoopConcurrent</code> 实现将任务分配到<strong>时间切片</strong>中进行调用</p>
<h5 id="beginWork"><a href="#beginWork" class="headerlink" title="beginWork"></a>beginWork</h5><p>beginWork 做的事情，就是创建当前WIP fiber 节点的子节点 <code>workInProgress.child</code>，相关的代码有 接近 1200 行</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">beginWork</span>(<span class="params"></span></span><br><span class="line"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  workInProgress: Fiber,</span></span><br><span class="line"><span class="params">  renderLanes: Lanes,</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Fiber</span> | <span class="literal">null</span> &#123;</span><br><span class="line"> <span class="comment">// update时：如果current存在可能存在优化路径，可以复用current（即上一次更新的Fiber节点）</span></span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复用current</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">bailoutOnAlreadyFinishedWork</span>(</span><br><span class="line">      current,</span><br><span class="line">      workInProgress,</span><br><span class="line">      renderLanes,</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在首次渲染的时候，除了rootFiber，其余的 WIP fiber 的 current 都为 null ，也就是说，current fiber 树是一颗只有一个节点的树<br>这里使用 current 是为 null 将 beginWork 工作分为两个部分：</p>
<ul>
<li>update：本次是更新，那么满足一定调节可以复用 current</li>
<li>mount：初始化挂载，那么需要创建每一个 子 fiber</li>
</ul>
<p>复用 current 一般发生在该节点在 更新时并没有发生任何变化， 这样可以在 beginWork 中优化<br>在确实需要更新的路径上，通过 fiber 不同的 tag ，以不同的逻辑创建 子 fiber</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mount时：根据tag不同，创建不同的Fiber节点</span></span><br><span class="line"><span class="keyword">switch</span> (workInProgress.<span class="property">tag</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="title class_">IndeterminateComponent</span>: </span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">  <span class="keyword">case</span> <span class="title class_">LazyComponent</span>: </span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">  <span class="keyword">case</span> <span class="title class_">FunctionComponent</span>: </span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">  <span class="keyword">case</span> <span class="title class_">ClassComponent</span>: </span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">  <span class="keyword">case</span> <span class="title class_">HostRoot</span>:</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">  <span class="keyword">case</span> <span class="title class_">HostComponent</span>:</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">  <span class="keyword">case</span> <span class="title class_">HostText</span>:</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">    <span class="comment">// ...省略其他类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常见的函数组件、类组件的创建子 fiber 逻辑最终都会进入 reconcileChildren</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">reconcileChildren</span>(<span class="params"></span></span><br><span class="line"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  workInProgress: Fiber,</span></span><br><span class="line"><span class="params">  nextChildren: <span class="built_in">any</span>,</span></span><br><span class="line"><span class="params">  renderLanes: Lanes</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 对于mount的组件</span></span><br><span class="line">    workInProgress.<span class="property">child</span> = <span class="title function_">mountChildFibers</span>(</span><br><span class="line">      workInProgress,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      nextChildren,</span><br><span class="line">      renderLanes,</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 对于update的组件</span></span><br><span class="line">    workInProgress.<span class="property">child</span> = <span class="title function_">reconcileChildFibers</span>(</span><br><span class="line">      workInProgress,</span><br><span class="line">      current.<span class="property">child</span>,</span><br><span class="line">      nextChildren,</span><br><span class="line">      renderLanes,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>reconcileChildren</code> 实现了 Reconciler 的核心逻辑，而 <code>mountChildFibers</code> 、<code>reconcileChildFibers</code> 都来自于同一个函数 <code>ChildReconciler</code>，他们逻辑基本一致</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reconcileChildFibers = <span class="title class_">ChildReconciler</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mountChildFibers = <span class="title class_">ChildReconciler</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>函数 <code>reconcileChildFibers</code> 的目的就是通过 diff 算法，生成一个新的 fiber 节点，<code>mountChildFibers</code>不同的是，生成的 fiber 节点<strong>没有</strong>标识更新的 flag 属性（之前为effectTag属性）<br>在 <code>src/react/packages/react-reconciler/src/ReactFiberFlags.js</code>中可以看到Flag 的 所有类型，都是以二进制表示，以便使用位操作赋值多个 flag effect</p>
<p>并且在mount 的情况下，WIP fiber 树中只有 rootFiber 会有 flag 标签，也就是说 mount 情况下 只有一次对 DOM 的操作</p>
<p>beginWork 阶段做的就是以当前 WIP fiber 节点，区分mount 和 update 状态，创建 或者 复用 current fiber 子节点 来构建 WIP fiber 子树，给需要更新的 current fiber 子节点 对应的 WIP fiber 节点 打上 flag 更新标志，整个过程属于前面 performUnitOfWork 中的 <strong>“递” 阶段</strong>，直到叶子节点，那么就会调用<code>completeWork</code>进入 <strong>“归” 阶段</strong></p>
<h5 id="completeWork"><a href="#completeWork" class="headerlink" title="completeWork"></a>completeWork</h5><p>类似<code>beginWork</code>，<code>completeWork</code> 也是针对不同 <code>fiber.tag</code>调用不同的处理逻辑。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">completeWork</span>(<span class="params"></span></span><br><span class="line"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  workInProgress: Fiber,</span></span><br><span class="line"><span class="params">  renderLanes: Lanes,</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Fiber</span> | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> newProps = workInProgress.<span class="property">pendingProps</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.<span class="property">tag</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">IndeterminateComponent</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">LazyComponent</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">SimpleMemoComponent</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">FunctionComponent</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">ForwardRef</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Fragment</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Mode</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Profiler</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">ContextConsumer</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">MemoComponent</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">ClassComponent</span>: &#123;</span><br><span class="line">      <span class="comment">// ...省略</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">HostRoot</span>: &#123;</span><br><span class="line">      <span class="comment">// ...省略</span></span><br><span class="line">      <span class="title function_">updateHostContainer</span>(workInProgress);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">HostComponent</span>: &#123;</span><br><span class="line">      <span class="comment">// ...省略</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// ...省略</span></span><br></pre></td></tr></table></figure>

<p>completeWork 主要对 WIP fiber 做以下操作：</p>
<ol>
<li>如果是挂载（mount）类型<ol>
<li>调用<code>createInstance</code>，创建该 fiber 对应的 离屏DOM（offScreen DOM）节点，然后赋给 <code>fiber.stateNode</code></li>
<li>调用<code>appendAllChildren</code>，将所有孩子节点都插入到当前的离屏 DOM节点中</li>
<li>处理 传递给 子节点的 props 和 事件监听</li>
</ol>
</li>
<li>如果是更新（update）类型<ol>
<li>diff props，返回一个需要更新props的 数组 like：<code>[propName1, propValue1, propName2, propsValue2 ]</code></li>
<li>将 props 更新数组放入 updatePayload 赋给 当前 completeWork的 fiber.updateQueue</li>
</ol>
</li>
<li>将有所有 使用 flag标记的 子 fiber 挂载到当前 fiber 的 effectList 末尾，也就是 <code>fiber.firstEffect</code> 和 <code>fiber.lastEffect</code>指向的更新单向链表，这样在 commit 阶段就不需要再遍历一次 WIP fiber 树 来判断每个节点是否有 更新 flag 了，在 commit 阶段，<strong>只需要从 rootFiber.firstEffect 开始访问，就可以找到所有需要更新的 fiber 节点</strong></li>
</ol>
<blockquote>
<p>React团队成员<strong>Dan Abramov</strong>：<code>effectList</code> 相较于 <code>Fiber 树</code>，就像圣诞树上挂的那一串彩灯。</p>
</blockquote>
<p>在 workLoop 完成之后，接下来就进入到 commit 阶段</p>
<h3 id="Commit-阶段"><a href="#Commit-阶段" class="headerlink" title="Commit 阶段"></a>Commit 阶段</h3><p>当整个fiberRoot中的rootFiber 通过 模拟递归 完成 WIP fiber 树的创建之后，会调用 <code>commitRoot(fiberRoot)</code>进入 commit 阶段<br>commit 阶段的主要工作就是 调用 Renderer ，包括执行链表<code>rootFiber.firstEffect</code>上的副作用、调用生命周期Hooks等，该阶段分为三个子阶段，分别对应操作DOM前、中、后：</p>
<ol>
<li>before mutation：主要处理 useEffect 回调、处理 rootFiber 的副作用</li>
<li>mutation： 操作DOM</li>
<li>layout ：操作 DOM 之后</li>
</ol>
<p>在 commit 阶段中的大致流程为：</p>
<ol>
<li>执行或者调度 useEffect 的回调，确保所以 useEffect 的回调都完全被调度，保证他们延迟执行</li>
<li>处理 rootFiber 副作用，如果 rootFiber 有副作用，那么添加到自身的 effectList 末尾</li>
<li>触发生命周期hook，包括<code>componentDidXxx</code> 和 <code>useLayoutEffect</code> <code>useEffect</code> 等，如果这些方法中产生了新的副作用，那么就会开启新的一轮 render -&gt; commit 流程</li>
</ol>
<h4 id="Before-Mutation-子阶段"><a href="#Before-Mutation-子阶段" class="headerlink" title="Before Mutation 子阶段"></a>Before Mutation 子阶段</h4><p>此阶段主要工作是：</p>
<ol>
<li>处理DOM节点渲染/删除后的 autoFocus、blur逻辑</li>
<li>调用 getSnapshotBeforeUpdate 钩子函数</li>
<li>遍历 effectList ，目的是调度 useEffect 的 callback</li>
</ol>
<h5 id="为什么要调用-getSnapshotBeforeUpdate？"><a href="#为什么要调用-getSnapshotBeforeUpdate？" class="headerlink" title="为什么要调用 getSnapshotBeforeUpdate？"></a>为什么要调用 getSnapshotBeforeUpdate？</h5><p>为了代替 componentWillXXX 的钩子，在react 16 之前，componentWillXXX钩子是在render 阶段调用，由于 之前使用的是不可中断的递归遍历，使得 componentWillXXX 在同步递归中只会执行一次，而 react 16 render 阶段可能被中断、重新开始，使得 componentWillXXX 可能会被调用多次<br>官方在react 16 中 使用 getSnapshotBeforeUpdate 作为新的替代钩子，由于commit 阶段是同步的，不可被中断，那么 getSnapshotBeforeUpdate 钩子就只会在执行commit 时 执行一次</p>
<h5 id="如何调用-调度-useEffect-的-callback"><a href="#如何调用-调度-useEffect-的-callback" class="headerlink" title="如何调用/调度 useEffect 的 callback"></a>如何调用/调度 useEffect 的 callback</h5><p>在React 16 中，before mutation 阶段同步地执行完毕了所有的 callback，而在React 17 中所有的 useEffect 的 callback 都是被异步调用的，也就是延迟到页面渲染之后</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调度useEffect</span></span><br><span class="line"><span class="keyword">if</span> ((effectTag &amp; <span class="title class_">Passive</span>) !== <span class="title class_">NoEffect</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!rootDoesHavePassiveEffects) &#123;</span><br><span class="line">    rootDoesHavePassiveEffects = <span class="literal">true</span>;</span><br><span class="line">    <span class="title function_">scheduleCallback</span>(<span class="title class_">NormalSchedulerPriority</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 触发useEffect</span></span><br><span class="line">      <span class="title function_">flushPassiveEffects</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scheduleCallback 是 Scheduler 库提供的，目的是以某个优先级调度callback，flushPassiveEffects 是真正执行 useEffect 方法的函数，也就是说 调用flushPassiveEffects() 会执行 副作用回调函数<br>effectList中链式保存了需要执行副作用的子Fiber节点，包括对DOM 的插入 更新 和删除 等操作，并且如果该Fiber对应的是一个函数组件，该函数组件含有 useEffect 或者 useLayoutEffect，那么该Fiber 的 flag 也会被赋值为 hooks副作用 <code>HasEffect</code><br>useEffect 是在 before mutation 阶段进行异步调度，在 layout 阶段之后进行 callback 调用链的赋值，浏览器完成布局和绘制之后的异步延迟时间中进行的链式调用，这样做是为了避免这些副作用在执行时，阻塞浏览器的渲染过程<br>而 react 提供了 useLayoutEffect ，可以使 effect 在 浏览器 绘制下一帧之前执行</p>
<h4 id="Mutation-子阶段"><a href="#Mutation-子阶段" class="headerlink" title="Mutation 子阶段"></a>Mutation 子阶段</h4><p>渲染页面阶段，也是遍历 effectList 副作用链，只不过执行的是 <code>commitMutationEffects</code>函数 ，这些副作用都与页面上的内容有关，可以理解为执行WIP fiber 上需要更新的副作用，这里的操作主要是操作DOM，对DOM进行插入、更新、删除<br><code>commitMutationEffects</code>函数中对不同的DOM 操作 有不同的处理函数</p>
<h5 id="Placement-effect"><a href="#Placement-effect" class="headerlink" title="Placement effect"></a>Placement effect</h5><p>该操作是指需要将flag为 Placement 的fiber 节点中的 DOM 内容插入到页面中，其中调用react-dom中的方法操作DOM</p>
<h5 id="Update-effect"><a href="#Update-effect" class="headerlink" title="Update effect"></a>Update effect</h5><p>指该fiber 节点需要更新，一般来说该Fiber 节点类型为 一个函数组件<code>FunctionComponent</code>或者原生DOM组件<code>HostComponent</code><br>如果是函数组件，那么会调用 <code>commitHookEffectListUnmount</code>遍历 effectList 中的 useLayoutEffect callback中<strong>返回的销毁函数</strong><br>如果是DOM组件，则会调用 <code>commitUpdate</code>，最终会处理style children 以及一些 props ，将fiber.updateQueue 中更新的内容渲染到页面上</p>
<h5 id="Deletion-effect"><a href="#Deletion-effect" class="headerlink" title="Deletion effect"></a>Deletion effect</h5><p>如果fiber的flag是 Deletion ，那么fiber对应的DOM阶段需要从页面中删除，这个阶段会调用与生命周期结束相关的钩子 例如 useEffect callback 的返回函数， 类组件的 <code>componentWillUnmount</code>，同时解绑释放ref</p>
<h4 id="Layout-阶段"><a href="#Layout-阶段" class="headerlink" title="Layout 阶段"></a>Layout 阶段</h4><p>这个阶段的代码均是在 操作完所有的DOM 后被调用的<br>这里有一个时间差：由于js是同步执行了修改DOM这一系列操作，此时DOM 信息已经在浏览器中改变，但是浏览器并没有渲染这些DOM到页面上，也就是说，这个时机是在浏览器主线程执行因DOM的改变而产生的渲染之前，也就是下一帧更新画面到来之前。<br>在这个阶段，会同步执行<code>commitLayoutEffect</code>，这可能会让浏览器延迟渲染更新的画面<br><code>commitLayoutEffect</code>同样是去遍历effectList，执行所有<code>useLayoutEffect</code>的callback<br>其过程会调用 <code>commitLayoutEffectOnFiber</code>函数，在其中，会调用Class 组件中 设置状态的第二个callback</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">xxx</span>: <span class="number">1</span> &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;i am update~&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里可以发现， <code>useLayoutEffect</code> 和 <code>useEffect</code>的本质区别， 前者的callback 和 销毁return 都是 同步调用，分别layout之后渲染之前、DOM更新之前，而后者 <code>useEffect</code> 则需要先调度，然后再layout 阶段完成之后（代码执行完之后）再<strong>异步执行</strong><br>ReactDOM.render的第三个参数callback也会在此时同步地调用<br>在layout开始前 mutation结束后，会将 WIP rootFiber 赋值到 fiberRoot.current ，这样就将 WIP fiber 变为了 current fiber，此时切换是为了 layout 阶段中的生命周期函数能获取到更新后的DOM</p>
<h2 id="Diffing-算法"><a href="#Diffing-算法" class="headerlink" title="Diffing 算法"></a>Diffing 算法</h2><p>该算法的主要使用场景是：在 render 阶段循环递归 fiber 树时，对于 Update 操作，对比更新前后的fiber 节点，将结果生成新的 fiber 节点，结果可能是复制（没有发生变化），部分复制，其余更新（发生变化）</p>
<h3 id="DOM-节点的关系"><a href="#DOM-节点的关系" class="headerlink" title="DOM 节点的关系"></a>DOM 节点的关系</h3><p>在React 中，一个DOM 节点会有4个相关对象：</p>
<ol>
<li>current fiber 节点，当前页面上 DOM 对应的 fiber</li>
<li>workingInProgress fiber 节点，代表即将即将对该DOM 进行 更新的 fiber</li>
<li>DOM 本身</li>
<li>JSX 对象，也就是该DOM节点对应的React Element 对象</li>
</ol>
<p>Diff 算法运行的本质其实就是将 1 和 4 对比之后，生成 2</p>
<h3 id="Diff-算法限制"><a href="#Diff-算法限制" class="headerlink" title="Diff 算法限制"></a>Diff 算法限制</h3><p>如果要对比两棵fiber树的所有节点，带来指数级的算法复杂度 <code>O(n^3)</code>这里的n指的是树中节点的数量，为了降低复杂度，React的Diff 算法做了三个复杂度限制：</p>
<ol>
<li>只对同级元素进行Diff 计算，如果 一个节点在更新中跨域了层级，那么直接会对其进行销毁并重构，</li>
</ol>
<blockquote>
<p>例如：<br>如果父节点下的子节点有一颗子树，如果更新后子节点变成了父节点的兄弟节点，那么react 会直接删除掉子节点以及所有的子树，然后再父节点的后面的兄弟节点上 重新创建新的 子节点 和 下面的子树</p>
</blockquote>
<ol start="2">
<li>针对不同类型的元素会生成不同的树，如果元素由div 更新 为了 p ，但其子树都不变，那么，React会销毁 div 以及子树，然后新建 p 以及子树</li>
<li>要求开发者在循环渲染的中使用key props进行性能优化</li>
</ol>
<h3 id="Diff-的实现"><a href="#Diff-的实现" class="headerlink" title="Diff 的实现"></a>Diff 的实现</h3><p>Diff 算法的入口在<code>reconcileChildFiber</code> 这里是使用父Fiber 进行 孩子的 Diff</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据newChild类型选择不同diff函数处理</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reconcileChildFibers</span>(<span class="params"></span></span><br><span class="line"><span class="params">  returnFiber: Fiber,</span></span><br><span class="line"><span class="params">  currentFirstChild: Fiber | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  newChild: <span class="built_in">any</span>,</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Fiber</span> | <span class="literal">null</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> isObject = <span class="keyword">typeof</span> newChild === <span class="string">&#x27;object&#x27;</span> &amp;&amp; newChild !== <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isObject) &#123;</span><br><span class="line">    <span class="comment">// object类型，可能是 REACT_ELEMENT_TYPE 或 REACT_PORTAL_TYPE</span></span><br><span class="line">    <span class="keyword">switch</span> (newChild.<span class="property">$$typeof</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="attr">REACT_ELEMENT_TYPE</span>:</span><br><span class="line">        <span class="comment">// 调用 reconcileSingleElement 处理</span></span><br><span class="line">        <span class="comment">// // ...省略其他case</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> newChild === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用 reconcileSingleTextNode 处理</span></span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isArray</span>(newChild)) &#123;</span><br><span class="line">    <span class="comment">// 调用 reconcileChildrenArray 处理</span></span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一些其他情况调用处理函数</span></span><br><span class="line">  <span class="comment">// ...省略</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以上都没有命中，删除节点</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">deleteRemainingChildren</span>(returnFiber, currentFirstChild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Diff的同级比较有两种类型：</p>
<ol>
<li>newChild是单一节点，例如文字节点，单个元素</li>
<li>newChild 是数组节点，也就是同级下有多个节点</li>
</ol>
<h4 id="单节点Diff"><a href="#单节点Diff" class="headerlink" title="单节点Diff"></a>单节点Diff</h4><p>当 newChild 为 jsx 对象或者 string、number 时，进入 <code>reconcileSingleElement</code>进行对比<br><img src= "/img/loading.gif" data-lazy-src="single_node_diff.png" alt="此图片来自 卡颂 的 React 技术揭秘" title="此图片来自 卡颂 的 React 技术揭秘"><br><code>reconcileSingleElement</code>中主要对比 React element 与 current fiber 的 key 以及 type，当key 和 type都相同时，会根据 新的 React element 的props 和复用 现有的 current fiber 创建新的fiber 名为 <code>existing</code>，<br>如果 type 不相同，那么说明两者不属于一个组件，切需要清空 兄弟元素<br>由于React 的 fiber 节点的child 是一个链表结构，当新旧节点的key不相同时，那么说明该fiber 不能被复用，需要删除当前 fiber ，但是兄弟元素不会被删除，因为可能后面的fiber可以复用<br>最后会通过new react element，也就是new child 创建一个新的 fiber</p>
<h4 id="多节点Diff"><a href="#多节点Diff" class="headerlink" title="多节点Diff"></a>多节点Diff</h4><p>此处会处理子节点数组的情况，这是diff 算法的核心部分，比较难以理解，先放到后面再说</p>
<h2 id="状态更新"><a href="#状态更新" class="headerlink" title="状态更新"></a>状态更新</h2><p>在React 中，触发更新的基本都是以下几个api：</p>
<ul>
<li>ReactDOM.render</li>
<li>this.setState</li>
<li>this.forceUpdate</li>
<li>useState</li>
<li>useReducer</li>
</ul>
<p>虽然使用场景不相同，但是他们背后会接入一套统一的更新机制，去触发 render 到 commit ，以更新视图<br>每次状态更新 都会生成一个 <code>Update</code>对象，来保存更新状态的内容，切这个对象保存在触发状态更新的current fiber 节点上<br>调用<code>markUpdateLaneFromFiberToRoot</code>方法，会一直沿着 fiber 的 return 属性，找到 顶层的 rootFiber，然后返回rootFiber<br>拿到rootFiber 后 ，react 就要 调度本次更新任务，决定优先级<code>Lane</code>以及同步或者异步更新<br>调度的回调函数为 render 的 更新阶段入口，也就是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">performSyncWorkOnRoot.<span class="title function_">bind</span>(<span class="literal">null</span>, root);</span><br><span class="line">performConcurrentWorkOnRoot.<span class="title function_">bind</span>(<span class="literal">null</span>, root);</span><br></pre></td></tr></table></figure>

<p>说以说，状态更新的主要路径为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">触发状态更新（根据场景调用不同方法）</span><br><span class="line"></span><br><span class="line">  |</span><br><span class="line">  |</span><br><span class="line">  v</span><br><span class="line"></span><br><span class="line">创建<span class="title class_">Update</span>对象（<span class="string">`updateContainer`</span>）</span><br><span class="line"></span><br><span class="line">  |</span><br><span class="line">  |</span><br><span class="line">  v</span><br><span class="line"></span><br><span class="line">从fiber到root（<span class="string">`markUpdateLaneFromFiberToRoot`</span>）</span><br><span class="line"></span><br><span class="line">  |</span><br><span class="line">  |</span><br><span class="line">  v</span><br><span class="line"></span><br><span class="line">调度更新（<span class="string">`ensureRootIsScheduled`</span>）</span><br><span class="line"></span><br><span class="line">  |</span><br><span class="line">  |</span><br><span class="line">  v</span><br><span class="line"></span><br><span class="line">render阶段（<span class="string">`performSyncWorkOnRoot`</span> 或 <span class="string">`performConcurrentWorkOnRoot`</span>）</span><br><span class="line"></span><br><span class="line">  |</span><br><span class="line">  |</span><br><span class="line">  v</span><br><span class="line"></span><br><span class="line">commit阶段（<span class="string">`commitRoot`</span>）</span><br></pre></td></tr></table></figure>

<h3 id="心智模型"><a href="#心智模型" class="headerlink" title="心智模型"></a>心智模型</h3><p>React 的更新方式分为 两种： 同步更新 和并发更新<br>将两个更新类比与代码版本控制：</p>
<h4 id="同步更新"><a href="#同步更新" class="headerlink" title="同步更新"></a>同步更新</h4><p>使用<code>ReactDOM.render</code>创建的应用都是通过同步更新的方式进行状态更新，他们的状态更新顺序是没有优先级的概念类似于版本迭代<br><img src= "/img/loading.gif" data-lazy-src="react_sync_update.png" alt="React 同步更新"><br>其中 蓝色 代表普通优先级， 红色代表高优先级</p>
<h4 id="并发更新"><a href="#并发更新" class="headerlink" title="并发更新"></a>并发更新</h4><p>在React中，通过<code>ReactDOM.createBlockingRoot</code>和<code>ReactDOM.createRoot</code>创建的应用会采用并发的方式更新状态。<br>也就类似于，使用 git flow 中应对 hotfix 的操作，hotfix 为优先级最高的修复分支<br>当项目出现bug时，需要从 master 切 出一个 hotfix 分支用于紧急修复，并且优先级大于dev分支<br>在修复完成后就hotfix 分支就尽快合并到 master 上，然后 此时 dev 分支上的 旧提交就和 新 master 分支一不一致，那么就要对dev 分支使用 <code>git rebase master</code>来重新接入 dev 分支，保证包含了 hotfix 修复的内容。<br><img src= "/img/loading.gif" data-lazy-src="react_concurrent_update.png" alt="Git rebase"></p>
<p><img src= "/img/loading.gif" data-lazy-src="react_concurrent_update_1.png" alt="React 并发更新"><br>此时的 D 可以理解为 React 更新中的高优先级更新，他可以打断 其余 蓝色 低优先级的更新，先完成 render - commit 阶段<br>也就是说，<strong>React并发模式</strong>的低优先级任务会<strong>根据</strong>高优先级任务<strong>更新后的结果来进行更新</strong></p>
<h2 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h2><h3 id="理念"><a href="#理念" class="headerlink" title="理念"></a>理念</h3><p>正在整理中，未完待续</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Eric Reeves</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ericreevess.gitee.io/2024/02/29/react-source-code/">https://ericreevess.gitee.io/2024/02/29/react-source-code/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ericreevess.gitee.io" target="_blank">Reeves'Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a><a class="post-meta__tags" href="/tags/React/">React</a><a class="post-meta__tags" href="/tags/%E6%BA%90%E7%A0%81/">源码</a><a class="post-meta__tags" href="/tags/%E5%BC%80%E6%BA%90%E6%9E%B6%E6%9E%84/">开源架构</a></div><div class="post_share"><div class="social-share" data-image="https://ms314006.github.io/static/b7a8f321b0bbc07ca9b9d22a7a505ed5/97b31/React.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/07/24/regexp/"><img class="next-cover" data-lazy-src="https://codesource.io/static/5e75f5a67a1abfbc4864baa935cb1286/3c931/Regular-Expressions-RegExp-in-Javascript.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JavaScript正则表达式学习笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/07/24/react-basis/" title="React基础与学习笔记"><img class="cover" data-lazy-src="https://frontendmasters.com/static-assets/learn/og-learning-path-react.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-24</div><div class="title">React基础与学习笔记</div></div></a></div><div><a href="/2023/07/24/ES6-8/" title="ECMAScript6-8 常用特性"><img class="cover" data-lazy-src="https://igormenezes.com/wp-content/uploads/2018/08/ecmascript.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-24</div><div class="title">ECMAScript6-8 常用特性</div></div></a></div><div><a href="/2020/08/23/Promise/" title="实现ES6的新特性——Promise"><img class="cover" data-lazy-src="https://res.cloudinary.com/practicaldev/image/fetch/s--8zpnP7e8--/c_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000/https://thepracticaldev.s3.amazonaws.com/i/vugz15i3sz2asv64clw3.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-23</div><div class="title">实现ES6的新特性——Promise</div></div></a></div><div><a href="/2023/07/24/axios/" title="封装AJAX以及Axios的使用"><img class="cover" data-lazy-src="https://i.morioh.com/2019/11/07/e90866e7658d.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-24</div><div class="title">封装AJAX以及Axios的使用</div></div></a></div><div><a href="/2023/07/24/cube/" title="使用CSS+JS实现一个简单的立方体(可旋转)"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/EricReevess/proxy/master/img/image-20200902163752855.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-24</div><div class="title">使用CSS+JS实现一个简单的立方体(可旋转)</div></div></a></div><div><a href="/2023/07/24/curry/" title="探究函数柯里化"><img class="cover" data-lazy-src="https://wonderdevelop.com/wp-content/uploads/2023/02/What-is-group-selector-in-css-15.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-24</div><div class="title">探究函数柯里化</div></div></a></div></div></div></article></main><footer id="footer" style="background-image: url(https://ms314006.github.io/static/b7a8f321b0bbc07ca9b9d22a7a505ed5/97b31/React.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Eric Reeves</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script defer="defer" id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script></div></body></html>